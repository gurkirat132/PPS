Edition 4.1

[]{#Top}

  ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

The GNU C Programming Tutorial {#the-gnu-c-programming-tutorial .settitle}
==============================

  ------------------------------------------------------------------------ ---- --
  [Preface](#Preface)                                                           
  [1. Introduction](#Introduction)                                              
  [2. Using a compiler](#Using-a-compiler)                                      
  [3. The form of a C program](#The-form-of-a-C-program)                        
  [4. Functions](#Functions)                                                    
  [5. Variables and declarations](#Variables-and-declarations)                  
  [6. Scope](#Scope)                                                            
  [7. Expressions and operators](#Expressions-and-operators)                    
  [8. Parameters](#Parameters)                                                  
  [9. Pointers](#Pointers)                                                      
  [10. Decisions](#Decisions)                                                   
  [11. Loops](#Loops)                                                           
  [12. Preprocessor directives](#Preprocessor-directives)                       
  [13. Libraries](#Libraries)                                                   
  [14. Arrays](#Arrays)                                                         
  [15. Strings](#Strings)                                                       
  [16. Input and output](#Input-and-output)                                     
  [17. Putting a program together](#Putting-a-program-together)                 
  [18. Advanced operators](#Advanced-operators)                                 
  [19. More data types](#More-data-types)                                       
  [20. Data structures](#Data-structures)                                       
  [21. Recursion](#Recursion)                                                   
  [22. Style](#Style)                                                           
  [23. Debugging](#Debugging)                                                   
  [24. Example programs](#Example-programs)                                     
  [A. A note from the original author](#A-note-from-the-original-author)        
  [B. Reserved words in C](#Reserved-words-in-C)                                
  [C. Precedence of operators](#Precedence-of-operators)                        
  [D. Special characters](#Special-characters)                                  
  [E. Character conversion table](#Character-conversion-table)                  
  [F. A word about `goto`](#A-word-about-goto)                                  
  [G. Answers to questions](#Answers-to-questions)                              
  [Bibliography](#Bibliography)                                                 
  [Glossary](#Glossary)                                                         
  [Code index](#Code-index)                                                     
  [Concept index](#Concept-index)                                               
  [Bits and pieces](#Bits-and-pieces)                                           
  ------------------------------------------------------------------------ ---- --

------------------------------------------------------------------------

[]{#Preface}

  ---------------------------------------------------- --------------------------------------------------------- --- ------------ ----------------------------- ------------------------------------------ --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Top "Previous section in reading order")\]   \[[\>](#Introduction "Next section in reading order")\]       \[ \<\< \]   \[[Up](#Top "Up section")\]   \[[\>\>](#Introduction "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ---------------------------------------------------- --------------------------------------------------------- --- ------------ ----------------------------- ------------------------------------------ --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Preface-1}

Preface {#preface .unnumbered}
=======

[]{#index-C-language_002c-why-it-is-useful}
[]{#index-C-language-as-standard}

This book is a tutorial for the computer programming language C. Unlike
BASIC or Pascal, C was not written as a teaching aid, but as a
professional tool. Programmers love C! Moreover, C is a standard,
widely-used language, and a single C program can often be made to run on
many different kinds of computer. As Richard M. Stallman remarks in GNU
Coding Standards, "Using another language is like using a non-standard
feature: it will cause trouble for users." (See
<http://www.gnu.org/prep/standards_toc.html>.)

[]{#index-C-language_002c-unforgiving-nature}
[]{#index-Unforgiving-nature-of-C-language}
[]{#index-C-language_002c-power-of} []{#index-Power-of-C-language}

Skeptics have said that everything that can go wrong in C, does. True,
it can be unforgiving, and holds some difficulties that are not obvious
at first, but that is because it does not withhold its powerful
capabilities from the beginner. If you have come to C seeking a powerful
language for writing everyday computer programs, you will not be
disappointed.

[]{#index-GNU-Project} []{#index-GNU_002fLinux}
[]{#index-Software_002c-free} []{#index-Free-software}

To get the most from this book, you should have some basic computer
literacy --- you should be able to run a program, edit a text file, and
so on. You should also have access to a computer running a GNU system
such as GNU/Linux. (For more information on GNU and the philosophy of
free software, see <http://www.gnu.org/philosophy/>.)

The tutorial introduces basic ideas in a logical order and progresses
steadily. You do not need to follow the order of the chapters
rigorously, but if you are a beginner to C, it is recommended that you
do. Later, you can return to this book and copy C code from it; the many
examples range from tiny programs that illustrate the use of one simple
feature, to complete applications that fill several pages. Along the
way, there are also brief discussions of the philosophy behind C.

[]{#index-Jargon}

Computer languages have been around so long that some jargon has
developed. You should not ignore this jargon entirely, because it is the
language that programmers speak. Jargon is explained wherever necessary,
but kept to a minimum. There is also a glossary at the back of the book.

[]{#index-GNU-Free-Documentation-License} []{#index-GNU-FDL}
[]{#index-Free-Documentation-License} []{#index-FDL}

The authors of this book hope you will learn everything you need to
write simple C programs from this book. Further, it is released under
the GNU Free Documentation License, so as the computers and robots in
the fantasies of Douglas Adams say, "Share and Enjoy!"

\
\
\

*The first edition of this book was written in 1987, then updated and
rewritten in 1999. It was originally published by Dabs Press. After it
went out of print, David Atherton of Dabs and the original author, Mark
Burgess, agreed to release the manuscript. At the request of the Free
Software Foundation, the book was further revised by Ron Hale-Evans in
2001 and 2002.*

[]{#index-Texinfo} []{#index-Emacs-Info-reader} []{#index-Info-reader}

*The current edition is written in Texinfo, which is a documentation
system using a single source file to produce both online information and
printed output. You can read this tutorial online with either the Emacs
Info reader, the stand-alone Info reader, or a World Wide Web browser,
or you can read it as a printed book.*

------------------------------------------------------------------------

[]{#Introduction}

  -------------------------------------------------------- ------------------------------------------------------------ --- ---------------------------------------------------------------------- ----------------------------- ---------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Preface "Previous section in reading order")\]   \[[\>](#Advantages-of-C "Next section in reading order")\]       \[[\<\<](#Preface "Beginning of this chapter or previous chapter")\]   \[[Up](#Top "Up section")\]   \[[\>\>](#Using-a-compiler "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  -------------------------------------------------------- ------------------------------------------------------------ --- ---------------------------------------------------------------------- ----------------------------- ---------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Introduction-1}

1. Introduction {#introduction .chapter}
===============

*What is a high-level language? Why is C unusual?*

[]{#index-Levels-of-detail} []{#index-Detail_002c-levels-of}

Any sufficiently complex object has levels of detail; the amount of
detail we see depends on how closely we scrutinize the object. A
computer has many levels of detail.

[]{#index-Low-level_002c-the} []{#index-High-level_002c-the}

The terms *low level* and *high level* are often used to describe these
layers of complexity in computers. The low level is buried in the
computer's microchips and microcircuits. The low level is the level at
which the computer seems most primitive and mechanical, whereas the high
level describes the computer in less detail, and makes it easier to use.

[]{#index-Car-as-metaphor-for-computer}
[]{#index-Automobile-as-metaphor-for-computer} []{#index-Black-boxes}
[]{#index-Boxes_002c-black}

You can see high levels and low levels in the workings of a car. In a
car, the nuts, bolts, and pistons of the low level can be grouped
together conceptually to form the higher-level engine. Without knowing
anything about the nuts and bolts, you can treat the engine as a *black
box*: a simple unit that behaves in predictable ways. At an even higher
level (the one most people use when driving), you can see a car as a
group of these black boxes, including the engine, the steering, the
brakes, and so on. At a high level, a computer also becomes a group of
black boxes.

[]{#index-C-language-as-high_002dlevel-language}
[]{#index-High_002dlevel-language_002c-C-language-as}

C is a high-level language. The aim of any high-level computer language
is to provide an easy, natural way to give a list of instructions (a
computer program) to a computer. The native language of the computer is
a stream of numbers called *machine language*. As you might expect, the
action resulting from a single machine language instruction is very
primitive, and many thousands of them can be required to do something
substantial. A high-level language provides a set of instructions you
can recombine creatively and give to the imaginary black boxes of the
computer. The high-level language software will then translate these
high-level instructions into low-level machine language instructions.

  --------------------------------------------------------- ---- --
  [1.1 The advantages of C](#Advantages-of-C)                    
  [1.2 Questions for Chapter 1](#Questions-for-Chapter-1)        
  --------------------------------------------------------- ---- --

------------------------------------------------------------------------

[]{#Advantages-of-C}

  ------------------------------------------------------------- -------------------------------------------------------------------- --- --------------------------------------------------------------------------- -------------------------------------- ---------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Introduction "Previous section in reading order")\]   \[[\>](#Questions-for-Chapter-1 "Next section in reading order")\]       \[[\<\<](#Introduction "Beginning of this chapter or previous chapter")\]   \[[Up](#Introduction "Up section")\]   \[[\>\>](#Using-a-compiler "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ------------------------------------------------------------- -------------------------------------------------------------------- --- --------------------------------------------------------------------------- -------------------------------------- ---------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#The-advantages-of-C}

1.1 The advantages of C {#the-advantages-of-c .section}
-----------------------

[]{#index-C-language_002c-advantages-of}
[]{#index-Advantages-of-the-C-language}
[]{#index-general_002dpurpose-programming}
[]{#index-programming_002c-general_002dpurpose}

C is one of a large number of high-level languages designed for
*general-purpose programming*, in other words, for writing anything from
small programs for personal amusement to complex industrial
applications.

C has many advantages:

-   []{#index-Black-boxes_002c-disadvantages-of}
    []{#index-Disadvantages-of-black-boxes}
-   Before C, machine-language programmers criticized high-level
    languages because, with their black box approach, they shielded the
    user from the working details of the computer and all its
    facilities. C, however, was designed to give access to any level of
    the computer down to raw machine language, and because of this, it
    is perhaps the most flexible high-level language.
    []{#index-C-language_002c-flexibility-of}
    []{#index-Style_002c-freedom-of-in-C-language}
    []{#index-Freedom-of-style-in-C-language}
-   C has features that allow the programmer to organize programs in a
    clear, easy, logical way. For example, C allows meaningful names for
    variables without any loss of efficiency, yet it gives a complete
    freedom of programming style, including flexible ways of making
    decisions, and a set of flexible commands for performing tasks
    repetitively (`for`, `while`, `do`).
    []{#index-C-language_002c-succinctness-of}
    []{#index-Suucinctness-of-C-language}
-   C is succinct. It permits the creation of tidy, compact programs.
    This feature can be a mixed blessing, however, and the C programmer
    must balance simplicity and readability.
    []{#index-C-language_002c-concealed-difficulties}
    []{#index-C-language_002c-power-of-1}
    []{#index-Concealed-difficulties-of-C-language}
    []{#index-Power-of-C-language-1}
-   C allows commands that are invalid in other languages. This is no
    defect, but a powerful freedom which, when used with caution, makes
    many things possible. It does mean that there are concealed
    difficulties in C, but if you write carefully and thoughtfully, you
    can create fast, efficient programs.
    []{#index-C-language-and-peripherals}
    []{#index-Peripherals-and-C-language}
-   With C, you can use every resource your computer offers. C tries to
    link closely with the local environment, providing facilities for
    gaining access to common peripherals like disk drives and printers.
    When new peripherals are invented, the GNU community quickly
    provides the ability to program them in C as well. In fact, most of
    the GNU project is written in C (as are many other operating
    systems).

For the reasons outlined above, C is the preeminent high-level language.
Clearly, no language can guarantee good programs, but C can provide a
framework in which it is easy to program well.

------------------------------------------------------------------------

[]{#Questions-for-Chapter-1}

  ---------------------------------------------------------------- ------------------------------------------------------------- --- --------------------------------------------------------------------------- -------------------------------------- ---------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Advantages-of-C "Previous section in reading order")\]   \[[\>](#Using-a-compiler "Next section in reading order")\]       \[[\<\<](#Introduction "Beginning of this chapter or previous chapter")\]   \[[Up](#Introduction "Up section")\]   \[[\>\>](#Using-a-compiler "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ---------------------------------------------------------------- ------------------------------------------------------------- --- --------------------------------------------------------------------------- -------------------------------------- ---------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Questions-for-Chapter-1-1}

1.2 Questions for Chapter 1 {#questions-for-chapter-1 .section}
---------------------------

1.  Explain the distinction between high levels and low levels.
2.  What is a "black box"?
3.  Name a few advantages to programming in the C language.

------------------------------------------------------------------------

[]{#Using-a-compiler}

  ------------------------------------------------------------------------ -------------------------------------------------------- --- --------------------------------------------------------------------------- ----------------------------- ----------------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Questions-for-Chapter-1 "Previous section in reading order")\]   \[[\>](#Basic-ideas "Next section in reading order")\]       \[[\<\<](#Introduction "Beginning of this chapter or previous chapter")\]   \[[Up](#Top "Up section")\]   \[[\>\>](#The-form-of-a-C-program "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ------------------------------------------------------------------------ -------------------------------------------------------- --- --------------------------------------------------------------------------- ----------------------------- ----------------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Using-a-compiler-1}

2. Using a compiler {#using-a-compiler .chapter}
===================

*How to use a compiler. What can go wrong.*

[]{#index-Operating-system} []{#index-Shell_002c-command}
[]{#index-Command-shell} []{#index-GNU-shell} []{#index-Shell_002c-GNU}
[]{#index-Compiler}

The *operating system* is the layer of software that drives the hardware
of a computer and provides the user with a comfortable work environment.
Operating systems vary, but most have a *shell*, or text interface. You
use the GNU shell every time you type in a command that launches an
email program or text editor under GNU.

In the following sections of this chapter, we will explore how to create
a C program from the GNU shell, and what might go wrong when you do.

  --------------------------------------------------------- ---- --
  [2.1 Basic ideas about C](#Basic-ideas)                        
  [2.2 The compiler](#The-compiler)                              
  [2.3 File names](#File-names)                                  
  [2.4 Errors](#Errors)                                          
  [2.5 Questions for Chapter 2](#Questions-for-Chapter-2)        
  --------------------------------------------------------- ---- --

------------------------------------------------------------------------

[]{#Basic-ideas}

  ----------------------------------------------------------------- --------------------------------------------------------- --- ------------------------------------------------------------------------------- ------------------------------------------ ----------------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Using-a-compiler "Previous section in reading order")\]   \[[\>](#The-compiler "Next section in reading order")\]       \[[\<\<](#Using-a-compiler "Beginning of this chapter or previous chapter")\]   \[[Up](#Using-a-compiler "Up section")\]   \[[\>\>](#The-form-of-a-C-program "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ----------------------------------------------------------------- --------------------------------------------------------- --- ------------------------------------------------------------------------------- ------------------------------------------ ----------------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Basic-ideas-about-C}

2.1 Basic ideas about C {#basic-ideas-about-c .section}
-----------------------

[]{#index-Shell_002c-command-1} []{#index-Command-shell-1}
[]{#index-GNU-shell-1} []{#index-Shell_002c-GNU-1}

First a note about a programming language that is different from the C
programming language, the GNU shell. When you enter commands in the GNU
shell, they are executed immediately. Moreover, the shell is a
programming language, in that the commands you type are a program,
because you can also create a text file containing many shell commands.
When you run this file, the commands will be executed in sequence.

On the other hand, consider C. While a shell command file can be
executed directly, a C program must be created in two stages:

1.  First, the program is written in the form of text files with a text
    editor such as GNU Emacs. This form of the program is called the
    *source code*. A computer cannot execute source code directly.
    []{#index-Compiler-1}
2.  Second, the completed source code is processed with a *compiler* ---
    a program that generates a new file containing a machine-language
    translation of the source code. This file is called an *executable
    file*, or *executable*. The executable file is said to have been
    *compiled* from the source code.

[]{#index-Executable-file_002c-running}
[]{#index-Running-an-executable-file}

To run the compiled program, you must usually type the name of the
executable file preceded by a period and a slash, as in this example:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | ./myprogram                       |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

[]{#index-_002e_002f-_0028dot_002dslash_0029-prefix-in-shell}
[]{#index-Dot_002dslash-_0028_002e_002f_0029-prefix-in-shell}

The "dot-slash" prefix tells the GNU shell to look in the current
directory for the executable. You usually do not need to type './' in
front of commands for programs that came with your GNU system, such as
`emacs`, because the computer already knows where to look for the
executables of those programs, which were placed in special directories
when your GNU system was installed.

[]{#index-Variable} []{#index-Function}

A C program is made up of, among other components, variables and
functions. A *variable* is a way to hold some data which may vary, hence
the name. For example, a variable might hold the number 17, and later
the number 41. Another variable might hold the word "Sue".

A *function* is a segment of text in the source code of a program that
tells the computer what to do. Programming consists, in large part, of
writing functions.

------------------------------------------------------------------------

[]{#The-compiler}

  ------------------------------------------------------------ ------------------------------------------------------- --- ------------------------------------------------------------------------------- ------------------------------------------ ----------------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Basic-ideas "Previous section in reading order")\]   \[[\>](#File-names "Next section in reading order")\]       \[[\<\<](#Using-a-compiler "Beginning of this chapter or previous chapter")\]   \[[Up](#Using-a-compiler "Up section")\]   \[[\>\>](#The-form-of-a-C-program "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ------------------------------------------------------------ ------------------------------------------------------- --- ------------------------------------------------------------------------------- ------------------------------------------ ----------------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#The-compiler-1}

2.2 The compiler {#the-compiler .section}
----------------

[]{#index-Compiler-2} []{#index-Compiler-passes}
[]{#index-Passes_002c-compiler}

When you compile a program, the compiler usually operates in an orderly
sequence of phases called *passes*. The sequence happens approximately
like this:

1.  []{#index-Source-code} []{#index-Code_002c-source}
    []{#index-Pseudo_002dcode}
2.  First, the compiler reads the source code, perhaps generating an
    intermediate code (such as *pseudo-code*) that simplifies the source
    code for subsequent processing. []{#index-Object-code-file}
    []{#index-Object-file} []{#index-File_002c-object-code}
    []{#index-File_002c-object} []{#index-Object-code}
    []{#index-Code_002c-object}
3.  Next, the compiler converts the intermediate code (if there is any)
    or the original source code into an *object code* file, which
    contains machine language but is not yet executable. The compiler
    builds a separate object file for each source file. These are only
    temporary and are deleted by the compiler after compilation.
    []{#index-Linker}
4.  Finally, the compiler runs a *linker*. The linker merges the
    newly-created object code with some standard, built-in object code
    to produce an executable file that can stand alone.

[]{#index-GCC} []{#index-gcc} []{#index-GNU-C-Compiler}
[]{#index-GNU-Compiler-Collection} []{#index-Compiler-3}

GNU environments use a simple command to invoke the C compiler: `gcc`,
which stands for "GNU Compiler Collection". (It used to stand for "GNU C
Compiler", but now GCC can compile many more languages than just C.)
Thus, to compile a small program, you will usually type something like
the following command:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | gcc file_name                     |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

[]{#index-a_002eout}

On GNU systems, this results in the creation of an executable program
with the default name '`a.out`'. To tell the compiler you would like the
executable program to be called something else, use the '-o' option for
setting the name of the object code:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | gcc -o program_name file_name     |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

For example, to create a program called '`myprog`' from a file called
'`myprog.c`', write

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | gcc -o myprog myprog.c            |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

To launch the resulting program '`myprog`' from the same directory, type

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | ./myprog                          |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

------------------------------------------------------------------------

[]{#File-names}

  ------------------------------------------------------------- --------------------------------------------------- --- ------------------------------------------------------------------------------- ------------------------------------------ ----------------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#The-compiler "Previous section in reading order")\]   \[[\>](#Errors "Next section in reading order")\]       \[[\<\<](#Using-a-compiler "Beginning of this chapter or previous chapter")\]   \[[Up](#Using-a-compiler "Up section")\]   \[[\>\>](#The-form-of-a-C-program "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ------------------------------------------------------------- --------------------------------------------------- --- ------------------------------------------------------------------------------- ------------------------------------------ ----------------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#File-names-1}

2.3 File names {#file-names .section}
--------------

[]{#index-File-name-conventions} []{#index-Conventions_002c-file-name}

GCC uses the following file name conventions:

  ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- ---------------------------------
  []{#index-_002ec-file-suffix} []{#index-_002eo-file-suffix} []{#index-_002eh-file-suffix} []{#index-_002ea-file-suffix} []{#index-_002eso-file-suffix} []{#index-File_002c-source-code} []{#index-Source-code-file} []{#index-File_002c-object-1} []{#index-Object-file-1} []{#index-File_002c-executable} []{#index-Executable-file} []{#index-File_002c-header} []{#index-Header-file} []{#index-File_002c-library} []{#index-Library-file}   
  Source code file                                                                                                                                                                                                                                                                                                                                                                                                                                program\_name`.c`
  Object file                                                                                                                                                                                                                                                                                                                                                                                                                                     program\_name`.o`
  Executable file                                                                                                                                                                                                                                                                                                                                                                                                                                 program\_name (no ending)
  Header file                                                                                                                                                                                                                                                                                                                                                                                                                                     name`.h`
  Library file                                                                                                                                                                                                                                                                                                                                                                                                                                    `lib`name`.a` or `lib`name`.so`
  ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- ---------------------------------

The file name endings, or *file extensions*, identify the contents of
files to the compiler. For example, the '.c' suffix tells the compiler
that the file contains C source code, and the other letters indicate
other kinds of files in a similar way.

------------------------------------------------------------------------

[]{#Errors}

  ----------------------------------------------------------- ----------------------------------------------------------------- --- ------------------------------------------------------------------------------- ------------------------------------------ ----------------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#File-names "Previous section in reading order")\]   \[[\>](#Typographical-errors "Next section in reading order")\]       \[[\<\<](#Using-a-compiler "Beginning of this chapter or previous chapter")\]   \[[Up](#Using-a-compiler "Up section")\]   \[[\>\>](#The-form-of-a-C-program "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ----------------------------------------------------------- ----------------------------------------------------------------- --- ------------------------------------------------------------------------------- ------------------------------------------ ----------------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Errors-1}

2.4 Errors {#errors .section}
----------

[]{#index-Errors} []{#index-Bugs}

Errors are mistakes that programmers make in their code. There are two
main kinds of errors.

-   []{#index-Compile_002dtime-errors}
    []{#index-Errors_002c-compile_002dtime}
    []{#index-Compile_002dtime-bugs}
    []{#index-Bugs_002c-compile_002dtime} []{#index-Syntax-errors}
    []{#index-Errors_002c-syntax} []{#index-Type-errors}
    []{#index-Errors_002c-type}
-   *Compile-time errors* are errors caught by the compiler. They can be
    *syntax errors*, such as typing fro instead of for, or they can be
    errors caused by the incorrect construction of your program. For
    example, you might tell the compiler that a certain variable is an
    integer, then attempt to give it a non-integer value such as 5.23.
    (See section [Type errors](#Type-errors).)

    The compiler lists all compile-time errors at once, with the line
    number at which each error occurred in the source code, and a
    message that explains what went wrong.

    For example, suppose that, in your file '`eg.c`' you write

    +-----------------------------------+-----------------------------------+
    |                                   | ``` {.smallexample}               |
    |                                   | y = sin (x];                      |
    |                                   | ```                               |
    +-----------------------------------+-----------------------------------+

    instead of

    +-----------------------------------+-----------------------------------+
    |                                   | ``` {.smallexample}               |
    |                                   | y = sin (x);                      |
    |                                   | ```                               |
    +-----------------------------------+-----------------------------------+

    []{#index-Assignment} []{#index-Assignment_002c-example-of}
    []{#index-_003d-_0028equals-sign_0029}
    []{#index-Equals-sign-_0028_003d_0029}

    (By the way, this is an example of *assignment*. With the equals
    sign ('='), you are *assigning* the variable `y` (causing the
    variable `y` to contain) the sine of the variable `x`. This is
    somewhat different from the way equals signs work in mathematics. In
    math, an equals sign indicates that the numbers and variables on
    either side of it are *already* equal; in C, an equals sign *makes*
    things equal. Sometimes it is useful to think of the equals sign as
    an abbreviation for the phrase "becomes the value of".)

    Ignore the syntactic details of the statements above for now, except
    to note that closing the `(x)` with a square bracket instead of a
    parenthesis is an error in C. Upon compilation, you will see
    something like this error message:

    error\--\>

    +-----------------------------------+-----------------------------------+
    |                                   | ``` {.smallexample}               |
    |                                   | eg.c: In function `main':         |
    |                                   | eg.c:8: parse error before `]'    |
    |                                   | ```                               |
    +-----------------------------------+-----------------------------------+

    (If you compile the program within Emacs, you can jump directly to
    the error. We will discuss this feature later. See section
    [Debugging](#Debugging), for more information.)

    []{#index-Compile_002dtime-errors-1}
    []{#index-Errors_002c-compile_002dtime-1} []{#index-Error-cascade}

    A program with compile-time errors will cause the compiler to halt,
    and will not produce an executable. However, the compiler will check
    the syntax up to the last line of your source code before stopping,
    and it is common for a single real error, even something as simple
    as a missing parenthesis, to result in a huge and confusing list of
    nonexistent "errors" from the compiler. This can be shocking and
    disheartening to novices, but you'll get used to it with experience.
    (We will provide an example later in the book. See section
    [Debugging](#Debugging).)

    As a rule, the best way to approach this kind of problem is to look
    for the *first* error, fix that, and then recompile. You will soon
    come to recognize when subsequent error messages are due to
    independent problems and when they are due to a cascade.

    []{#index-Run_002dtime-errors} []{#index-Errors_002c-run_002dtime}

-   *Run-time errors* are errors that occur in a compiled and running
    program, sometimes long after it has been compiled.

    One kind of run-time error happens when you write a running program
    that does not do what you intend. For example, you intend to send a
    letter to all drivers whose licenses will expire in June, but
    instead, you send a letter to all drivers whose licenses will *ever*
    expire.

    []{#index-Crash_002c-computer} []{#index-Computer-crash}
    []{#index-Stability-of-GNU-system}
    []{#index-GNU-system_002c-stability-of}

    Another kind of run-time error can cause your program to *crash*, or
    quit abruptly. For example, you may tell the computer to examine a
    part of its memory that doesn't exist, or to divide some variable by
    zero. Fortunately, the GNU environment is extremely stable, and very
    little will occur other than an error message in your terminal
    window when you crash a program you are writing under GNU.

[]{#index-Executable-file-1} []{#index-File_002c-executable-1}

If the compilation of a program is successful, then a new executable
file is created.

When a programmer wishes to make alterations and corrections to a C
program, these must be made in the source code, using a text editor;
after making the changes, the programmer must recompile the program, or
its salient parts.

  ----------------------------------------------------- ---- --
  [2.4.1 Typographical errors](#Typographical-errors)        
  [2.4.2 Type errors](#Type-errors)                          
  ----------------------------------------------------- ---- --

------------------------------------------------------------------------

[]{#Typographical-errors}

  ------------------------------------------------------- -------------------------------------------------------- --- ------------------------------------------------------------------------------- -------------------------------- ----------------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Errors "Previous section in reading order")\]   \[[\>](#Type-errors "Next section in reading order")\]       \[[\<\<](#Using-a-compiler "Beginning of this chapter or previous chapter")\]   \[[Up](#Errors "Up section")\]   \[[\>\>](#The-form-of-a-C-program "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ------------------------------------------------------- -------------------------------------------------------- --- ------------------------------------------------------------------------------- -------------------------------- ----------------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Typographical-errors-1}

### 2.4.1 Typographical errors {#typographical-errors .subsection}

[]{#index-Typographical-errors} []{#index-Errors_002c-typographical}
[]{#index-Case_002dsensitivity-of-C-language}
[]{#index-C-language_002c-case_002dsensitivity-of}

The compiler can sometimes fail for very simple reasons, such as
typographical errors, including the misuse of upper- and lower-case
characters. The C language is *case-sensitive*. Unlike languages such as
Pascal and some versions of BASIC, C distinguishes between upper- and
lower-case letters, such as 'A' and 'a'. If a letter is typed in the
wrong case in a critical place in the source code, compilation will
fail. This is a potential source of errors that are difficult to find.

------------------------------------------------------------------------

[]{#Type-errors}

  --------------------------------------------------------------------- -------------------------------------------------------------------- --- ------------------------------------------------------------------------------- -------------------------------- ----------------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Typographical-errors "Previous section in reading order")\]   \[[\>](#Questions-for-Chapter-2 "Next section in reading order")\]       \[[\<\<](#Using-a-compiler "Beginning of this chapter or previous chapter")\]   \[[Up](#Errors "Up section")\]   \[[\>\>](#The-form-of-a-C-program "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  --------------------------------------------------------------------- -------------------------------------------------------------------- --- ------------------------------------------------------------------------------- -------------------------------- ----------------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Type-errors-1}

### 2.4.2 Type errors {#type-errors .subsection}

[]{#index-Variable-types} []{#index-Types_002c-variable}
[]{#index-Type-errors-1} []{#index-Errors_002c-type-1}
[]{#index-Defining-your-own-types}
[]{#index-Types_002c-defining-your-own}

C supports a variety of *variable types* (different kinds of variables
for different kinds of data), such as `integer` for integer numbers, and
`float` for numbers with fractional parts. You can even define your own
types, such as `total` for a sum, or `surname` for someone's last name.
You can also convert a variable of one type into other types. (This is
called *type coercion*.) Consequently, the type of a variable is of
great importance to the compiler.

[]{#index-Variable-declaration} []{#index-Declaration_002c-variable}

C requires us to list the names and types of all variables that will be
used in a program, and provide information about where they are going to
be used. This is called *declaring* variables. If you fail to declare a
variable, or use it as if it were a different type from the type it is
declared to be, for example, by assigning a non-integer value to an
integer variable, you will receive a compile-time error.

See section [Variables and declarations](#Variables-and-declarations),
for more information on variable declarations. See section [The form of
a C program](#The-form-of-a-C-program), for some simple examples of
variable declarations.

------------------------------------------------------------------------

[]{#Questions-for-Chapter-2}

  ------------------------------------------------------------ -------------------------------------------------------------------- --- ------------------------------------------------------------------------------- ------------------------------------------ ----------------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Type-errors "Previous section in reading order")\]   \[[\>](#The-form-of-a-C-program "Next section in reading order")\]       \[[\<\<](#Using-a-compiler "Beginning of this chapter or previous chapter")\]   \[[Up](#Using-a-compiler "Up section")\]   \[[\>\>](#The-form-of-a-C-program "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ------------------------------------------------------------ -------------------------------------------------------------------- --- ------------------------------------------------------------------------------- ------------------------------------------ ----------------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Questions-for-Chapter-2-1}

2.5 Questions for Chapter 2 {#questions-for-chapter-2 .section}
---------------------------

1.  What is a compiler?
2.  How does one run a C program?
3.  How does one usually compile a C program?
4.  Are upper and lower case equivalent in C?
5.  What the two main kinds of error that can occur in a program?
6.  If you had some C source code that you wished to call "accounts",
    under what name would you save it?
7.  What would be the name of the executable file for the program in the
    last question?
8.  How would you run this program?

------------------------------------------------------------------------

[]{#The-form-of-a-C-program}

  ------------------------------------------------------------------------ --------------------------------------------------------------- --- ------------------------------------------------------------------------------- ----------------------------- --------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Questions-for-Chapter-2 "Previous section in reading order")\]   \[[\>](#A-word-about-style "Next section in reading order")\]       \[[\<\<](#Using-a-compiler "Beginning of this chapter or previous chapter")\]   \[[Up](#Top "Up section")\]   \[[\>\>](#Functions "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ------------------------------------------------------------------------ --------------------------------------------------------------- --- ------------------------------------------------------------------------------- ----------------------------- --------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#The-form-of-a-C-program-1}

3. The form of a C program {#the-form-of-a-c-program .chapter}
==========================

*What goes into a C program? What does one look like?*

[]{#index-Function_002c-as-building-block}
[]{#index-Building-block_002c-function-as}

The basic building block of a C program is the *function*. Every C
program is a collection of one or more functions. Functions are made of
variable declarations and *statements*, or complex commands, and are
surrounded by curly brackets ('{' and '}').

[]{#index-main-function} []{#index-Function_002c-main}
[]{#index-C-program_002c-simplest} []{#index-Simplest-C-program}

One and only one of the functions in a program must have the name
`main`. This function is always the starting point of a C program, so
the simplest C program is a single function definition:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | main ()                           |
|                                   | {                                 |
|                                   | }                                 |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

The parentheses '()' that follow the name of the function must be
included. This is how C distinguishes functions from ordinary variables.

The function `main` does not need to be at the top of a program, so a C
program does not necessarily start at line 1, but wherever the function
called `main` is located. The function `main` cannot be *called*, or
started, by any other function in the program. Only the operating system
can call `main`; this is how a C program is started.

The next most simple C program is perhaps a program that starts, calls a
function that does nothing, and then ends.

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | /******************************** |
|                                   | **********************/           |
|                                   | /*                                |
|                                   |                      */           |
|                                   | /* Program : do nothing           |
|                                   |                      */           |
|                                   | /*                                |
|                                   |                      */           |
|                                   | /******************************** |
|                                   | **********************/           |
|                                   |                                   |
|                                   | main()                          / |
|                                   | * Main program */                 |
|                                   | {                                 |
|                                   |   do_nothing();                   |
|                                   | }                                 |
|                                   |                                   |
|                                   | /******************************** |
|                                   | **********************/           |
|                                   |                                   |
|                                   | do_nothing()                 /* F |
|                                   | unction called */                 |
|                                   | {                                 |
|                                   | }                                 |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

[]{#index-Comments} []{#index-Comment-characters}

(Any text sandwiched between '/\*' and '\*/' in C code is a comment for
other humans to read. See the section on comments below for more
information.)

There are several things to notice about this program.

First, this program consists of two functions, one of which calls the
other.

Second, the function `do_nothing` is called by simply typing the main
part of its name followed by '()' parentheses and a semicolon.

Third, the semicolon is vital; every simple statement in C ends with
one. This is a signal to the compiler that the end of a statement has
been reached and that anything that follows is part of another
statement. This signal helps the compiler diagnose errors.

Fourth, the curly bracket characters '{' and '}' outline a *block* of
statements. When this program meets the closing '}' of the second
function's block, it transfers control back to 'main', where it meets
another '}', and the program ends.

  --------------------------------------------------------- ---- --
  [3.1 A word about style](#A-word-about-style)                  
  [3.2 Comments](#Comments)                                      
  [3.3 Example 1](#Example-comment)                              
  [3.4 Questions for Chapter 3](#Questions-for-Chapter-3)        
  --------------------------------------------------------- ---- --

------------------------------------------------------------------------

[]{#A-word-about-style}

  ------------------------------------------------------------------------ ----------------------------------------------------- --- -------------------------------------------------------------------------------------- ------------------------------------------------- --------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#The-form-of-a-C-program "Previous section in reading order")\]   \[[\>](#Comments "Next section in reading order")\]       \[[\<\<](#The-form-of-a-C-program "Beginning of this chapter or previous chapter")\]   \[[Up](#The-form-of-a-C-program "Up section")\]   \[[\>\>](#Functions "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ------------------------------------------------------------------------ ----------------------------------------------------- --- -------------------------------------------------------------------------------------- ------------------------------------------------- --------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#A-word-about-style-1}

3.1 A word about style {#a-word-about-style .section}
----------------------

[]{#index-Style} []{#index-C_002c-ANSI-Standard}
[]{#index-ANSI-Standard-C}

The code examples above are simple, but they illustrate the *control
flow* of a C program, or the order in which its statements are executed.
You should note that these programs are written in "old-fashioned" C, as
the language existed before ANSI Standard C --- the version in which
most C programs are now written. The above programs are also missing
several key elements that most C programs have, such as header files and
function prototypes. Finally, they do not show good style; if you wish
to submit programs you write to the Free Software Foundation, you should
consult its advice on how best to use the C language.

You may wonder why we chose old-style C for these first few examples,
even though people proverbially learn best what they learn first. We did
so because pre-ANSI C is considerably simpler than the present form, and
also because as you develop as a C programmer, you will probably run
across some old C code that you will want to read.

You may also wonder why a savvy programmer would want to follow the ANSI
Standard, which was drafted by committee, or even the GNU guidelines.
Isn't programming free software all about freedom? Yes, but following
the ANSI Standard ensures that your code can be easily compiled on many
other computer platforms, and the GNU guidelines ensure that your code
can be read by other programmers. (We will introduce good C style in our
examples soon. Meanwhile, you can examine the GNU guidelines later in
the book. See section [Style](#Style).)

  --------------------------------------------------------- ---- --
  [3.2 Comments](#Comments)                                      
  [3.3 Example 1](#Example-comment)                              
  [3.4 Questions for Chapter 3](#Questions-for-Chapter-3)        
  --------------------------------------------------------- ---- --

------------------------------------------------------------------------

[]{#Comments}

  ------------------------------------------------------------------- ------------------------------------------------------------ --- -------------------------------------------------------------------------------------- ------------------------------------------------- --------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#A-word-about-style "Previous section in reading order")\]   \[[\>](#Example-comment "Next section in reading order")\]       \[[\<\<](#The-form-of-a-C-program "Beginning of this chapter or previous chapter")\]   \[[Up](#The-form-of-a-C-program "Up section")\]   \[[\>\>](#Functions "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ------------------------------------------------------------------- ------------------------------------------------------------ --- -------------------------------------------------------------------------------------- ------------------------------------------------- --------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Comments-1}

3.2 Comments {#comments .section}
------------

\

*Annotating programs.*\

[]{#index-Comments-1} []{#index-Annotating-programs}
[]{#index-Programs_002c-annotating}

Comments are a way of inserting remarks and reminders into code without
affecting its behavior. Since comments are only read by other humans,
you can put anything you wish to in a comment, but it is better to be
informative than humorous.

The compiler ignores comments, treating them as though they were
*whitespace* (blank characters, such as spaces, tabs, or carriage
returns), and they are consequently ignored. During compilation,
comments are simply stripped out of the code, so programs can contain
any number of comments without losing speed.

Because a comment is treated as whitespace, it can be placed anywhere
whitespace is valid, even in the middle of a statement. (Such a practice
can make your code difficult to read, however.)

[]{#index-Comment-characters-1}

Any text sandwiched between '/\*' and '\*/' in C code is a comment. Here
is an example of a C comment:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | /* ...... comment ......*/        |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

Comments do not necessarily terminate at the end of a line, only with
the characters '\*/'. If you forget to close a comment with the
characters '\*/', the compiler will display an 'unterminated comment'
error when you try to compile your code.

[]{#index-Comments_002c-example}

------------------------------------------------------------------------

[]{#Example-comment}

  --------------------------------------------------------- -------------------------------------------------------------------- --- -------------------------------------------------------------------------------------- ------------------------------------------------- --------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Comments "Previous section in reading order")\]   \[[\>](#Questions-for-Chapter-3 "Next section in reading order")\]       \[[\<\<](#The-form-of-a-C-program "Beginning of this chapter or previous chapter")\]   \[[Up](#The-form-of-a-C-program "Up section")\]   \[[\>\>](#Functions "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  --------------------------------------------------------- -------------------------------------------------------------------- --- -------------------------------------------------------------------------------------- ------------------------------------------------- --------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Example-1}

3.3 Example 1 {#example-1 .section}
-------------

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | #include <stdio.h>      /* header |
|                                   |  file */                          |
|                                   |                                   |
|                                   | main ()   /* Trivial program */   |
|                                   |                                   |
|                                   | {                                 |
|                                   |                                   |
|                                   | /* This little line has no effect |
|                                   |  */                               |
|                                   | /* This little line has none */   |
|                                   | /* This little line went all the  |
|                                   | way down                          |
|                                   |    to the next line,              |
|                                   |    And so on...                   |
|                                   |    And so on...                   |
|                                   |    And so on... */                |
|                                   |                                   |
|                                   |   do_little();                    |
|                                   |                                   |
|                                   |   printf ("Function 'main' comple |
|                                   | ting.\n");                        |
|                                   | }                                 |
|                                   |                                   |
|                                   | /******************************** |
|                                   | **************/                   |
|                                   |                                   |
|                                   | /* A bar like the one above can b |
|                                   | e used to */                      |
|                                   | /* separate functions visibly in  |
|                                   | a program */                      |
|                                   |                                   |
|                                   |                                   |
|                                   | do_little ()                      |
|                                   | {                                 |
|                                   |                                   |
|                                   | /* This function does little. */  |
|                                   |                                   |
|                                   |   printf ("Function 'do_little' c |
|                                   | ompleting.\n");                   |
|                                   | }                                 |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

[]{#index-C_002c-ANSI-Standard-1} []{#index-ANSI-Standard-C-1}
[]{#index-GNU-style-guidelines} []{#index-Style-1}

Again, this example is old-fashioned C, and in mediocre style. To make
it more compliant with the ANSI Standard and GNU guidelines, we would
declare the variable type each function returns (`int` for `main`, which
also requires an `exit` or `return` statement), and we would create
function prototypes at the beginning of the file. (See section
[Functions](#Functions).)

  --------------------------------------------------------- ---- --
  [3.4 Questions for Chapter 3](#Questions-for-Chapter-3)        
  --------------------------------------------------------- ---- --

------------------------------------------------------------------------

[]{#Questions-for-Chapter-3}

  ---------------------------------------------------------------- ------------------------------------------------------ --- -------------------------------------------------------------------------------------- ------------------------------------------------- --------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Example-comment "Previous section in reading order")\]   \[[\>](#Functions "Next section in reading order")\]       \[[\<\<](#The-form-of-a-C-program "Beginning of this chapter or previous chapter")\]   \[[Up](#The-form-of-a-C-program "Up section")\]   \[[\>\>](#Functions "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ---------------------------------------------------------------- ------------------------------------------------------ --- -------------------------------------------------------------------------------------- ------------------------------------------------- --------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Questions-for-Chapter-3-1}

3.4 Questions for Chapter 3 {#questions-for-chapter-3 .section}
---------------------------

1.  What is a block?
2.  Does a C program start at the beginning? Where is the beginning?
3.  What happens when a program comes to a '}' character? What does this
    character signify?
4.  What vital piece of punctuation goes at the end of every simple C
    statement?
5.  What happens if a comment is not ended? That is if the programmer
    types '/\*' .. to start but forgets the ..'\*/' to close?

------------------------------------------------------------------------

[]{#Functions}

  ------------------------------------------------------------------------ ----------------------------------------------------------- --- -------------------------------------------------------------------------------------- ----------------------------- -------------------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Questions-for-Chapter-3 "Previous section in reading order")\]   \[[\>](#Function-names "Next section in reading order")\]       \[[\<\<](#The-form-of-a-C-program "Beginning of this chapter or previous chapter")\]   \[[Up](#Top "Up section")\]   \[[\>\>](#Variables-and-declarations "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ------------------------------------------------------------------------ ----------------------------------------------------------- --- -------------------------------------------------------------------------------------- ----------------------------- -------------------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Functions-1}

4. Functions {#functions .chapter}
============

*Solving problems and getting results.*

[]{#index-Functions}

A function is a section of program code that performs a particular task.
Making functions is a way of isolating one section of code from other
independent sections. Functions allow a programmer to separate code by
its purpose, and make a section of code *reusable* --- that is, make it
so the section can be called in many different contexts.

Functions should be written in the following form:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | type function_name (type paramete |
|                                   | r1_name, type parameter2_name, …) |
|                                   |                                   |
|                                   | {                                 |
|                                   |   variable declarations           |
|                                   |                                   |
|                                   |   statements                      |
|                                   |   ...                             |
|                                   |   ...                             |
|                                   |   ...                             |
|                                   | }                                 |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

[]{#index-C_002c-ANSI-Standard-2} []{#index-ANSI-Standard-C-2}

You may notice when reading the examples in this chapter that this
format is somewhat different from the one we have used so far. This
format conforms to the ANSI Standard and is better C. The other way is
old-fashioned C, although GCC will still compile it. Nevertheless, GCC
is not guaranteed to do so in the future, and we will use ANSI Standard
C in this text from now on.

[]{#index-Parameters} []{#index-Declarations_002c-variable}
[]{#index-Variable-declarations} []{#index-Statements}

As shown above, a function can have a number of *parameters*, or pieces
of information from outside, and the function's *body* consists of a
number of declarations and statements, enclosed by curly brackets:
'{...}'.

  --------------------------------------------------------- ---- --
  [4.1 Function names](#Function-names)                          
  [4.2 Function examples](#Function-examples)                    
  [4.3 Functions with values](#Functions-with-values)            
  [4.4 Function prototyping](#Function-prototyping)              
  [4.5 The `exit` function](#The-exit-function)                  
  [4.6 Questions for Chapter 4](#Questions-for-Chapter-4)        
  --------------------------------------------------------- ---- --

------------------------------------------------------------------------

[]{#Function-names}

  ---------------------------------------------------------- -------------------------------------------------------------- --- ------------------------------------------------------------------------ ----------------------------------- -------------------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Functions "Previous section in reading order")\]   \[[\>](#Function-examples "Next section in reading order")\]       \[[\<\<](#Functions "Beginning of this chapter or previous chapter")\]   \[[Up](#Functions "Up section")\]   \[[\>\>](#Variables-and-declarations "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ---------------------------------------------------------- -------------------------------------------------------------- --- ------------------------------------------------------------------------ ----------------------------------- -------------------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Function-names-1}

4.1 Function names {#function-names .section}
------------------

[]{#index-Functions_002c-names-of} []{#index-Function-names}

Every function has a name by which it is known to the rest of the
program. The name of a function in C can be anything from a single
letter to a long word. The ANSI Standard, however, only guarantees that
C will be able to distinguish the first 31 letters of *identifiers*, or
function and variable names. (Identifiers are therefore said to have 31
*significant characters*.) In some cases, identifiers may have as few as
six significant characters, to stay compatible with older linkers, but
this part of the ANSI Standard is becoming obsolete.

[]{#index-Function-names_002c-characters-available-for}

A function name must begin with an alphabetic letter or the underscore
'\_' character, but the other characters in the name can be chosen from
the following groups:

-   Any lower-case letter from 'a' to 'z'
-   Any upper-case letter from 'A' to 'Z'
-   Any digit from '0' to '9'
-   The underscore character '\_'

Note that with GCC, you can also use dollar signs ('\$') in identifiers.
This is one of GCC's extensions to the C language, and is not part of
the ANSI standard. It also may not be supported under GCC on certain
hardware platforms.

------------------------------------------------------------------------

[]{#Function-examples}

  --------------------------------------------------------------- ------------------------------------------------------------------ --- ------------------------------------------------------------------------ ----------------------------------- -------------------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Function-names "Previous section in reading order")\]   \[[\>](#Functions-with-values "Next section in reading order")\]       \[[\<\<](#Functions "Beginning of this chapter or previous chapter")\]   \[[Up](#Functions "Up section")\]   \[[\>\>](#Variables-and-declarations "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  --------------------------------------------------------------- ------------------------------------------------------------------ --- ------------------------------------------------------------------------ ----------------------------------- -------------------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Function-examples-1}

4.2 Function examples {#function-examples .section}
---------------------

[]{#index-Function_002c-example} []{#index-Example-function}
[]{#index-printf}

Here is an example of a function that adds two integers and prints the
sum with C's "print formatted" function named `printf`, using the
characters '%d' to specify integer output.

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | void add_two_numbers (int a, int  |
|                                   | b)               /* Add a and b * |
|                                   | /                                 |
|                                   | {                                 |
|                                   |   int c;                          |
|                                   |                                   |
|                                   |   c = a + b;                      |
|                                   |   printf ("%d\n", c);             |
|                                   | }                                 |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

The variables `a` and `b` are parameters passed in from outside the
function. The code defines `a`, `b`, and `c` to be of type `int`, or
integer.

The function above is not much use standing alone. Here is a `main`
function that calls the `add_two_numbers` function:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | int main()                        |
|                                   | {                                 |
|                                   |   int var1, var2;                 |
|                                   |                                   |
|                                   |   var1 = 1;                       |
|                                   |   var2 = 53;                      |
|                                   |                                   |
|                                   |   add_two_numbers (var1, var2);   |
|                                   |   add_two_numbers (1, 2);         |
|                                   |                                   |
|                                   |   exit(0);                        |
|                                   | }                                 |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

When these functions are incorporated into a C program, together they
print the number 54, then they print the number 3, and then they stop.

------------------------------------------------------------------------

[]{#Functions-with-values}

  ------------------------------------------------------------------ ----------------------------------------------------------------- --- ------------------------------------------------------------------------ ----------------------------------- -------------------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Function-examples "Previous section in reading order")\]   \[[\>](#Function-prototyping "Next section in reading order")\]       \[[\<\<](#Functions "Beginning of this chapter or previous chapter")\]   \[[Up](#Functions "Up section")\]   \[[\>\>](#Variables-and-declarations "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ------------------------------------------------------------------ ----------------------------------------------------------------- --- ------------------------------------------------------------------------ ----------------------------------- -------------------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Functions-with-values-1}

4.3 Functions with values {#functions-with-values .section}
-------------------------

[]{#index-Functions_002c-with-values} []{#index-Function-values}
[]{#index-Returning-values-from-functions}
[]{#index-Functions_002c-return-values}
[]{#index-Functions_002c-returning-values-from}

In mathematics, a function takes one or more values and calculates, or
*returns*, another value. In C, some functions return values and others
do not; whether a function you write does or does not will depend on
what you want the function to do. For example, a function that
calculates a value should probably return that value, while a function
that merely prints something out may not need to.

The `add_two_numbers` function above did not return a value. We will now
examine a function that does.

Here is an example of calling a function that returns a value:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | bill = calculate_bill (data1, dat |
|                                   | a2, data3);                       |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

When this statement is executed, control is passed to the function
`calculate_bill`, that function executes, and then it returns control
and some value to the original statement. The value returned is assigned
to `bill`, and the program continues.

In C, returning a value from a function is a simple matter. Consider the
function `calculate_bill` as it might be written in a program that
contains the statement above:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | int calculate_bill (int a, int b, |
|                                   |  int c)                           |
|                                   | {                                 |
|                                   |   int total;                      |
|                                   |                                   |
|                                   |   total = a + b + c;              |
|                                   |   return total;                   |
|                                   | }                                 |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

As soon as the `return` statement is met, `calculate_bill` stops
executing and returns the value `total`.

A function that returns a value must have a `return` statement.
Forgetting it can ruin a program. For instance if `calculate_bill` had
read as follows, then the variable `bill` would have had no meaningful
value assigned to it, and you might have received a warning from the
compiler as well. (The word `void` below indicates that the function
does not return a value. In ANSI C, you must place it before the name of
any such function.)

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | void calculate_bill (int a, int b |
|                                   | , int c)                          |
|                                   | {                                 |
|                                   |   int total;                      |
|                                   |                                   |
|                                   |   total = a + b + c;              |
|                                   | }                                 |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

On the other hand, you do not need to actually use a value when a
function returns one. For example, the C input/output functions `printf`
and `scanf` return values, but the values are rarely used. See [output:
(and devices)Input](and%20devices.html#Input), for more information on
these functions.

If we use the first version of the `calculate_bill` function (the one
that contains the line `return total;`), the value of the function can
simply be discarded. (Of course, the resulting program is not very
useful, since it never displays a value to the user!)

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | int main()                        |
|                                   | {                                 |
|                                   |   calculate_bill (1, 2, 3);       |
|                                   |   exit (0);                       |
|                                   | }                                 |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

------------------------------------------------------------------------

[]{#Function-prototyping}

  ---------------------------------------------------------------------- -------------------------------------------------------------- --- ------------------------------------------------------------------------ ----------------------------------- -------------------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Functions-with-values "Previous section in reading order")\]   \[[\>](#The-exit-function "Next section in reading order")\]       \[[\<\<](#Functions "Beginning of this chapter or previous chapter")\]   \[[Up](#Functions "Up section")\]   \[[\>\>](#Variables-and-declarations "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ---------------------------------------------------------------------- -------------------------------------------------------------- --- ------------------------------------------------------------------------ ----------------------------------- -------------------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Function-prototyping-1}

4.4 Function prototyping {#function-prototyping .section}
------------------------

[]{#index-Functions_002c-prototyping} []{#index-Prototyping-function}
[]{#index-Function-prototypes}

Functions do not have to return integer values, as in the above
examples, but can return almost any type of value, including floating
point and character values. (See section [Variables and
declarations](#Variables-and-declarations), for more information on
variable types.)

[]{#index-Function-declarations} []{#index-Functions_002c-declaring}
[]{#index-Declaring-functions}

A function must be declared to return a certain variable type (such as
an integer), just as variables must be. (See section [Variables and
declarations](#Variables-and-declarations), for more information about
variable types.) To write code in good C style, you should declare what
type of value a function returns (and what type of parameters it
accepts) in two places:

1.  At the beginning of the program, in global scope. (See section
    [Scope](#Scope).)
2.  In the definition of the function itself.

Function declarations at the beginning of a program are called
*prototypes*. Here is an example of a program in which prototypes are
used:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | #include <stdio.h>                |
|                                   |                                   |
|                                   | void print_stuff (int foo, int ba |
|                                   | r);                               |
|                                   | int calc_value (int bas, int quux |
|                                   | );                                |
|                                   |                                   |
|                                   |                                   |
|                                   | void print_stuff (int foo, int ba |
|                                   | r)                                |
|                                   | {                                 |
|                                   |   int var_to_print;               |
|                                   |                                   |
|                                   |   var_to_print = calc_value (foo, |
|                                   |  bar);                            |
|                                   |   printf ("var_to_print = %d\n",  |
|                                   | var_to_print);                    |
|                                   | }                                 |
|                                   |                                   |
|                                   |                                   |
|                                   | int calc_value (int bas, int quux |
|                                   | )                                 |
|                                   | {                                 |
|                                   |   return bas * quux;              |
|                                   | }                                 |
|                                   |                                   |
|                                   |                                   |
|                                   | int main()                        |
|                                   | {                                 |
|                                   |   print_stuff (23, 5);            |
|                                   |   exit (0);                       |
|                                   | }                                 |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

The above program will print the text 'var\_to\_print = 115' and then
quit.

[]{#index-Function-prototypes_002c-reasons-for-using}

Prototypes may seem to be a nuisance, but they overcome a problem
intrinsic to compilers, which is that they compile functions as they
come upon them. Without function prototypes, you usually cannot write
code that calls a function before the function itself is defined in the
program. If you place prototypes for your functions in a header file,
however, you can call the functions from any source code file that
includes the header. This is one reason C is considered to be such a
flexible programming language.

Some compilers avoid the use of prototypes by making a first pass just
to see what functions are there, and a second pass to do the work, but
this takes about twice as long. Programmers already hate the time
compilers take, and do not want to use compilers that make unnecessary
passes on their source code, making prototypes a necessity. Also,
prototypes enable the C compiler to do more rigorous error checking, and
that saves an enormous amount of time and grief.

------------------------------------------------------------------------

[]{#The-exit-function}

  --------------------------------------------------------------------- -------------------------------------------------------------------- --- ------------------------------------------------------------------------ ----------------------------------- -------------------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Function-prototyping "Previous section in reading order")\]   \[[\>](#Questions-for-Chapter-4 "Next section in reading order")\]       \[[\<\<](#Functions "Beginning of this chapter or previous chapter")\]   \[[Up](#Functions "Up section")\]   \[[\>\>](#Variables-and-declarations "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  --------------------------------------------------------------------- -------------------------------------------------------------------- --- ------------------------------------------------------------------------ ----------------------------------- -------------------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#The-exit-function-1}

4.5 The `exit` function {#the-exit-function .section}
-----------------------

[]{#index-exit-command} []{#index-return-command}

GNU coding standards specify that you should always use `exit` (or
`return`) within your `main` function. (See section [Style](#Style).)

You can use the `exit` function to terminate a program at any point, no
matter how many function calls have been made. Before it terminates the
program, it calls a number of other functions that perform tidy-up
duties such as closing open files.

[]{#index-exit-command-1} []{#index-Return-codes}

`exit` is called with a *return code*, like this:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | exit(0);                          |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

In the example above, the return code is `0`. Any program that calls
your program can read the return code from your program. The return code
is like a return value from another function that is not `main`; in
fact, most of the time you can use the `return` command within your
`main`, instead of `exit`.

Conventionally, a return code of `0` specifies that your program has
ended normally and all is well. (You can remember this as "zero errors",
although for technical reasons, you cannot use the number of errors your
program found as the return code. See section [Style](#Style).) A return
code other than `0` indicates that some sort of error has occurred. If
your code terminates when it encounters an error, use `exit`, and
specify a non-zero return code.

------------------------------------------------------------------------

[]{#Questions-for-Chapter-4}

  ------------------------------------------------------------------ ----------------------------------------------------------------------- --- ------------------------------------------------------------------------ ----------------------------------- -------------------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#The-exit-function "Previous section in reading order")\]   \[[\>](#Variables-and-declarations "Next section in reading order")\]       \[[\<\<](#Functions "Beginning of this chapter or previous chapter")\]   \[[Up](#Functions "Up section")\]   \[[\>\>](#Variables-and-declarations "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ------------------------------------------------------------------ ----------------------------------------------------------------------- --- ------------------------------------------------------------------------ ----------------------------------- -------------------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Questions-for-Chapter-4-1}

4.6 Questions for Chapter 4 {#questions-for-chapter-4 .section}
---------------------------

1.  Write a function that takes two values a and b, then returns the
    value of a \* b (that is, `a` times `b`.)
2.  Is there anything wrong with a function that returns no value?
3.  What happens if a function returns a value but you do not assign
    that value to anything?
4.  What happens if a variable is assigned the result of a function, but
    the function does not return a value?
5.  How can you make a program terminate, anywhere in the program?

------------------------------------------------------------------------

[]{#Variables-and-declarations}

  ------------------------------------------------------------------------ -------------------------------------------------------------- --- ------------------------------------------------------------------------ ----------------------------- ----------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Questions-for-Chapter-4 "Previous section in reading order")\]   \[[\>](#Integer-variables "Next section in reading order")\]       \[[\<\<](#Functions "Beginning of this chapter or previous chapter")\]   \[[Up](#Top "Up section")\]   \[[\>\>](#Scope "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ------------------------------------------------------------------------ -------------------------------------------------------------- --- ------------------------------------------------------------------------ ----------------------------- ----------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Variables-and-declarations-1}

5. Variables and declarations {#variables-and-declarations .chapter}
=============================

*Storing data. Discriminating types. Declaring data.*

[]{#index-Variables}
[]{#index-Variable-names_002c-characters-available-for}

Variable names in C follow the same rules as function names, as far as
what characters they can contain. (See section [Function
names](#Function-names).) Variables work differently from functions,
however. Every variable in C has a *data type*, or *type*, that conveys
to the the compiler what sort of data will be stored in it. Functions in
C are sometimes said to have types, but a function's type is actually
the data type of the variable it returns.

[]{#index-Declaring-variables} []{#index-Variables_002c-declaring}

In some older computer languages like BASIC, and even some newer ones
like Perl, you can tell what type a variable is because its name begins
or ends with a special character. For example, in many versions of
BASIC, all integer variable names end with a percent sign ('%') --- for
example, 'YEAR%'. No such convention exists in C. Instead, we declare
variables, or tell the compiler that they are of a certain type, before
they are used. This feature of C has the following advantages (among
others):

-   It gives a compiler precise information about the amount of memory
    that will have to be allotted to a variable when a program is run,
    and what sort of arithmetic will have to be used with it (e.g.
    integer, floating point, or none at all).
-   It provides the compiler with a list of the variables so that it can
    catch errors in the code, such as assigning a string to an integer
    variable.

There are a lot of variable types in C. In fact, you can define your
own, but there are some basic types ready for use. We will discuss them
in the following sections.

  --------------------------------------------------------- ---- --
  [5.1 Integer variables](#Integer-variables)                    
  [5.2 Declarations](#Declarations)                              
  [5.3 Initialization](#Initialization)                          
  [5.4 The cast operator](#The-cast-operator)                    
  [5.5 Storage classes](#Storage-classes)                        
  [5.6 Questions for Chapter 5](#Questions-for-Chapter-5)        
  --------------------------------------------------------- ---- --

------------------------------------------------------------------------

[]{#Integer-variables}

  --------------------------------------------------------------------------- ---------------------------------------------------------- --- ----------------------------------------------------------------------------------------- ---------------------------------------------------- ----------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Variables-and-declarations "Previous section in reading order")\]   \[[\>](#The-char-type "Next section in reading order")\]       \[[\<\<](#Variables-and-declarations "Beginning of this chapter or previous chapter")\]   \[[Up](#Variables-and-declarations "Up section")\]   \[[\>\>](#Scope "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  --------------------------------------------------------------------------- ---------------------------------------------------------- --- ----------------------------------------------------------------------------------------- ---------------------------------------------------- ----------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Integer-variables-1}

5.1 Integer variables {#integer-variables .section}
---------------------

[]{#index-Variables_002c-integer} []{#index-Integer-variables}

C has five kinds of *integer*. An integer is a whole number (a number
without a fractional part). In C, there are a limited number of integers
possible; how many depends on the type of integer. In arithmetic, you
can have as large a number as you like, but C integer types always have
a largest (and smallest) possible number.

[]{#index-char-type} []{#index-short-type} []{#index-int-type}
[]{#index-long-type} []{#index-long-long-type}

-   `char`: A single byte, usually one ASCII character. (See the section
    on the `char` type below.)
-   `short`: A short integer (16 bits long on most GNU systems). Also
    called `short int`. Rarely used.
-   `int`: A standard integer (32 bits long on most GNU systems).
-   `long`: A long integer (32 bits long on most GNU systems, the same
    as `int`). Also called `long int`.
-   `long long`: A long long integer (64 bits long on most GNU systems).
    Also called `long long int`.

[]{#index-Operating-systems_002c-64_002dbit}

64-bit operating systems are now appearing in which long integers are 64
bits long. With GCC, long integers are normally 32 bits long and long
long integers are 64 bits long, but it varies with the computer hardware
and implementation of GCC, so check your system's documentation.

[]{#index-Integer-variables_002c-sizes-of}
[]{#index-Variables_002c-integer_002c-sizes-of}

These integer types differ in the size of the integer they can hold and
the amount of storage required for them. The sizes of these variables
depend on the hardware and operating system of the computer. On a
typical 32-bit GNU system, the sizes of the integer types are as
follows.

[]{#index-char-type-1} []{#index-unsigned-char-type}
[]{#index-short-type-1} []{#index-unsigned-short-type}
[]{#index-int-type-1} []{#index-unsigned-int-type}
[]{#index-long-type-1} []{#index-unsigned-long-type}
[]{#index-long-long-type-1} []{#index-unsigned-long-long-type}

  ---------------------- ---------- ---------------------------------------------------------
  **Type**               **Bits**   **Possible Values**
  `char`                 8          -127 to 127
  `unsigned char`        8          0 to 255
                                    
  `short`                16         -32,767 to 32,767
  `unsigned short`       16         0 to 65,535
                                    
  `int`                  32         -2,147,483,647 to 2,147,483,647
  `unsigned int`         32         0 to 4,294,967,295
                                    
  `long`                 32         -2,147,483,647 to 2,147,483,647
  `unsigned long`        32         0 to 4,294,967,295
                                    
  `long long`            64         -9,223,372,036,854,775,807 to 9,223,372,036,854,775,807
  `unsigned long long`   64         0 to 18,446,744,073,709,551,615
  ---------------------- ---------- ---------------------------------------------------------

On some computers, the lowest possible value may be 1 less than shown
here; for example, the smallest possible `short` may be -32,768 rather
than -32,767.

The word `unsigned`, when placed in front of integer types, means that
only positive or zero values can be used in that variable (i.e. it
cannot have a minus sign). The advantage is that larger numbers can then
be stored in the same variable. The ANSI standard also allows the word
`signed` to be placed before an integer, to indicate the opposite of
`unsigned`.

  ------------------------------------------------------------- ---- --
  [5.1.1 The `char` type](#The-char-type)                            
  [5.1.2 Floating point variables](#Floating-point-variables)        
  ------------------------------------------------------------- ---- --

------------------------------------------------------------------------

[]{#The-char-type}

  ------------------------------------------------------------------ --------------------------------------------------------------------- --- ----------------------------------------------------------------------------------------- ------------------------------------------- ----------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Integer-variables "Previous section in reading order")\]   \[[\>](#Floating-point-variables "Next section in reading order")\]       \[[\<\<](#Variables-and-declarations "Beginning of this chapter or previous chapter")\]   \[[Up](#Integer-variables "Up section")\]   \[[\>\>](#Scope "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ------------------------------------------------------------------ --------------------------------------------------------------------- --- ----------------------------------------------------------------------------------------- ------------------------------------------- ----------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#The-char-type-1}

### 5.1.1 The `char` type {#the-char-type .subsection}

[]{#index-char-type-2} []{#index-unsigned-char-type-1}

`char` is a special integer type designed for storing single characters.
The integer value of a `char` corresponds to an ASCII character. For
example, a value of 65 corresponds to the letter 'A', 66 corresponds to
'B', 67 to 'C', and so on.

As in the table above, `unsigned char` permits values from 0 to 255, and
`signed char` permits values from -127 (or -128) to 127. The `char` type
is signed by default on some computers, but unsigned on others. (See
section [Character conversion table](#Character-conversion-table). See
section [Special characters](#Special-characters).)

`char` is used only within arrays; variables meant to hold one character
should be declared `int`. (See section [Strings](#Strings), for more
information on character arrays. See section [Cast operator
demo](#Cast-operator-demo), for an example of how to use an integer
variable to hold a character value.)

------------------------------------------------------------------------

[]{#Floating-point-variables}

  -------------------------------------------------------------- --------------------------------------------------------- --- ----------------------------------------------------------------------------------------- ------------------------------------------- ----------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#The-char-type "Previous section in reading order")\]   \[[\>](#Declarations "Next section in reading order")\]       \[[\<\<](#Variables-and-declarations "Beginning of this chapter or previous chapter")\]   \[[Up](#Integer-variables "Up section")\]   \[[\>\>](#Scope "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  -------------------------------------------------------------- --------------------------------------------------------- --- ----------------------------------------------------------------------------------------- ------------------------------------------- ----------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Floating-point-variables-1}

### 5.1.2 Floating point variables {#floating-point-variables .subsection}

[]{#index-Floating-point-variables}
[]{#index-Variables_002c-floating-point}
[]{#index-Floating-point-numbers} []{#index-Numbers_002c-floating-point}
[]{#index-float-type} []{#index-double-type}

*Floating point numbers* are numbers with a decimal point. There are
different sizes of floating point numbers in C. The `float` type can
contain large floating point numbers with a small degree of precision,
but the double-precision `double` type can hold even larger numbers with
a higher degree of precision. (*Precision* is simply the number of
decimal places to which a number can be computed with accuracy. If a
number can be computed to five decimal places, it is said to have five
*significant digits*.)

[]{#index-double-type-1} []{#index-long-float-type}

All floating point mathematical functions built into C require `double`
or `long float` arguments (`long float` variables are generally the same
as `double` variables on GNU systems), so it is common to use `float`
only for storage of small floating point numbers, and to use `double`
everywhere else.

Here are the floating point variable types available in C:

[]{#index-float-type-1} []{#index-long-float-type-1}
[]{#index-double-type-2} []{#index-long-double-type}

-   `float`: A single-precision floating point number, with at least 6
    significant decimal digits.
-   `double`: A double-precision floating point number. Usually the same
    as `long float` on GNU systems. Has at least 10 significant decimal
    digits.
-   `long double`: Usually the same as `double` on GNU systems, but may
    be a 128-bit number in some cases.

On a typical 32-bit GNU system, the sizes of the different floating
point types are as follows.

[]{#index-float-type-2} []{#index-long-float-type-2}
[]{#index-double-type-3} []{#index-long-double-type-1}

  --------------- ---------- -------------------------------
  **Type**        **Bits**   **Possible values (approx.)**
  `float`         32         1e-38 to 1e+38
  `double`        64         2e-308 to 1e+308
  `long double`   64         2e-308 to 1e+308
  --------------- ---------- -------------------------------

\
\

You may find the figures in the right-hand column confusing. They use a
form of shorthand for large numbers. For example, the number 5e2 means
[![\$5 \* 10\^2\$](ctut_1.svg)]{.MATH}, or 500. 5e-2 means [![\$5 \*
10\^-2\$](ctut_2.svg)]{.MATH} ([![\$5/100\$](ctut_3.svg)]{.MATH}, or
[![\$1/20\$](ctut_4.svg)]{.MATH}). You can see, therefore, that the
`float`, `double`, and `long double` types can contain some very large
and very small numbers indeed. (When you work with large and small
numbers in C, you will use this notation in your code.)

------------------------------------------------------------------------

[]{#Declarations}

  ------------------------------------------------------------------------- ----------------------------------------------------------- --- ----------------------------------------------------------------------------------------- ---------------------------------------------------- ----------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Floating-point-variables "Previous section in reading order")\]   \[[\>](#Initialization "Next section in reading order")\]       \[[\<\<](#Variables-and-declarations "Beginning of this chapter or previous chapter")\]   \[[Up](#Variables-and-declarations "Up section")\]   \[[\>\>](#Scope "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ------------------------------------------------------------------------- ----------------------------------------------------------- --- ----------------------------------------------------------------------------------------- ---------------------------------------------------- ----------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Declarations-1}

5.2 Declarations {#declarations .section}
----------------

[]{#index-Declaring-variables-1} []{#index-Variables_002c-declaring-1}

To declare a variable, write the type followed by a list of variables of
that type:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | type_name variable_name_1, …, var |
|                                   | iable_name_n;                     |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

For example:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | int last_year, cur_year;          |
|                                   | long double earth_mass, mars_mass |
|                                   | , venus_mass;                     |
|                                   | unsigned int num_pets;            |
|                                   |                                   |
|                                   | long city_pop, state_pop;         |
|                                   | state_pop = city_pop = 5000000;   |
|                                   |                                   |
|                                   | short moon_landing = 1969;        |
|                                   |                                   |
|                                   | float temp1, temp2, temp3;        |
|                                   | temp1 = 98.6;                     |
|                                   | temp2 = 98.7;                     |
|                                   | temp3 = 98.5;                     |
|                                   |                                   |
|                                   | double bignum, smallnum;          |
|                                   | bignum = 2.36e208;                |
|                                   | smallnum = 3.2e-300;              |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

Always declare your variables. A compiler will catch a missing
declaration every time and terminate compilation, complaining bitterly.
(You will often see a host of error messages, one for each use of the
undeclared variable. See section [Debugging](#Debugging).)

------------------------------------------------------------------------

[]{#Initialization}

  ------------------------------------------------------------- -------------------------------------------------------------- --- ----------------------------------------------------------------------------------------- ---------------------------------------------------- ----------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Declarations "Previous section in reading order")\]   \[[\>](#The-cast-operator "Next section in reading order")\]       \[[\<\<](#Variables-and-declarations "Beginning of this chapter or previous chapter")\]   \[[Up](#Variables-and-declarations "Up section")\]   \[[\>\>](#Scope "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ------------------------------------------------------------- -------------------------------------------------------------- --- ----------------------------------------------------------------------------------------- ---------------------------------------------------- ----------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Initialization-1}

5.3 Initialization {#initialization .section}
------------------

[]{#index-Variables_002c-initializing} []{#index-Initializing-variables}

Assigning a variable its first value is called *initializing* the
variable. When you declare a variable in C, you can also initialize it
at the same time. This is no more efficient in terms of a running
program than doing it in two stages, but sometimes creates tidier and
more compact code. Consider the following:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | int initial_year;                 |
|                                   | float percent_complete;           |
|                                   |                                   |
|                                   | initial_year = 1969;              |
|                                   | percent_complete = 89.5;          |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

The code above is equivalent to the code below, but the code below is
more compact.

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | int initial_year = 1969;          |
|                                   | float percent_complete = 89.5;    |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

You can always write declarations and initializers this way, but you may
not always want to. (See section [Style](#Style).)

------------------------------------------------------------------------

[]{#The-cast-operator}

  --------------------------------------------------------------- --------------------------------------------------------------- --- ----------------------------------------------------------------------------------------- ---------------------------------------------------- ----------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Initialization "Previous section in reading order")\]   \[[\>](#Cast-operator-demo "Next section in reading order")\]       \[[\<\<](#Variables-and-declarations "Beginning of this chapter or previous chapter")\]   \[[Up](#Variables-and-declarations "Up section")\]   \[[\>\>](#Scope "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  --------------------------------------------------------------- --------------------------------------------------------------- --- ----------------------------------------------------------------------------------------- ---------------------------------------------------- ----------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#The-cast-operator-1}

5.4 The cast operator {#the-cast-operator .section}
---------------------

[]{#index-cast-operator} []{#index-Casting-types}
[]{#index-Types_002c-casting}

An *operator* is a symbol or string of C characters used as a function.
One very valuable operator in C is the *cast operator*, which converts
one type into another. Its general form is as follows:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | (type) variable                   |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

For example, floating point and integer types can be interconverted:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | float exact_length;               |
|                                   | int rough_length;                 |
|                                   |                                   |
|                                   | exact_length = 3.37;              |
|                                   | rough_length = (int) exact_length |
|                                   | ;                                 |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

In the example above, the cast operator rounds the number down when
converting it from a float to an integer, because an integer number
cannot represent the fractional part after the decimal point. Note that
C always *truncates*, or rounds down, a number when converting it to an
integer. For example, both 3.1 and 3.9 are truncated to 3 when C is
converting them to integer values.

The cast operator works the other way around, too:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | float exact_length;               |
|                                   | int rough_length;                 |
|                                   |                                   |
|                                   | rough_length = 12;                |
|                                   | exact_length = (float) rough_leng |
|                                   | th;                               |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

In converting large integers to floating point numbers, you may lose
some precision, since the `float` type guarantees only 6 significant
digits, and the `double` type guarantees only 10.

It does not always make sense to convert types. (See section [Data
structures](#Data-structures), for examples of types that do not convert
to other types well.)

  ------------------------------------------------- ---- --
  [5.4.1 Cast operator demo](#Cast-operator-demo)        
  ------------------------------------------------- ---- --

------------------------------------------------------------------------

[]{#Cast-operator-demo}

  ------------------------------------------------------------------ ------------------------------------------------------------ --- ----------------------------------------------------------------------------------------- ------------------------------------------- ----------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#The-cast-operator "Previous section in reading order")\]   \[[\>](#Storage-classes "Next section in reading order")\]       \[[\<\<](#Variables-and-declarations "Beginning of this chapter or previous chapter")\]   \[[Up](#The-cast-operator "Up section")\]   \[[\>\>](#Scope "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ------------------------------------------------------------------ ------------------------------------------------------------ --- ----------------------------------------------------------------------------------------- ------------------------------------------- ----------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Cast-operator-demo-1}

### 5.4.1 Cast operator demo {#cast-operator-demo .subsection}

[]{#index-cast-operator-1} []{#index-Casting-types_002c-example}
[]{#index-Types_002c-casting_002c-example}

The following is an example of how to use the cast operator in C code.
It also shows how to use an integer variable to store a character value.

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | /******************************** |
|                                   | *******************/              |
|                                   | /*                                |
|                                   |                   */              |
|                                   | /* Demo of Cast operator          |
|                                   |                   */              |
|                                   | /*                                |
|                                   |                   */              |
|                                   | /******************************** |
|                                   | *******************/              |
|                                   |                                   |
|                                   | #include <stdio.h>                |
|                                   |                                   |
|                                   | int main()               /* Use i |
|                                   | nt float and int */               |
|                                   | {                                 |
|                                   |   float my_float;                 |
|                                   |   int my_int;                     |
|                                   |   int my_ch;                      |
|                                   |                                   |
|                                   |   my_float = 75.345;              |
|                                   |   my_int = (int) my_float;        |
|                                   |   my_ch = (int) my_float;         |
|                                   |   printf ("Convert from float my_ |
|                                   | float=%f to my_int=%d and my_ch=% |
|                                   | c\n",                             |
|                                   |     my_float, my_int, my_ch);     |
|                                   |                                   |
|                                   |   my_int = 69;                    |
|                                   |   my_float = (float) my_int;      |
|                                   |   my_ch = my_int;                 |
|                                   |   printf ("Convert from int my_in |
|                                   | t=%d to my_float=%f and my_ch=%c\ |
|                                   | n",                               |
|                                   |     my_int, my_float, my_ch);     |
|                                   |                                   |
|                                   |   my_ch = '*';                    |
|                                   |   my_int = my_ch;                 |
|                                   |   my_float = (float) my_ch;       |
|                                   |   printf ("Convert from int my_ch |
|                                   | =%c to my_int=%d and my_float=%f\ |
|                                   | n",                               |
|                                   |     my_ch, my_int, my_float);     |
|                                   |                                   |
|                                   |   exit(0);                        |
|                                   | }                                 |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

Here is the sort of output you should expect (floating point values may
differ slightly):

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | Convert from float my_float=75.34 |
|                                   | 5001 to my_int=75 and my_ch=K     |
|                                   | Convert from int my_int=69 to my_ |
|                                   | float=69.000000 and my_ch=E       |
|                                   | Convert from int my_ch=* to my_in |
|                                   | t=42 and my_float=42.000000       |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

------------------------------------------------------------------------

[]{#Storage-classes}

  ------------------------------------------------------------------- --------------------------------------------------------------- --- ----------------------------------------------------------------------------------------- ---------------------------------------------------- ----------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Cast-operator-demo "Previous section in reading order")\]   \[[\>](#External-variables "Next section in reading order")\]       \[[\<\<](#Variables-and-declarations "Beginning of this chapter or previous chapter")\]   \[[Up](#Variables-and-declarations "Up section")\]   \[[\>\>](#Scope "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ------------------------------------------------------------------- --------------------------------------------------------------- --- ----------------------------------------------------------------------------------------- ---------------------------------------------------- ----------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Storage-classes-1}

5.5 Storage classes {#storage-classes .section}
-------------------

[]{#index-Storage-classes} []{#index-Classes_002c-storage}

There are a few variable declaration keywords commonly used in C that do
not specify variable types, but a related concept called *storage
classes*. Two common examples of storage class specifiers are the
keywords `extern` and `static`.

  ------------------------------------------------------- ---- --
  [5.5.1 External variables](#External-variables)              
  [5.5.2 Static variables](#Static-variables)                  
  [5.5.3 Other storage classes](#Other-storage-classes)        
  ------------------------------------------------------- ---- --

------------------------------------------------------------------------

[]{#External-variables}

  ---------------------------------------------------------------- ------------------------------------------------------------- --- ----------------------------------------------------------------------------------------- ----------------------------------------- ----------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Storage-classes "Previous section in reading order")\]   \[[\>](#Static-variables "Next section in reading order")\]       \[[\<\<](#Variables-and-declarations "Beginning of this chapter or previous chapter")\]   \[[Up](#Storage-classes "Up section")\]   \[[\>\>](#Scope "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ---------------------------------------------------------------- ------------------------------------------------------------- --- ----------------------------------------------------------------------------------------- ----------------------------------------- ----------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#External-variables-1}

### 5.5.1 External variables {#external-variables .subsection}

[]{#index-Variables_002c-external} []{#index-External-variables}
[]{#index-extern-storage-class-specifier}

Sometimes the source code for a C program is contained in more than one
text file. If this is the case, then it may be necessary to use
variables that are defined in another file. You can use a global
variable in files other than the one in which it is defined by
redeclaring it, prefixed by the `extern` specifier, in the other files.

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | File main.c                  File |
|                                   |  secondary.c                      |
|                                   |                                   |
|                                   |                           #includ |
|                                   | e <stdio.h>                       |
|                                   |                           int my_ |
|                                   | var;                              |
|                                   | int main()                        |
|                                   | {                                 |
|                                   |   extern int my_var;      void pr |
|                                   | int_value()                       |
|                                   |                           {       |
|                                   |   my_var = 500;             print |
|                                   | f("my_var = %d\n", my_var);       |
|                                   |   print_value();          }       |
|                                   |   exit (0);                       |
|                                   | }                                 |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

In this example, the variable `my_var` is created in the file
'`secondary.c`', assigned a value in the file '`main.c`', and printed
out in the function `print_value`, which is defined in the file
'`secondary.c`', but called from the file '`main.c`'.

See section [Compiling multiple files](#Compiling-multiple-files), for
information on how to compile a program whose source code is split among
multiple files. For this example, you can simply type the command
`gcc -o testprog main.c secondary.c`, and run the program with
`./testprog`.

------------------------------------------------------------------------

[]{#Static-variables}

  ------------------------------------------------------------------- ------------------------------------------------------------------ --- ----------------------------------------------------------------------------------------- ----------------------------------------- ----------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#External-variables "Previous section in reading order")\]   \[[\>](#Other-storage-classes "Next section in reading order")\]       \[[\<\<](#Variables-and-declarations "Beginning of this chapter or previous chapter")\]   \[[Up](#Storage-classes "Up section")\]   \[[\>\>](#Scope "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ------------------------------------------------------------------- ------------------------------------------------------------------ --- ----------------------------------------------------------------------------------------- ----------------------------------------- ----------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Static-variables-1}

### 5.5.2 Static variables {#static-variables .subsection}

[]{#index-Static-variables} []{#index-Variables_002c-static}
[]{#index-static-storage-class-specifier}

A second important storage class specifier is `static`. Normally, when
you call a function, all its local variables are reinitialized each time
the function is called. This means that their values change between
function calls. Static variables, however, maintain their value between
function calls.

Every global variable is defined as `static` automatically. (Roughly
speaking, functions anywhere in a program can refer to a global
variable; in contrast, a function can only refer to a local variable
that is "nearby", where "nearby" is defined in a specific manner. See
section [Scope](#Scope), for more information on global variables. See
section [Expressions and operators](#Expressions-and-operators), for an
example of a static local variable.)

------------------------------------------------------------------------

[]{#Other-storage-classes}

  ----------------------------------------------------------------- -------------------------------------------------------------------- --- ----------------------------------------------------------------------------------------- ----------------------------------------- ----------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Static-variables "Previous section in reading order")\]   \[[\>](#Questions-for-Chapter-5 "Next section in reading order")\]       \[[\<\<](#Variables-and-declarations "Beginning of this chapter or previous chapter")\]   \[[Up](#Storage-classes "Up section")\]   \[[\>\>](#Scope "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ----------------------------------------------------------------- -------------------------------------------------------------------- --- ----------------------------------------------------------------------------------------- ----------------------------------------- ----------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Other-storage-classes-1}

### 5.5.3 Other storage classes {#other-storage-classes .subsection}

[]{#index-Storage-classes-1} []{#index-Classes_002c-storage-1}
[]{#index-auto-storage-class-specifier}
[]{#index-register-storage-class-specifier}

There are three more storage class identifiers in C: `auto`, `register`,
and `typedef`.

-   `auto` is the opposite of `static`. It is redundant, but is included
    in contemporary versions of C for backwards compatibility. All local
    variables are `auto` by default.
-   `register` is another outdated C storage class. Defining a variable
    as `register` used to store it in one of the computer's registers, a
    specific location on its processor chip, thereby making code using
    that variable run faster. These days, most C compilers (including
    GCC) are smart enough to *optimize* the code (make it faster and
    more compact) without the `register` keyword.
-   `typedef` allows you to define your own variable types. See section
    [More data types](#More-data-types), for more information.

------------------------------------------------------------------------

[]{#Questions-for-Chapter-5}

  ---------------------------------------------------------------------- -------------------------------------------------- --- ----------------------------------------------------------------------------------------- ---------------------------------------------------- ----------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Other-storage-classes "Previous section in reading order")\]   \[[\>](#Scope "Next section in reading order")\]       \[[\<\<](#Variables-and-declarations "Beginning of this chapter or previous chapter")\]   \[[Up](#Variables-and-declarations "Up section")\]   \[[\>\>](#Scope "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ---------------------------------------------------------------------- -------------------------------------------------- --- ----------------------------------------------------------------------------------------- ---------------------------------------------------- ----------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Questions-for-Chapter-5-1}

5.6 Questions for Chapter 5 {#questions-for-chapter-5 .section}
---------------------------

1.  What is an identifier?
2.  Which of the following are valid C variable names?
    1.  `Ralph23`
    2.  `80shillings`
    3.  `mission_control`
    4.  `A%`
    5.  `A$`
    6.  `_off`
3.  Write a statement to declare two integers called `start_temperature`
    and `end_temperature`.
4.  What is the difference between the types `float` and `double`?
5.  What is the difference between the types `int` and `unsigned int`?
6.  Write a statement that assigns the value 1066 to the integer
    variable `norman`.
7.  What data type do C functions return by default?
8.  You must declare the data type a function returns at two places in a
    program. Where?
9.  Write a statement, using the cast operator, to print out the integer
    part of the number 23.1256.
10. Is it possible to have an automatic global variable?

------------------------------------------------------------------------

[]{#Scope}

  ------------------------------------------------------------------------ ------------------------------------------------------------- --- ----------------------------------------------------------------------------------------- ----------------------------- ------------------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Questions-for-Chapter-5 "Previous section in reading order")\]   \[[\>](#Global-variables "Next section in reading order")\]       \[[\<\<](#Variables-and-declarations "Beginning of this chapter or previous chapter")\]   \[[Up](#Top "Up section")\]   \[[\>\>](#Expressions-and-operators "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ------------------------------------------------------------------------ ------------------------------------------------------------- --- ----------------------------------------------------------------------------------------- ----------------------------- ------------------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Scope-1}

6. Scope {#scope .chapter}
========

*Where a program's fingers can and can't reach.*

[]{#index-Functions_002c-as-buildings}
[]{#index-Buildings-as-metaphor-for-functions}
[]{#index-Visibility-of-variables} []{#index-Scope-of-variables}
[]{#index-Variables_002c-visibility-of}
[]{#index-Variables_002c-scope-of} []{#index-Curly-brackets-as-walls}
[]{#index-Walls_002c-as-metaphors-for-curly-brackets}

Imagine that a function is a building with a person (Fred) standing in
the doorway. This person can see certain things: other people and other
buildings, out in the open. But Fred cannot see certain other things,
such as the people inside the other buildings. Just so, some variables
in a C program, like the people standing outside, are *visible* to
nearly every other part of the program (these are called *global
variables*), while other variables, like the people indoors, are hidden
behind the "brick walls" of curly brackets (these are called *local
variables*).

Where a variable is visible to other C code is called the *scope* of
that variable. There are two main kinds of scope, global and local,
which stem from the two kinds of places in which you can declare a
variable:

1.  []{#index-Global-scope} []{#index-Scope_002c-global}
2.  *Global scope* is outside all of the functions, that is, in the
    space between function definitions --- after the `#include` lines,
    for example. Variables declared in global scope are called *global
    variables*. Global variables can be used in any function, as well as
    in any block within that function.
    +-----------------------------------+-----------------------------------+
    |                                   | ``` {.smallexample}               |
    |                                   | #include <stdio.h>                |
    |                                   |                                   |
    |                                   | int global_integer;               |
    |                                   | float global_floating_point;      |
    |                                   |                                   |
    |                                   | int main ()                       |
    |                                   | {                                 |
    |                                   |   exit (0);                       |
    |                                   | }                                 |
    |                                   | ```                               |
    +-----------------------------------+-----------------------------------+

    []{#index-Local-scope} []{#index-Scope_002c-local}
3.  You can also declare variables immediately following the opening
    bracket ('{') of any block of code. This area is called *local
    scope*, and variables declared here are called *local variables*. A
    local variable is visible within its own block and the ones that
    block contains, but invisible outside its own block.
    +-----------------------------------+-----------------------------------+
    |                                   | ``` {.smallexample}               |
    |                                   | #include <stdio.h>                |
    |                                   |                                   |
    |                                   | int main()                        |
    |                                   | {                                 |
    |                                   |   int foo;                        |
    |                                   |   float bar, bas, quux;           |
    |                                   |                                   |
    |                                   |   exit (0);                       |
    |                                   | }                                 |
    |                                   | ```                               |
    +-----------------------------------+-----------------------------------+

  ------------------------------------------------------------------- ---- --
  [6.1 Global Variables](#Global-variables)                                
  [6.2 Local Variables](#Local-variables)                                  
  [6.3 Communication via parameters](#Communication-via-parameters)        
  [6.4 Scope example](#Scope-example)                                      
  [6.5 Questions for Chapter 6](#Questions-for-Chapter-6)                  
  ------------------------------------------------------------------- ---- --

------------------------------------------------------------------------

[]{#Global-variables}

  ------------------------------------------------------ ------------------------------------------------------------ --- -------------------------------------------------------------------- ------------------------------- ------------------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Scope "Previous section in reading order")\]   \[[\>](#Local-variables "Next section in reading order")\]       \[[\<\<](#Scope "Beginning of this chapter or previous chapter")\]   \[[Up](#Scope "Up section")\]   \[[\>\>](#Expressions-and-operators "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ------------------------------------------------------ ------------------------------------------------------------ --- -------------------------------------------------------------------- ------------------------------- ------------------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Global-Variables}

6.1 Global Variables {#global-variables .section}
--------------------

[]{#index-Global-variables} []{#index-Variables_002c-global}

Global variables can be used in any function, as well as any block
within that function. (Technically, global variables can only be seen by
functions that are defined after the declaration of those global
variables, but global variables are usually declared in a header file
that is included everywhere they are needed.) Global variables are
created when a program is started and are not destroyed until a program
is stopped.

------------------------------------------------------------------------

[]{#Local-variables}

  ----------------------------------------------------------------- ------------------------------------------------------------------------- --- -------------------------------------------------------------------- ------------------------------- ------------------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Global-variables "Previous section in reading order")\]   \[[\>](#Communication-via-parameters "Next section in reading order")\]       \[[\<\<](#Scope "Beginning of this chapter or previous chapter")\]   \[[Up](#Scope "Up section")\]   \[[\>\>](#Expressions-and-operators "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ----------------------------------------------------------------- ------------------------------------------------------------------------- --- -------------------------------------------------------------------- ------------------------------- ------------------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Local-Variables}

6.2 Local Variables {#local-variables .section}
-------------------

[]{#index-Local-variables} []{#index-Variables_002c-local}

Local variables, on the other hand, are only visible within local scope.
They are "trapped" inside their code blocks.

[]{#index-Code-blocks} []{#index-Blocks_002c-code}

Just as global scope contains many functions, however, each function can
contain many code blocks (defined with curly brackets: '{...}'). C
allows blocks within blocks, even functions within functions, *ad
infinitum*. A local variable is visible within its own block and the
ones that block contains, but invisible outside its own block.

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | int a;                            |
|                                   |                                   |
|                                   | /* Global scope.  Global variable |
|                                   |  'a' is visible here,             |
|                                   |    but not local variables 'b' or |
|                                   |  'c'. */                          |
|                                   |                                   |
|                                   | int main()                        |
|                                   | {                                 |
|                                   |   int b;                          |
|                                   |                                   |
|                                   |   /* Local scope of 'main'.       |
|                                   |      Variables 'a' and 'b' are vi |
|                                   | sible here,                       |
|                                   |      but not 'c'. */              |
|                                   |                                   |
|                                   |   {                               |
|                                   |     int c;                        |
|                                   |                                   |
|                                   |     /* Local scope of ‘{…}’ block |
|                                   |  within 'main'.                   |
|                                   |        Variables 'a', 'b', and 'c |
|                                   | ' are all visible here. */        |
|                                   |   }                               |
|                                   |                                   |
|                                   |   exit (0);                       |
|                                   | }                                 |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

[]{#index-Local-variables_002c-visibility-of}
[]{#index-Local-variables_002c-scope-of}
[]{#index-Variables_002c-local_002c-visibility-of}
[]{#index-Variables_002c-local_002c-scope-of}
[]{#index-Scope-of-local-variables}
[]{#index-Visibility-of-local-variables}

Local variables are not visible outside their curly brackets. To use an
"existence" rather than a "visibility" metaphor, local variables are
created when the opening brace is met, and they are destroyed when the
closing brace is met. (Do not take this too literally; they are not
created and destroyed in your C source code, but internally to the
computer, when you run the program.)

------------------------------------------------------------------------

[]{#Communication-via-parameters}

  ---------------------------------------------------------------- ---------------------------------------------------------- --- -------------------------------------------------------------------- ------------------------------- ------------------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Local-variables "Previous section in reading order")\]   \[[\>](#Scope-example "Next section in reading order")\]       \[[\<\<](#Scope "Beginning of this chapter or previous chapter")\]   \[[Up](#Scope "Up section")\]   \[[\>\>](#Expressions-and-operators "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ---------------------------------------------------------------- ---------------------------------------------------------- --- -------------------------------------------------------------------- ------------------------------- ------------------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Communication-via-parameters-1}

6.3 Communication via parameters {#communication-via-parameters .section}
--------------------------------

[]{#index-Parameters-1} []{#index-Communication-via-parameters}
[]{#index-Parameters_002c-communication-via}

If no code inside a function could ever communicate with other parts of
the program, then functions would not be very useful. Functions would be
isolated, comatose, unable to do much of anything. Fortunately, although
local variables are invisible outside their code blocks, they can still
communicate with other functions via parameters. See section
[Expressions and operators](#Expressions-and-operators), the next
chapter, for information on parameters.

------------------------------------------------------------------------

[]{#Scope-example}

  ----------------------------------------------------------------------------- -------------------------------------------------------------------- --- -------------------------------------------------------------------- ------------------------------- ------------------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Communication-via-parameters "Previous section in reading order")\]   \[[\>](#Questions-for-Chapter-6 "Next section in reading order")\]       \[[\<\<](#Scope "Beginning of this chapter or previous chapter")\]   \[[Up](#Scope "Up section")\]   \[[\>\>](#Expressions-and-operators "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ----------------------------------------------------------------------------- -------------------------------------------------------------------- --- -------------------------------------------------------------------- ------------------------------- ------------------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Scope-example-1}

6.4 Scope example {#scope-example .section}
-----------------

[]{#index-Scope_002c-example-of} []{#index-Stack_002c-variable}
[]{#index-Variable-stack}

Notice that there are two variables named `my_var` in the example below,
both visible in the same place. When two or more variables visible in
one area of code have the same name, the last variable to be defined
takes priority. (Technically adept readers will realize that this is
because it was the last one onto the variable stack.)

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | /******************************** |
|                                   | *******************************/  |
|                                   | /*                                |
|                                   |                               */  |
|                                   | /* SCOPE                          |
|                                   |                               */  |
|                                   | /*                                |
|                                   |                               */  |
|                                   | /******************************** |
|                                   | *******************************/  |
|                                   |                                   |
|                                   | #include <stdio.h>                |
|                                   |                                   |
|                                   | int main ()                       |
|                                   | {                                 |
|                                   |   int my_var = 3;                 |
|                                   |                                   |
|                                   |   {                               |
|                                   |     int my_var = 5;               |
|                                   |     printf ("my_var=%d\n", my_var |
|                                   | );                                |
|                                   |   }                               |
|                                   |                                   |
|                                   |   printf ("my_var=%d\n", my_var); |
|                                   |                                   |
|                                   |   exit(0);                        |
|                                   | }                                 |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

When you run this example, it will print out the following text:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | my_var=5                          |
|                                   | my_var=3                          |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

------------------------------------------------------------------------

[]{#Questions-for-Chapter-6}

  -------------------------------------------------------------- ---------------------------------------------------------------------- --- -------------------------------------------------------------------- ------------------------------- ------------------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Scope-example "Previous section in reading order")\]   \[[\>](#Expressions-and-operators "Next section in reading order")\]       \[[\<\<](#Scope "Beginning of this chapter or previous chapter")\]   \[[Up](#Scope "Up section")\]   \[[\>\>](#Expressions-and-operators "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  -------------------------------------------------------------- ---------------------------------------------------------------------- --- -------------------------------------------------------------------- ------------------------------- ------------------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Questions-for-Chapter-6-1}

6.5 Questions for Chapter 6 {#questions-for-chapter-6 .section}
---------------------------

1.  What is a global variable?
2.  What is a local variable?
3.  Do parameters spoil functions by leaking the variables into other
    functions?
4.  Write a program `gnoahs_park` that declares 4 variables. Two
    *global* integer variables called `num_gnus` and `num_gnats`, and
    two *local* floating point variables within the function `main`,
    called `avg_gnu_mass`, and `avg_gnat_mass`. Then add another
    function called `calculate_park_biomass`, and pass `avg_gnu_mass`
    and `avg_gnat_mass` to it. How many different storage spaces are
    used when this program runs? (Hint: are `avg_gnu_mass` and
    `avg_gnat_mass` and their copies the same?)

------------------------------------------------------------------------

[]{#Expressions-and-operators}

  ------------------------------------------------------------------------ -------------------------------------------------------------------- --- -------------------------------------------------------------------- ----------------------------- ---------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Questions-for-Chapter-6 "Previous section in reading order")\]   \[[\>](#The-assignment-operator "Next section in reading order")\]       \[[\<\<](#Scope "Beginning of this chapter or previous chapter")\]   \[[Up](#Top "Up section")\]   \[[\>\>](#Parameters "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ------------------------------------------------------------------------ -------------------------------------------------------------------- --- -------------------------------------------------------------------- ----------------------------- ---------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Expressions-and-operators-1}

7. Expressions and operators {#expressions-and-operators .chapter}
============================

*Thinking in C. Short strings of code.*

[]{#index-Operators}

An *operator* is a character or string of characters used as a built-in
function. We have already experimented with one operator in C: the cast
operator.

[]{#index-Addition-operator} []{#index-Operator_002c-addition}
[]{#index-_002b-operator}

An operator is so called because it takes one or more values and
*operates* on them to produce a result. For example, the addition
operator `+` can operate on the values 4 and 5 to produce the result 9.
Such a procedure is called an *operation*, and any value operated on
(such as 4 and 5 in this example) is called an *operand*.

[]{#index-Subtraction-operator} []{#index-Operator_002c-subtraction}
[]{#index-_002d-operator}

There are many operators in C. Some of them are familiar, such as the
addition operator `+` and subtraction operator `-`. Most operators can
be thought of as belonging to one of three groups, according to what
they do with their operands:

-   []{#index-Multiplication-operator}
    []{#index-Operator_002c-multiplication} []{#index-_002a-operator}
    []{#index-Operators_002c-mathematical}
    []{#index-Mathematical-operators}
-   Mathematical operators, such as the addition operator `+` in
    `100 + 500`, or the multiplication operator `*` in `12 * 2`.
    []{#index-Comparison-operators} []{#index-Operators_002c-comparison}
    []{#index-_003c-less_002dthan-operator}
    []{#index-_003e-greater_002dthan-operator}
-   Comparison operators (a subset of mathematical operators), such as
    the less-than operator `<` and the greater-than operator `>`.
    []{#index-Cast-operator} []{#index-Operator_002c-cast}
-   Operators that produce new variable types, such as the cast
    operator.

[]{#index-Boolean-values} []{#index-Values_002c-Boolean}

The majority of operators fall into the first group. The second group is
a subset of the first set; in this second set, the result of an
operation is a *Boolean value* (a value of either true or false).

C has about forty different operators. The chief object of this chapter
is to explain the basic operators in C. We will examine more complex
operators in another chapter. (See section [Advanced
operators](#Advanced-operators).)

  ------------------------------------------------------------------------------------------------------- ---- --
  [7.1 The assignment operator](#The-assignment-operator)                                                      
  [7.2 Expressions and values](#Expressions-and-values)                                                        
  [7.3 Expressions](#Expressions)                                                                              
  [7.4 Parentheses and Priority](#Parentheses-and-Priority)                                                    
  [7.5 Unary Operator Precedence](#Unary-Operator-Precedence)                                                  
  [7.6 Special Assignment Operators `++` and `--`](#Special-Assignment-Operators-_002b_002b-_002d_002d)        
  [7.7 More Special Assignments](#More-Special-Assignments)                                                    
  [7.8 Comparisons and logic](#Comparisons-and-logic)                                                          
  [7.9 Logical operators](#Logical-operators)                                                                  
  [7.10 Questions for Chapter 7](#Questions-for-Chapter-7)                                                     
  ------------------------------------------------------------------------------------------------------- ---- --

------------------------------------------------------------------------

[]{#The-assignment-operator}

  -------------------------------------------------------------------------- ---------------------------------------------------------------------------- --- ---------------------------------------------------------------------------------------- --------------------------------------------------- ---------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Expressions-and-operators "Previous section in reading order")\]   \[[\>](#Important-note-about-assignment "Next section in reading order")\]       \[[\<\<](#Expressions-and-operators "Beginning of this chapter or previous chapter")\]   \[[Up](#Expressions-and-operators "Up section")\]   \[[\>\>](#Parameters "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  -------------------------------------------------------------------------- ---------------------------------------------------------------------------- --- ---------------------------------------------------------------------------------------- --------------------------------------------------- ---------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#The-assignment-operator-1}

7.1 The assignment operator {#the-assignment-operator .section}
---------------------------

[]{#index-Assignment-operator} []{#index-Operator_002c-assignment}
[]{#index-_003d-assignment-operator}

No operator such as addition (`+`) or multiplication (`*`) would be
useful without another operator that attaches the values they produce to
variables. Thus, the assignment operator `=` is perhaps the most
important mathematical operator.

We have seen the assignment operator already in our code examples. Here
is an example to refresh your memory:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | int gnu_count, gnat_count, critte |
|                                   | r_count;                          |
|                                   |                                   |
|                                   | gnu_count = 45;                   |
|                                   | gnat_count = 5678;                |
|                                   |                                   |
|                                   | critter_count = gnu_count + gnat_ |
|                                   | count;                            |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

The assignment operator takes the value of whatever is on the right-hand
side of the `=` symbol and puts it into the variable on the left-hand
side. For example, the code sample above assigns the value 45 to the
variable `gnu_count`.

[]{#index-Lvalues}

Something that can be assigned *to* is called an *lvalue*, ("l" for
"left", because it can appear on the *left* side of an assignment). You
will sometimes see the word 'lvalue' in error messages from the
compiler. For example, try to compile a program containing the following
code:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | 5 = 2 + 3;                        |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

You will receive an error such as the following:

error\--\>

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | bad_example.c:3: invalid lvalue i |
|                                   | n assignment                      |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

You can't assign a value to 5; it has its own value already! In other
words, 5 is not an lvalue.

  --------------------------------------------------------------------------- ---- --
  [7.1.1 Important note about assignment](#Important-note-about-assignment)        
  --------------------------------------------------------------------------- ---- --

------------------------------------------------------------------------

[]{#Important-note-about-assignment}

  ------------------------------------------------------------------------ ------------------------------------------------------------------- --- ---------------------------------------------------------------------------------------- ------------------------------------------------- ---------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#The-assignment-operator "Previous section in reading order")\]   \[[\>](#Expressions-and-values "Next section in reading order")\]       \[[\<\<](#Expressions-and-operators "Beginning of this chapter or previous chapter")\]   \[[Up](#The-assignment-operator "Up section")\]   \[[\>\>](#Parameters "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ------------------------------------------------------------------------ ------------------------------------------------------------------- --- ---------------------------------------------------------------------------------------- ------------------------------------------------- ---------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Important-note-about-assignment-1}

### 7.1.1 Important note about assignment {#important-note-about-assignment .subsection}

[]{#index-Assignment-operator_002c-confused-with-equality-operator}
[]{#index-Equality-operator_002c-confused-with-assignment-operator}
[]{#index-_003d-confused-with-_003d_003d}
[]{#index-_003d_003d-confused-with-_003d}

Many people confuse the assignment operator (`=`) with the equality
operator (`==`), and this is a major source of bugs in C programs.
Because of early arithmetic training, people tend to think of `=` as
indicating equality, but in C it means "takes on the value produced by",
and it should always be read that way. By way of contrast, `==` is an
equality test operator and should always be read "is tested for equality
with". (See section [Comparisons and logic](#Comparisons-and-logic), for
more information on the `==` operator.)

------------------------------------------------------------------------

[]{#Expressions-and-values}

  -------------------------------------------------------------------------------- -------------------------------------------------------- --- ---------------------------------------------------------------------------------------- --------------------------------------------------- ---------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Important-note-about-assignment "Previous section in reading order")\]   \[[\>](#Expressions "Next section in reading order")\]       \[[\<\<](#Expressions-and-operators "Beginning of this chapter or previous chapter")\]   \[[Up](#Expressions-and-operators "Up section")\]   \[[\>\>](#Parameters "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  -------------------------------------------------------------------------------- -------------------------------------------------------- --- ---------------------------------------------------------------------------------------- --------------------------------------------------- ---------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Expressions-and-values-1}

7.2 Expressions and values {#expressions-and-values .section}
--------------------------

The most common operators in any language are basic arithmetic
operators. In C, these include the following:

[]{#index-Arithmetic-operators} []{#index-Operators_002c-arithmetic}

[]{#index-_002b-unary-plus-operator}

`+`

unary plus, example: `+5`

[]{#index-_002d-unary-minus-operator}

`-`

unary minus, example: `-5`

[]{#index-_002b-addition-operator}

`+`

addition, example: `2 + 2`

[]{#index-_002d-subtraction-operator}

`-`

subtraction, example: `14 - 7`

[]{#index-_002a-multiplication-operator}

`*`

multiplication, example: `3 * 3`

[]{#index-_002f-division-operator}

`/`

floating point division, example: `10.195 / 2.4`

[]{#index-_002f-integer-division-operator} []{#index-_002f-div-operator}

`/`

integer division *div*, example: `5 / 2`

[]{#index-_0025-integer-remainder-operator}
[]{#index-_0025-mod-operator} []{#index-_0025-modulo-operator}

`%`

integer remainder *mod*, example: `24 % 7`

------------------------------------------------------------------------

[]{#Expressions}

  ----------------------------------------------------------------------- --------------------------------------------------------------------- --- ---------------------------------------------------------------------------------------- --------------------------------------------------- ---------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Expressions-and-values "Previous section in reading order")\]   \[[\>](#Parentheses-and-Priority "Next section in reading order")\]       \[[\<\<](#Expressions-and-operators "Beginning of this chapter or previous chapter")\]   \[[Up](#Expressions-and-operators "Up section")\]   \[[\>\>](#Parameters "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ----------------------------------------------------------------------- --------------------------------------------------------------------- --- ---------------------------------------------------------------------------------------- --------------------------------------------------- ---------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Expressions-1}

7.3 Expressions {#expressions .section}
---------------

[]{#index-Expressions}

An *expression* is simply a string of operators, variables, numbers, or
some combination, that can be parsed by the compiler. All of the
following are expressions:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | 19                                |
|                                   |                                   |
|                                   | 1 + 2 + 3                         |
|                                   |                                   |
|                                   | my_var                            |
|                                   |                                   |
|                                   | my_var + some_function()          |
|                                   |                                   |
|                                   | (my_var + 4 * (some_function() +  |
|                                   | 2))                               |
|                                   |                                   |
|                                   | 32 * circumference / 3.14         |
|                                   |                                   |
|                                   | day_of_month % 7                  |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

Here is an example of some arithmetic expressions in C:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | #include <stdio.h>                |
|                                   |                                   |
|                                   | int main ()                       |
|                                   | {                                 |
|                                   |   int my_int;                     |
|                                   |                                   |
|                                   |   printf ("Arithmetic Operators:\ |
|                                   | n\n");                            |
|                                   |                                   |
|                                   |   my_int = 6;                     |
|                                   |   printf ("my_int = %d, -my_int = |
|                                   |  %d\n", my_int, -my_int);         |
|                                   |                                   |
|                                   |   printf ("int 1 + 2 = %d\n", 1 + |
|                                   |  2);                              |
|                                   |   printf ("int 5 - 1 = %d\n", 5 - |
|                                   |  1);                              |
|                                   |   printf ("int 5 * 2 = %d\n", 5 * |
|                                   |  2);                              |
|                                   |                                   |
|                                   |   printf ("\n9 div 4 = 2 remainde |
|                                   | r 1:\n");                         |
|                                   |   printf ("int 9 / 4 = %d\n", 9 / |
|                                   |  4);                              |
|                                   |   printf ("int 9 % 4 = %d\n", 9 % |
|                                   |  4);                              |
|                                   |                                   |
|                                   |   printf ("double 9 / 4 = %f\n",  |
|                                   | 9.0 / 4.0);                       |
|                                   |                                   |
|                                   |   return 0;                       |
|                                   | }                                 |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

The program above produces the output below:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | Arithmetic Operators:             |
|                                   |                                   |
|                                   | my_int = 6, -my_int = -6          |
|                                   | int 1 + 2 = 3                     |
|                                   | int 5 - 1 = 4                     |
|                                   | int 5 * 2 = 10                    |
|                                   |                                   |
|                                   | 9 div 4 = 2 remainder 1:          |
|                                   | int 9 / 4 = 2                     |
|                                   | int 9 % 4 = 1                     |
|                                   | double 9 / 4 = 2.250000           |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

------------------------------------------------------------------------

[]{#Parentheses-and-Priority}

  ------------------------------------------------------------ ---------------------------------------------------------------------- --- ---------------------------------------------------------------------------------------- --------------------------------------------------- ---------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Expressions "Previous section in reading order")\]   \[[\>](#Unary-Operator-Precedence "Next section in reading order")\]       \[[\<\<](#Expressions-and-operators "Beginning of this chapter or previous chapter")\]   \[[Up](#Expressions-and-operators "Up section")\]   \[[\>\>](#Parameters "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ------------------------------------------------------------ ---------------------------------------------------------------------- --- ---------------------------------------------------------------------------------------- --------------------------------------------------- ---------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Parentheses-and-Priority-1}

7.4 Parentheses and Priority {#parentheses-and-priority .section}
----------------------------

[]{#index-Parentheses} []{#index-Order-of-operations}
[]{#index-Operations_002c-order-of} []{#index-Operator-precedence}
[]{#index-Precedence_002c-operator}

Just as in algebra, the C compiler considers operators to have certain
priorities, and *evaluates*, or parses, some operators before others.
The order in which operators are evaluated is called *operator
precedence* or the *order of operations*. You can think of some
operators as "stronger" than others. The "stronger" ones will always be
evaluated first; otherwise, expressions are evaluated from left to
right.

For example, since the multiplication operator `*` has a higher priority
than the addition operator `+` and is therefore evaluated first, the
following expression will always evaluate to 10 rather than 18:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | 4 + 2 * 3                         |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

However, as in algebra, you can use parentheses to force the program to
evaluate the expression to 18:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | (4 + 2) * 3                       |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

The parentheses force the expression `(4 + 2)` to be evaluated first.
Placing parentheses around `2 * 3`, however, would have no effect.

Parentheses are classed as operators by the compiler; they have a value,
in the sense that they assume the value of whatever is inside them. For
example, the value of `(5 + 5)` is 10.

------------------------------------------------------------------------

[]{#Unary-Operator-Precedence}

  ------------------------------------------------------------------------- ----------------------------------------------------------------------------------------------- --- ---------------------------------------------------------------------------------------- --------------------------------------------------- ---------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Parentheses-and-Priority "Previous section in reading order")\]   \[[\>](#Special-Assignment-Operators-_002b_002b-_002d_002d "Next section in reading order")\]       \[[\<\<](#Expressions-and-operators "Beginning of this chapter or previous chapter")\]   \[[Up](#Expressions-and-operators "Up section")\]   \[[\>\>](#Parameters "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ------------------------------------------------------------------------- ----------------------------------------------------------------------------------------------- --- ---------------------------------------------------------------------------------------- --------------------------------------------------- ---------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Unary-Operator-Precedence-1}

7.5 Unary Operator Precedence {#unary-operator-precedence .section}
-----------------------------

[]{#index-Unary-operators}
[]{#index-Unary-operators_002c-order-of-operation}
[]{#index-Order-of-operation_002c-unary-operators}

Unary operators are operators that have only a single operand --- that
is, they operate on only one object. The following are (or can be) all
unary operators:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | ++  --  +  -                      |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

The order of evaluation of unary operators is from right to left, so an
expression like:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | *ptr++;                           |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

would perform the `++` before the `*`. (The `++` operator will be
introduced in the next section, and the `*` operator will be introduced
in the next chapter. See section [Pointers](#Pointers).)

------------------------------------------------------------------------

[]{#Special-Assignment-Operators-_002b_002b-_002d_002d}

  -------------------------------------------------------------------------- --------------------------------------------------------------------- --- ---------------------------------------------------------------------------------------- --------------------------------------------------- ---------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Unary-Operator-Precedence "Previous section in reading order")\]   \[[\>](#More-Special-Assignments "Next section in reading order")\]       \[[\<\<](#Expressions-and-operators "Beginning of this chapter or previous chapter")\]   \[[Up](#Expressions-and-operators "Up section")\]   \[[\>\>](#Parameters "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  -------------------------------------------------------------------------- --------------------------------------------------------------------- --- ---------------------------------------------------------------------------------------- --------------------------------------------------- ---------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Special-Assignment-Operators-_002b_002b-and-_002d_002d}

7.6 Special Assignment Operators `++` and `--` {#special-assignment-operators-and--- .section}
----------------------------------------------

[]{#index-_002b_002b-increment-operator}
[]{#index-_002d_002d-decrement-operator}
[]{#index-Special-assignment-operators}
[]{#index-Operators_002c-special-assignment}

C has some special operators that can simplify code. The simplest of
these are the increment and decrement operators:

 `++`

:   increment: add one to

 `--`

:   decrement: subtract one from

You can use these with any integer or floating point variable (or a
character in some cases, carefully). They simply add or subtract 1 from
a variable. The following three statements are equivalent:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | variable = variable + 1;          |
|                                   | variable++;                       |
|                                   | ++variable;                       |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

So are these three:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | variable = variable - 1;          |
|                                   | variable--;                       |
|                                   | --variable;                       |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

Notice that the `++` and `--` operators can be placed before or after
the variable. In the cases above, the two forms work identically, but
there is actually a subtle difference. (See section [Postfix and prefix
`++` and `--`](#Postfix-and-prefix-_002b_002b-and-_002d_002d), for more
information.)

------------------------------------------------------------------------

[]{#More-Special-Assignments}

  --------------------------------------------------------------------------------------------------- ------------------------------------------------------------------ --- ---------------------------------------------------------------------------------------- --------------------------------------------------- ---------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Special-Assignment-Operators-_002b_002b-_002d_002d "Previous section in reading order")\]   \[[\>](#Comparisons-and-logic "Next section in reading order")\]       \[[\<\<](#Expressions-and-operators "Beginning of this chapter or previous chapter")\]   \[[Up](#Expressions-and-operators "Up section")\]   \[[\>\>](#Parameters "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  --------------------------------------------------------------------------------------------------- ------------------------------------------------------------------ --- ---------------------------------------------------------------------------------------- --------------------------------------------------- ---------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#More-Special-Assignments-1}

7.7 More Special Assignments {#more-special-assignments .section}
----------------------------

[]{#index-Special-assignment-operators-1}
[]{#index-Operators_002c-special-assignment-1}

Like `++` and `--`, the following operators are short ways of writing
longer expressions. Consider the following statement:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | variable = variable + 23;         |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

[]{#index-_002b_003d-operator}

In C, this would be a long-winded way of adding 23 to `variable`. It
could be done more simply with the general increment operator `+=`, as
in this example:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | variable += 23;                   |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

This performs exactly the same operation. Similarly, the following two
statements are equivalent:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | variable1 = variable1 + variable2 |
|                                   | ;                                 |
|                                   | variable1 += variable2;           |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

There are a handful of these operators. For example, one for
subtraction:

[]{#index-_002d_003d-operator}

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | variable = variable - 42;         |
|                                   | variable -= 42;                   |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

More surprisingly, perhaps, there is one for multiplication:

[]{#index-_002a_003d-operator}

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | variable = variable * 2;          |
|                                   | variable *= 2;                    |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

The main arithmetic operators all follow this pattern:

[]{#index-Arithmetic-operators-1} []{#index-Operators_002c-arithmetic-1}

 `+=`

:   addition assignment operator

 `-=`

:   subtraction assignment operator

 `*=`

:   multiplication assignment operator

 `/=`

:   division assignment operator (floating point and integers)

 `%=`

:   remainder assignment operator (integers only)

There are more exotic kinds too, used for machine-level operations,
which we will ignore for the moment. (See section [Advanced
operators](#Advanced-operators), if you want to know more.)

Here is a short program that demonstrates these special assignment
operators:

[]{#index-Special-assignment-operators_002c-example}

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | #include <stdio.h>                |
|                                   |                                   |
|                                   | int main()                        |
|                                   | {                                 |
|                                   |   int my_int;                     |
|                                   |                                   |
|                                   |   printf ("Assignment Operators:\ |
|                                   | n\n");                            |
|                                   |                                   |
|                                   |   my_int = 10;                    |
|                                   |         /* Assignment */          |
|                                   |   printf ("my_int = 10 : %d\n",my |
|                                   | _int);                            |
|                                   |                                   |
|                                   |   my_int++;                       |
|                                   |         /* my_int = my_int + 1 */ |
|                                   |   printf ("my_int++    : %d\n",my |
|                                   | _int);                            |
|                                   |                                   |
|                                   |   my_int += 5;                    |
|                                   |         /* my_int = my_int + 5 */ |
|                                   |   printf ("my_int += 5 : %d\n",my |
|                                   | _int);                            |
|                                   |                                   |
|                                   |   my_int--;                       |
|                                   |         /* my_int = my_int = 1 */ |
|                                   |   printf ("my_int--    : %d\n",my |
|                                   | _int);                            |
|                                   |                                   |
|                                   |   my_int -= 2;                    |
|                                   |         /* my_int = my_int - 2 */ |
|                                   |   printf ("my_int -= 2 : %d\n",my |
|                                   | _int);                            |
|                                   |                                   |
|                                   |   my_int *= 5;                    |
|                                   |         /* my_int = my_int * 5 */ |
|                                   |   printf ("my_int *= 5 : %d\n",my |
|                                   | _int);                            |
|                                   |                                   |
|                                   |   my_int /= 2;                    |
|                                   |         /* my_int = my_int / 2 */ |
|                                   |   printf ("my_int /= 2 : %d\n",my |
|                                   | _int);                            |
|                                   |                                   |
|                                   |   my_int %= 3;                    |
|                                   |         /* my_int = my_int % 3 */ |
|                                   |   printf ("my_int %%= 3 : %d\n",m |
|                                   | y_int);                           |
|                                   |                                   |
|                                   |   return 0;                       |
|                                   | }                                 |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

The program above produces the output below:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | Assignment Operators:             |
|                                   |                                   |
|                                   | my_int = 10 : 10                  |
|                                   | my_int++    : 11                  |
|                                   | my_int += 5 : 16                  |
|                                   | my_int--    : 15                  |
|                                   | my_int -= 2 : 13                  |
|                                   | my_int *= 5 : 65                  |
|                                   | my_int /= 2 : 32                  |
|                                   | my_int %= 3 : 2                   |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

The second to last line of output is

+-----------------------------------+-----------------------------------+
|                                   | ``` {.example}                    |
|                                   | my_int /= 2 : 32                  |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

In this example, 65 divided by 2 using the `/=` operator results in 32,
not 32.5. This is because both operands, 65 and 2, are integers, type
`int`, and when `/=` operates on two integers, it produces an integer
result. This example only uses integer values, since that is how the
numbers are declared. To get the fractional answer, you would have had
to declare the three numbers involved as floats.

The last line of output is

+-----------------------------------+-----------------------------------+
|                                   | ``` {.example}                    |
|                                   | my_int %= 3 : 2                   |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

This is because 32 divided by 3 is 10 with a remainder of 2.

------------------------------------------------------------------------

[]{#Comparisons-and-logic}

  ------------------------------------------------------------------------- -------------------------------------------------------------- --- ---------------------------------------------------------------------------------------- --------------------------------------------------- ---------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#More-Special-Assignments "Previous section in reading order")\]   \[[\>](#Logical-operators "Next section in reading order")\]       \[[\<\<](#Expressions-and-operators "Beginning of this chapter or previous chapter")\]   \[[Up](#Expressions-and-operators "Up section")\]   \[[\>\>](#Parameters "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ------------------------------------------------------------------------- -------------------------------------------------------------- --- ---------------------------------------------------------------------------------------- --------------------------------------------------- ---------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Comparisons-and-logic-1}

7.8 Comparisons and logic {#comparisons-and-logic .section}
-------------------------

[]{#index-Comparison-operators-1} []{#index-Operators_002c-comparison-1}

Comparison operators tell you how numerical values relate to one
another, such as whether they are equal to one another, or whether one
is greater than the other. Comparison operators are used in logical
tests, such as `if` statements. (See section [Decisions](#Decisions).)

[]{#index-True-Boolean-value} []{#index-False-Boolean-value}

The results of a logical comparison are always either true (1) or false
(0). In computer programming jargon, true and false are the two *Boolean
values*. Note that, unlike real life, there are no "gray areas" in C;
just as in Aristotelian logic, a comparison operator will never produce
a value other than true or false.

Six operators in C are used to make logical comparisons:

 `==`

:   is equal to

 `!=`

:   is not equal to

 `>`

:   is greater than

 `<`

:   is less than

 `>=`

:   is greater than or equal to

 `<=`

:   is less than or equal to

[]{#index-Assignment-operator_002c-confused-with-equality-operator-1}
[]{#index-Equality-operator_002c-confused-with-assignment-operator-1}
[]{#index-_003d-confused-with-_003d_003d-1}
[]{#index-_003d_003d-confused-with-_003d-1}

**Important:** Remember that many people confuse the equality operator
(`==`) with the assignment operator (`=`), and this is a major source of
bugs in C programs. (See section [Expressions and
values](#Expressions-and-values), for more information on the
distinction between the `==` and `=` operators.)

[]{#index-Boolean-values-1} []{#index-Values_002c-Boolean-1}
[]{#index-TRUE-macro} []{#index-FALSE-macro}

The operators above result in values, much as the addition operator `+`
does. They produce Boolean values: true and false only. Actually, C uses
1 for "true" and 0 for "false" when evaluating expressions containing
comparison operators, but it is easy to define the strings 'TRUE' and
'FALSE' as macros, and they may well already be defined in a library
file you are using. (See section [Preprocessor
directives](#Preprocessor-directives), for information on defining
macros.)

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | #define TRUE  1                   |
|                                   | #define FALSE 0                   |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

Note that although any non-zero value in C is treated as true, you do
not need to worry about a comparison evaluating to anything other than 1
or 0. Try the following short program:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | #include <stdio.h>                |
|                                   |                                   |
|                                   | int main ()                       |
|                                   | {                                 |
|                                   |   int truth, falsehood;           |
|                                   |                                   |
|                                   |   truth = (2 + 2 == 4);           |
|                                   |   falsehood = (2 + 2 == 5);       |
|                                   |                                   |
|                                   |   printf("truth is %d\n", truth); |
|                                   |   printf("falsehood is %d\n", fal |
|                                   | sehood);                          |
|                                   |                                   |
|                                   |   exit (0);                       |
|                                   | }                                 |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

You should receive the following result:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | truth is 1                        |
|                                   | falsehood is 0                    |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

------------------------------------------------------------------------

[]{#Logical-operators}

  ---------------------------------------------------------------------- --------------------------------------------------------- --- ---------------------------------------------------------------------------------------- --------------------------------------------------- ---------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Comparisons-and-logic "Previous section in reading order")\]   \[[\>](#Inclusive-OR "Next section in reading order")\]       \[[\<\<](#Expressions-and-operators "Beginning of this chapter or previous chapter")\]   \[[Up](#Expressions-and-operators "Up section")\]   \[[\>\>](#Parameters "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ---------------------------------------------------------------------- --------------------------------------------------------- --- ---------------------------------------------------------------------------------------- --------------------------------------------------- ---------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Logical-operators-1}

7.9 Logical operators {#logical-operators .section}
---------------------

[]{#index-Logical-operators} []{#index-Operators_002c-logical}
[]{#index-Comparison-operators-2} []{#index-Operators_002c-comparison-2}

Comparisons are often made in pairs or groups. For example, you might
want to ask a question such as, "Is variable `a` greater than variable
`b` *and* is variable `b` greater than variable `c`?" The word "and" in
the question above is represented in C by the *logical operator* (an
"operator on Boolean values") `&&`, and the whole comparison above might
be represented by the following expression:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | (a > b) && (b > c)                |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

The main logical operators in C are as follows:

 `&&`

:   logical AND

 `||`

:   logical Inclusive OR (See section [Inclusive OR](#Inclusive-OR).)

 `!`

:   logical NOT

Here is another example. The question, "Is the variable `a` greater than
the variable `b`, *or* is the variable `a` *not* greater than the
variable `c`?" might be written:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | (a > b) || !(a > c)               |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

  ------------------------------------- ---- --
  [7.9.1 Inclusive OR](#Inclusive-OR)        
  ------------------------------------- ---- --

------------------------------------------------------------------------

[]{#Inclusive-OR}

  ------------------------------------------------------------------ -------------------------------------------------------------------- --- ---------------------------------------------------------------------------------------- ------------------------------------------- ---------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Logical-operators "Previous section in reading order")\]   \[[\>](#Questions-for-Chapter-7 "Next section in reading order")\]       \[[\<\<](#Expressions-and-operators "Beginning of this chapter or previous chapter")\]   \[[Up](#Logical-operators "Up section")\]   \[[\>\>](#Parameters "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ------------------------------------------------------------------ -------------------------------------------------------------------- --- ---------------------------------------------------------------------------------------- ------------------------------------------- ---------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Inclusive-OR-1}

### 7.9.1 Inclusive OR {#inclusive-or .subsection}

[]{#index-Inclusive-OR} []{#index-OR_002c-inclusive}
[]{#index-To-be-or-not-to-be} []{#index-Shakespeare}

**Note well!** Shakespeare might have been disappointed that, *whatever*
the value of a variable `to_be`, the result of

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | to_be || !to_be                   |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

(i.e. "To be, or not to be?") is always 1, or true. This is because one
or the other of `to_be` or `!to_be` must always be true, and as long as
one side of an OR `||` expression is true, the whole expression is true.

------------------------------------------------------------------------

[]{#Questions-for-Chapter-7}

  ------------------------------------------------------------- ------------------------------------------------------- --- ---------------------------------------------------------------------------------------- --------------------------------------------------- ---------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Inclusive-OR "Previous section in reading order")\]   \[[\>](#Parameters "Next section in reading order")\]       \[[\<\<](#Expressions-and-operators "Beginning of this chapter or previous chapter")\]   \[[Up](#Expressions-and-operators "Up section")\]   \[[\>\>](#Parameters "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ------------------------------------------------------------- ------------------------------------------------------- --- ---------------------------------------------------------------------------------------- --------------------------------------------------- ---------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Questions-for-Chapter-7-1}

7.10 Questions for Chapter 7 {#questions-for-chapter-7 .section}
----------------------------

1.  What is an operand?
2.  Write a short statement that assigns the remainder of 5 divided by 2
    to a variable called `remainder` and prints it out.
3.  Write a statement that subtracts -5 from 10.

------------------------------------------------------------------------

[]{#Parameters}

  ------------------------------------------------------------------------ ------------------------------------------------------------------------------ --- ---------------------------------------------------------------------------------------- ----------------------------- -------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Questions-for-Chapter-7 "Previous section in reading order")\]   \[[\>](#Parameters-in-function-prototypes "Next section in reading order")\]       \[[\<\<](#Expressions-and-operators "Beginning of this chapter or previous chapter")\]   \[[Up](#Top "Up section")\]   \[[\>\>](#Pointers "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ------------------------------------------------------------------------ ------------------------------------------------------------------------------ --- ---------------------------------------------------------------------------------------- ----------------------------- -------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Parameters-1}

8. Parameters {#parameters .chapter}
=============

*Ways in and out of functions.*

[]{#index-Parameters-2} []{#index-Passing-information-with-parameters}
[]{#index-Passing-parameters}

*Parameters* are the main way in C to transfer, or *pass*, information
from function to function. Consider a call to our old friend
`calculate_bill`:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | total = calculate_bill (20, 35, 2 |
|                                   | 8);                               |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

We are passing 20, 35, and 28 as parameters to `calculate_bill` so that
it can add them together and return the sum.

When you pass information to a function with parameters, in some cases
the information can go only one way, and the function returns only a
single value (such as `total` in the above snippet of code). In other
cases, the information in the parameters can go both ways; that is, the
function called can alter the information in the parameters it is
passed.

[]{#index-Passing-parameters-by-value}
[]{#index-Passing-parameters-by-reference}
[]{#index-Value_002c-passing-parameters-by}
[]{#index-Reference_002c-passing-parameters-by}

The former technique (passing information only one way) is called
*passing parameters by value* in computer programming jargon, and the
latter technique (passing information both ways) is referred to as
*passing parameters by reference*.

For our purposes, at the moment, there are two (mutually exclusive)
kinds of parameters:

-   []{#index-Value-parameters} []{#index-Parameters_002c-value}
-   *Value parameters* are the kind that pass information one-way. They
    are so-called because the function to which they are passed receives
    only a copy of their values, and they cannot be altered as variable
    parameters can. The phrase "passing by value" mentioned above is
    another way to talk about passing "value parameters".
    []{#index-Variable-parameters} []{#index-Parameters_002c-variable}
-   *Variable parameters* are the kind that pass information back to the
    calling function. They are so called because the function to which
    they are passed can alter them, just as it can alter an ordinary
    variable. The phrase "passing by reference" mentioned above is
    another way to talk about passing "variable parameters".

Consider a slightly-expanded version of `calculate_bill`:

[]{#index-Value-parameters_002c-example-of}
[]{#index-Parameters_002c-value_002c-example-of}

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | #include <stdio.h>                |
|                                   |                                   |
|                                   | int main (void);                  |
|                                   | int calculate_bill (int, int, int |
|                                   | );                                |
|                                   |                                   |
|                                   | int main()                        |
|                                   | {                                 |
|                                   |   int bill;                       |
|                                   |   int fred = 25;                  |
|                                   |   int frank = 32;                 |
|                                   |   int franny = 27;                |
|                                   |                                   |
|                                   |   bill = calculate_bill (fred, fr |
|                                   | ank, franny);                     |
|                                   |   printf("The total bill comes to |
|                                   |  $%d.00.\n", bill);               |
|                                   |                                   |
|                                   |   exit (0);                       |
|                                   | }                                 |
|                                   |                                   |
|                                   | int calculate_bill (int diner1, i |
|                                   | nt diner2, int diner3)            |
|                                   | {                                 |
|                                   |   int total;                      |
|                                   |                                   |
|                                   |   total = diner1 + diner2 + diner |
|                                   | 3;                                |
|                                   |   return total;                   |
|                                   | }                                 |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

Note that all of the parameters in this example are value parameters:
the information flows only one way. The values are passed to the
function `calculate_bill`. The original values are not changed. In
slightly different jargon, we are "passing the parameters by value
only". We are *not* passing them "by reference"; they are *not*
"variable parameters".

[]{#index-Parameters_002c-declaring} []{#index-Declaring-parameters}

All parameters must have their types declared. This is true whether they
are value parameters or variable parameters. In the function
`calculate_bill` above, the value parameters `diner1`, `diner2`, and
`diner3` are all declared to be of type `int`.

  ----------------------------------------------------------------------------------------- ---- --
  [8.1 Parameters in function prototypes](#Parameters-in-function-prototypes)                    
  [8.2 Value Parameters](#Value-parameters)                                                      
  [8.3 Actual parameters and formal parameters](#Actual-parameters-and-formal-parameters)        
  [8.4 Variadic functions](#Variadic-functions)                                                  
  [8.5 Questions for Chapter 8](#Questions-for-Chapter-8)                                        
  ----------------------------------------------------------------------------------------- ---- --

------------------------------------------------------------------------

[]{#Parameters-in-function-prototypes}

  ----------------------------------------------------------- ------------------------------------------------------------- --- ------------------------------------------------------------------------- ------------------------------------ -------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Parameters "Previous section in reading order")\]   \[[\>](#Value-parameters "Next section in reading order")\]       \[[\<\<](#Parameters "Beginning of this chapter or previous chapter")\]   \[[Up](#Parameters "Up section")\]   \[[\>\>](#Pointers "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ----------------------------------------------------------- ------------------------------------------------------------- --- ------------------------------------------------------------------------- ------------------------------------ -------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Parameters-in-function-prototypes-1}

8.1 Parameters in function prototypes {#parameters-in-function-prototypes .section}
-------------------------------------

[]{#index-Parameters-in-function-prototypes}
[]{#index-Function-prototypes_002c-parameters-in}
[]{#index-Prototypes_002c-function_002c-parameters-in}

Note that in the function prototype for `calculate_bill`, the parameter
names were completely omitted. This is perfectly acceptable in ANSI C,
although it might be confusing to someone trying to understand your code
by reading the function prototypes, which can be in a separate file from
the functions themselves. For instance, in the code example above, the
function prototype for `calculate_bill` looks like this:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | int calculate_bill (int, int, int |
|                                   | );                                |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

You may include parameter names in function prototypes if you wish; this
is usually a good idea when the function prototype is significantly
separated from the function definition, such as when the prototype is in
a header file or at the top of a long file of function definitions. For
example, we could have written the prototype for `calculate_bill` thus:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | int calculate_bill (int diner1, i |
|                                   | nt diner2, int diner3);           |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

Parameter names in a function prototype do not need to match the names
in the function's definition; only their types need to match. For
example, we can also write the function prototype above in this way:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | int calculate_bill (int guest1, i |
|                                   | nt guest2, int guest3);           |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

[]{#index-International-Obfuscated-C-Code-Contest}
[]{#index-Obfuscated-C-Code-Contest_002c-International}

As usual, it is a good idea to use mnemonic names for the parameters in
a function prototype, as in the last two examples. [(1)](#FOOT1){#DOCF1}
Thus, the function prototype below is not as helpful to the person
reading your code as the last two examples are; it might just as well
have been written without variable names at all:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | int calculate_bill (int variable1 |
|                                   | , int variable2, int variable3);  |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

  ----------------------------------------------------------------------------------------- ---- --
  [8.2 Value Parameters](#Value-parameters)                                                      
  [8.3 Actual parameters and formal parameters](#Actual-parameters-and-formal-parameters)        
  [8.4 Variadic functions](#Variadic-functions)                                                  
  [8.5 Questions for Chapter 8](#Questions-for-Chapter-8)                                        
  ----------------------------------------------------------------------------------------- ---- --

------------------------------------------------------------------------

[]{#Value-parameters}

  ---------------------------------------------------------------------------------- ------------------------------------------------------------------------------------ --- ------------------------------------------------------------------------- ------------------------------------ -------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Parameters-in-function-prototypes "Previous section in reading order")\]   \[[\>](#Actual-parameters-and-formal-parameters "Next section in reading order")\]       \[[\<\<](#Parameters "Beginning of this chapter or previous chapter")\]   \[[Up](#Parameters "Up section")\]   \[[\>\>](#Pointers "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ---------------------------------------------------------------------------------- ------------------------------------------------------------------------------------ --- ------------------------------------------------------------------------- ------------------------------------ -------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Value-Parameters}

8.2 Value Parameters {#value-parameters .section}
--------------------

[]{#index-Value-parameters-1} []{#index-Parameters_002c-value-1}
[]{#index-Passing-parameters-by-value-1}

When you are passing data to a function by value, the parameters in the
function you are passing the data *to* contain copies of the data in the
parameters you are passing the data *with*. Let us modify the function
`main` from the last example slightly:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | int main()                        |
|                                   | {                                 |
|                                   |   int bill;                       |
|                                   |   int fred = 25;                  |
|                                   |   int frank = 32;                 |
|                                   |   int franny = 27;                |
|                                   |                                   |
|                                   |   bill = calculate_bill (fred, fr |
|                                   | ank, franny);                     |
|                                   |                                   |
|                                   |   fred = 20000;                   |
|                                   |   frank = 50000;                  |
|                                   |   franny = 20000;                 |
|                                   |                                   |
|                                   |   printf("The total bill comes to |
|                                   |  $%d.00.\n", bill);               |
|                                   |                                   |
|                                   |   exit (0);                       |
|                                   | }                                 |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

As far as the function `calculate_bill` is concerned, `fred`, `frank`,
and `franny` are still 25, 32, and 27 respectively. Changing their
values to extortionate sums after passing them to `calculate_bill` does
nothing; `calculate_bill` has already created local copies of the
parameters, called `diner1`, `diner2`, and `diner3` containing the
earlier values.

**Important:** Even if we named the parameters in the definition of
`calculate_bill` to match the parameters of the function call in `main`
(see example below), the result would be the same: `main` would print
out '\$84.00', not '\$90000.00'. When passing data by value, the
parameters in the function call and the parameters in the function
definition (which are only copies of the parameters in the function
call) are completely separate.

Just to remind you, this is the `calculate_bill` function:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | int calculate_bill (int fred, int |
|                                   |  frank, int franny)               |
|                                   | {                                 |
|                                   |   int total;                      |
|                                   |                                   |
|                                   |   total = fred + frank + franny;  |
|                                   |   return total;                   |
|                                   | }                                 |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

------------------------------------------------------------------------

[]{#Actual-parameters-and-formal-parameters}

  ----------------------------------------------------------------- --------------------------------------------------------------- --- ------------------------------------------------------------------------- ------------------------------------ -------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Value-parameters "Previous section in reading order")\]   \[[\>](#Variadic-functions "Next section in reading order")\]       \[[\<\<](#Parameters "Beginning of this chapter or previous chapter")\]   \[[Up](#Parameters "Up section")\]   \[[\>\>](#Pointers "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ----------------------------------------------------------------- --------------------------------------------------------------- --- ------------------------------------------------------------------------- ------------------------------------ -------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Actual-parameters-and-formal-parameters-1}

8.3 Actual parameters and formal parameters {#actual-parameters-and-formal-parameters .section}
-------------------------------------------

[]{#index-Actual-parameters} []{#index-Formal-parameters}
[]{#index-Parameters_002c-actual} []{#index-Parameters_002c-formal}

There are two other categories that you should know about that are also
referred to as "parameters". They are called "parameters" because they
define information that is passed to a function.

-   *Actual parameters* are parameters as they appear in function calls.
-   *Formal parameters* are parameters as they appear in function
    declarations.

A parameter cannot be both a formal and an actual parameter, but both
formal parameters and actual parameters can be either value parameters
or variable parameters.

Let's look at `calculate_bill` again:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | #include <stdio.h>                |
|                                   |                                   |
|                                   | int main (void);                  |
|                                   | int calculate_bill (int, int, int |
|                                   | );                                |
|                                   |                                   |
|                                   | int main()                        |
|                                   | {                                 |
|                                   |   int bill;                       |
|                                   |   int fred = 25;                  |
|                                   |   int frank = 32;                 |
|                                   |   int franny = 27;                |
|                                   |                                   |
|                                   |   bill = calculate_bill (fred, fr |
|                                   | ank, franny);                     |
|                                   |   printf("The total bill comes to |
|                                   |  $%d.00.\n", bill);               |
|                                   |                                   |
|                                   |   exit (0);                       |
|                                   | }                                 |
|                                   |                                   |
|                                   | int calculate_bill (int diner1, i |
|                                   | nt diner2, int diner3)            |
|                                   | {                                 |
|                                   |   int total;                      |
|                                   |                                   |
|                                   |   total = diner1 + diner2 + diner |
|                                   | 3;                                |
|                                   |   return total;                   |
|                                   | }                                 |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

In the function `main` in the example above, `fred`, `frank`, and
`franny` are all actual parameters when used to call `calculate_bill`.
On the other hand, the corresponding variables in `calculate_bill`
(namely `diner1`, `diner2` and `diner3`, respectively) are all formal
parameters because they appear in a function definition.

Although formal parameters are always variables (which does not mean
that they are always variable parameters), actual parameters do not have
to be variables. You can use numbers, expressions, or even function
calls as actual parameters. Here are some examples of valid actual
parameters in the function call to `calculate_bill`:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | bill = calculate_bill (25, 32, 27 |
|                                   | );                                |
|                                   |                                   |
|                                   | bill = calculate_bill (50+60, 25* |
|                                   | 2, 100-75);                       |
|                                   |                                   |
|                                   | bill = calculate_bill (fred, fran |
|                                   | ny, (int) sqrt(25));              |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

[]{#index-math_002eh-system-header-file} []{#index-sqrt-function}

(The last example requires the inclusion of the math routines in
'`math.h`', and compilation with the '-lm' option. `sqrt` is the
square-root function and returns a `double`, so it must be cast into an
`int` to be passed to `calculate_bill`.)

------------------------------------------------------------------------

[]{#Variadic-functions}

  ---------------------------------------------------------------------------------------- -------------------------------------------------------------------- --- ------------------------------------------------------------------------- ------------------------------------ -------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Actual-parameters-and-formal-parameters "Previous section in reading order")\]   \[[\>](#Questions-for-Chapter-8 "Next section in reading order")\]       \[[\<\<](#Parameters "Beginning of this chapter or previous chapter")\]   \[[Up](#Parameters "Up section")\]   \[[\>\>](#Pointers "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ---------------------------------------------------------------------------------------- -------------------------------------------------------------------- --- ------------------------------------------------------------------------- ------------------------------------ -------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Variadic-functions-1}

8.4 Variadic functions {#variadic-functions .section}
----------------------

[]{#index-Variadic-functions} []{#index-Functions_002c-variadic}

Suppose you are writing a program that repeatedly generates lists of
numbers that can run anywhere from one to fifty items. You never know
how many numbers a particular list will contain, but you always want to
add all the numbers together. Passing them to an ordinary C function
will not work, because an ordinary function has a fixed number of formal
parameters, and cannot accept an arbitrarily long list of actual
parameters. What should you do?

[]{#index-stdarg_002eh-system-header-file}

One way of solving this problem is to use a *variadic function*, or
function that can accept arbitrarily long lists of actual parameters.
You can do this by including the '`stdarg.h`' header in your program.
For example, with '`stdarg.h`', you can write a function called
`add_all` that will add all integers passed to it, returning correct
results for all of the following calls:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | sum = add_all (2, 3, 4);          |
|                                   |                                   |
|                                   | sum = add_all (10, 150, 9, 81, 14 |
|                                   | , 2, 2, 31);                      |
|                                   |                                   |
|                                   | sum = add_all (4);                |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

Unfortunately, the use of '`stdarg.h`' is beyond the scope of this
tutorial. For more information on variadic functions, see [the GNU C
Library manual](http://www.gnu.org/manual/glibc-2.0.6/libc.html).

------------------------------------------------------------------------

[]{#Questions-for-Chapter-8}

  ------------------------------------------------------------------- ----------------------------------------------------- --- ------------------------------------------------------------------------- ------------------------------------ -------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Variadic-functions "Previous section in reading order")\]   \[[\>](#Pointers "Next section in reading order")\]       \[[\<\<](#Parameters "Beginning of this chapter or previous chapter")\]   \[[Up](#Parameters "Up section")\]   \[[\>\>](#Pointers "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ------------------------------------------------------------------- ----------------------------------------------------- --- ------------------------------------------------------------------------- ------------------------------------ -------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Questions-for-Chapter-8-1}

8.5 Questions for Chapter 8 {#questions-for-chapter-8 .section}
---------------------------

1.  What is the difference between a value parameter and a variable
    parameter?
2.  What is the difference between a formal parameter and an actual
    parameter?
3.  What does passing by reference let you do that passing by value
    doesn't?
4.  Can a function call be used as an actual parameter?
5.  Do actual and formal parameters need to have the same names?

------------------------------------------------------------------------

[]{#Pointers}

  ------------------------------------------------------------------------ -------------------------------------------------------------- --- ------------------------------------------------------------------------- ----------------------------- --------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Questions-for-Chapter-8 "Previous section in reading order")\]   \[[\>](#Pointer-operators "Next section in reading order")\]       \[[\<\<](#Parameters "Beginning of this chapter or previous chapter")\]   \[[Up](#Top "Up section")\]   \[[\>\>](#Decisions "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ------------------------------------------------------------------------ -------------------------------------------------------------- --- ------------------------------------------------------------------------- ----------------------------- --------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Pointers-1}

9. Pointers {#pointers .chapter}
===========

*Making maps of data.*

[]{#index-Pointers} []{#index-Addresses_002c-memory}
[]{#index-Memory-addresses}

In one sense, any variable in C is just a convenient label for a chunk
of the computer's memory that contains the variable's data. A *pointer*,
then, is a special kind of variable that contains the location or
*address* of that chunk of memory. (Pointers are so called because they
*point* to a chunk of memory.) The address contained by a pointer is a
lengthy number that enables you to pinpoint exactly where in the
computer's memory the variable resides.

[]{#index-Passing-by-reference_002c-origin-of-term}
[]{#index-Reference_002c-passing-by_002c-origin-of-term}

Pointers are one of the more versatile features of C. There are many
good reasons to use them. Knowing a variable's address in memory enables
you to pass the variable to a function by reference (See section
[Variable parameters](#Variable-parameters).) [(2)](#FOOT2){#DOCF2}
Also, since functions are just chunks of code in the computer's memory,
and each of them has its own address, you can create pointers to
functions too, and knowing a function's address in memory enables you to
pass functions as parameters too, giving your functions the ability to
switch among calling numerous functions. (See section [Function
pointers](#Function-pointers).)

Pointers are important when using text strings. In C, a text string is
always accessed with a pointer to a character --- the first character of
the text string. For example, the following code will print the text
string 'Boy howdy!':

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | char *greeting = "Boy howdy!";    |
|                                   | printf ("%s\n\n", greeting);      |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

See section [Strings](#Strings).

Pointers are important for more advanced types of data as well. For
example, there is a data structure called a "linked list" that uses
pointers to "glue" the items in the list together. (See section [Data
structures](#Data-structures), for information on linked lists.)

[]{#index-scanf-function}

Another use for pointers stems from functions like the C input routine
`scanf`. This function accepts information from the keyboard, just as
`printf` sends output to the console. However, `scanf` uses pointers to
variables, not variables themselves. For example, the following code
reads an integer from the keyboard:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | int my_integer;                   |
|                                   | scanf ("%d", &my_integer);        |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

(See section [`scanf`](#scanf), for more information.)

  ----------------------------------------------------------------- ---- --
  [9.1 Pointer operators](#Pointer-operators)                            
  [9.2 Pointer types](#Pointer-types)                                    
  [9.3 Pointers and initialization](#Pointers-and-initialization)        
  [9.4 Variable parameters](#Variable-parameters)                        
  [9.5 Questions for Chapter 9](#Questions-for-Chapter-9)                
  ----------------------------------------------------------------- ---- --

------------------------------------------------------------------------

[]{#Pointer-operators}

  --------------------------------------------------------- ---------------------------------------------------------- --- ----------------------------------------------------------------------- ---------------------------------- --------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Pointers "Previous section in reading order")\]   \[[\>](#Pointer-types "Next section in reading order")\]       \[[\<\<](#Pointers "Beginning of this chapter or previous chapter")\]   \[[Up](#Pointers "Up section")\]   \[[\>\>](#Decisions "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  --------------------------------------------------------- ---------------------------------------------------------- --- ----------------------------------------------------------------------- ---------------------------------- --------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Pointer-operators-1}

9.1 Pointer operators {#pointer-operators .section}
---------------------

[]{#index-_002a-pointer-operator} []{#index-_0026-pointer-operator}

To create a pointer to a variable, we use the `*` and `&` operators. (In
context, these have nothing to do with multiplication or logical AND.
For example, the following code declares a variable called `total_cost`
and a pointer to it called `total_cost_ptr`.

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | float total_cost;                 |
|                                   | float *total_cost_ptr;            |
|                                   |                                   |
|                                   | total_cost_ptr = &total_cost;     |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

The '\*' symbol in the declaration of `total_cost_ptr` is the way to
declare that variable to be a pointer in C. (The '\_ptr' at the end of
the variable name, on the other hand, is just a way of reminding humans
that the variable is a pointer.)

When you read C code to yourself, it is often useful to be able to
pronounce C's operators aloud; you will find it can help you make sense
of a difficult piece of code. For example, you can pronounce the above
statement `float *total_cost_ptr` as "Declare a float pointer called
`total_cost_ptr`", and you can pronounce the statement
`total_cost_ptr = &total_cost;` as "Let `total_cost_ptr` take as its
value the address of the variable `total_cost`".

Here are some suggestions for pronouncing the `*` and `&` operators,
which are always written in front of a variable:

 `*`

:   "The contents of the address held in variable" or "the contents of
    the location pointed to by variable".

 `&`

:   "The address of variable" or "the address at which the variable
    variable is stored".

For instance:

 `&fred`

:   "The address of `fred`" or "the address at which the variable `fred`
    is stored".

 `*fred_ptr`

:   "The contents of the address held in `fred_ptr`" or "the contents of
    the location pointed to by `fred_ptr`".

The following examples show some common ways in which you might use the
`*` and `&` operators:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | int some_var;                     |
|                                   |        /* 1 */                    |
|                                   | ``Declare an integer variable cal |
|                                   | led some_var.''                   |
|                                   |                                   |
|                                   | int *ptr_to_some_var;             |
|                                   |        /* 2 */                    |
|                                   | ``Declare an integer pointer call |
|                                   | ed ptr_to_some_var.''  (The       |
|                                   | * in front of ptr_to_some_var is  |
|                                   | the way C declares                |
|                                   | ptr_to_some_var as a pointer to a |
|                                   | n integer, rather than just an    |
|                                   | integer.)                         |
|                                   |                                   |
|                                   | some_var = 42;                    |
|                                   |        /* 3 */                    |
|                                   | ``Let some_var take the value 42. |
|                                   | ''                                |
|                                   | ```                               |
|                                   |                                   |
|                                   | ``` {.smallexample}               |
|                                   | ```                               |
|                                   |                                   |
|                                   | ``` {.smallexample}               |
|                                   | ptr_to_some_var = &some_var;      |
|                                   |        /* 4 */                    |
|                                   | ``Let ptr_to_some_var take the ad |
|                                   | dress of the variable             |
|                                   | some_var as its value.''  (Notice |
|                                   |  that only now does               |
|                                   | ptr_to_some_var become a pointer  |
|                                   | to the particular variable        |
|                                   | some_var --- before this, it was  |
|                                   | merely a pointer that could       |
|                                   | point to any integer variable.)   |
|                                   |                                   |
|                                   | printf ("%d\n\n", *ptr_to_some_va |
|                                   | r);    /* 5 */                    |
|                                   | ``Print out the contents of the l |
|                                   | ocation pointed to by             |
|                                   | ptr_to_some_var.''  (In other wor |
|                                   | ds, print out some_var            |
|                                   | itself.  This will print just 42. |
|                                   |   Accessing what a pointer points |
|                                   |  to in                            |
|                                   | this way is called dereferencing  |
|                                   | the pointer, because the pointer  |
|                                   | is considered to be referencing t |
|                                   | he variable.)                     |
|                                   |                                   |
|                                   | *ptr_to_some_var = 56; /* 6 */ `` |
|                                   | Let the contents of the location  |
|                                   | pointed to by ptr_to_some_var equ |
|                                   | al 56.''  (In the context of the  |
|                                   | other statements, this is the sam |
|                                   | e as the more direct statement    |
|                                   | some_var = 56;.)                  |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

**A subtle point:** don't confuse the usage of asterisks in code like
examples 2 and 6 above. Using an asterisk in a declaration, as in
example 2, declares the variable to be a pointer, while using it on the
left-hand side of an assignment, as in example 6, dereferences a
variable that is already a pointer, enabling you to access the variable
to which the pointer is pointing.

------------------------------------------------------------------------

[]{#Pointer-types}

  ------------------------------------------------------------------ ------------------------------------------------------------------------ --- ----------------------------------------------------------------------- ---------------------------------- --------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Pointer-operators "Previous section in reading order")\]   \[[\>](#Pointers-and-initialization "Next section in reading order")\]       \[[\<\<](#Pointers "Beginning of this chapter or previous chapter")\]   \[[Up](#Pointers "Up section")\]   \[[\>\>](#Decisions "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ------------------------------------------------------------------ ------------------------------------------------------------------------ --- ----------------------------------------------------------------------- ---------------------------------- --------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Pointer-types-1}

9.2 Pointer types {#pointer-types .section}
-----------------

[]{#index-Pointer-types} []{#index-Pointers_002c-types-of}
[]{#index-Types_002c-pointer}

Pointers can point to any type of variable, but they must be declared to
do so. A pointer to an integer is not the same type of variable as a
pointer to a float or other variable type. At the "business end" of a
pointer is usually a variable, and all variables have a type.

Here are some examples of different types of pointer:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | int *my_integer_ptr;              |
|                                   |                                   |
|                                   | char *my_character_ptr;           |
|                                   |                                   |
|                                   | float *my_float_ptr;              |
|                                   |                                   |
|                                   | double *my_double_ptr;            |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

However, GCC is fairly lenient about casting different types of pointer
to one another *implicitly*, or automatically, without your
intervention. For example, the following code will simply truncate the
value of `*float_ptr` and print out 23. (As a bonus, pronunciation is
given for every significant line of the code in this example.)

[]{#index-Pointer-expressions_002c-pronunciation-of}
[]{#index-Pronunciation-of-pointer-expressions}

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | #include <stdio.h>                |
|                                   | /* Include the standard input/out |
|                                   | put header in this program */     |
|                                   |                                   |
|                                   | int main()                        |
|                                   | /* Declare a function called main |
|                                   |  that returns an integer          |
|                                   |    and takes no parameters */     |
|                                   | {                                 |
|                                   |   int *integer_ptr;               |
|                                   |   /* Declare an integer pointer c |
|                                   | alled integer_ptr */              |
|                                   |                                   |
|                                   |   float *float_ptr;               |
|                                   |   /* Declare a floating-point poi |
|                                   | nter called float_ptr */          |
|                                   |                                   |
|                                   |   int my_int = 17;                |
|                                   |   /* Declare an integer variable  |
|                                   | called my_int                     |
|                                   |      and assign it the value 17 * |
|                                   | /                                 |
|                                   |                                   |
|                                   |   float my_float = 23.5;          |
|                                   |   /* Declare a floating-point var |
|                                   | iable called my_float             |
|                                   |      and assign it the value 23.5 |
|                                   |  */                               |
|                                   |                                   |
|                                   |   integer_ptr = &my_int;          |
|                                   |   /* Assign the address of the in |
|                                   | teger variable my_int             |
|                                   |      to the integer pointer varia |
|                                   | ble integer_ptr */                |
|                                   |                                   |
|                                   |   float_ptr = &my_float;          |
|                                   |   /* Assign the address of the fl |
|                                   | oating-point variable my_float    |
|                                   |      to the floating-point pointe |
|                                   | r variable float_ptr */           |
|                                   |                                   |
|                                   |   *integer_ptr = *float_ptr;      |
|                                   |   /* Assign the contents of the l |
|                                   | ocation pointed to by             |
|                                   |      the floating-point pointer v |
|                                   | ariable float_ptr                 |
|                                   |      to the location pointed to b |
|                                   | y the integer pointer variable    |
|                                   |      integer_ptr (the value assig |
|                                   | ned will be truncated) */         |
|                                   |                                   |
|                                   |   printf ("%d\n\n", *integer_ptr) |
|                                   | ;                                 |
|                                   |   /* Print the contents of the lo |
|                                   | cation pointed to by the          |
|                                   |      integer pointer variable int |
|                                   | eger_ptr */                       |
|                                   |                                   |
|                                   |   return 0;                       |
|                                   |   /* Return a value of 0, indicat |
|                                   | ing successful execution,         |
|                                   |      to the operating system */   |
|                                   |                                   |
|                                   | }                                 |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

There will still be times when you will want to convert one type of
pointer into another. For example, GCC will give a warning if you try to
pass float pointers to a function that accepts integer pointers. Not
treating pointer types interchangeably will also help you understand
your own code better.

[]{#index-Pointer-types_002c-casting} []{#index-Casting-pointer-types}
[]{#index-Cast-operator-1} []{#index-Operator_002c-cast-1}

To convert pointer types, use the cast operator. (See section [The cast
operator](#The-cast-operator).) As you know, the general form of the
cast operator is as follows:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | (type) variable                   |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

Here is the general form of the cast operator for pointers:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | (type *) pointer_variable         |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

Here is an actual example:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | int *my_integer_ptr;              |
|                                   | long *my_long_ptr;                |
|                                   |                                   |
|                                   | my_long_ptr = (long *) my_integer |
|                                   | _ptr;                             |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

This copies the value of the pointer `my_integer` to the pointer
`my_long_ptr`. The cast operator ensures that the data types match. (See
section [Data structures](#Data-structures), for more details on pointer
casting.)

------------------------------------------------------------------------

[]{#Pointers-and-initialization}

  -------------------------------------------------------------- ---------------------------------------------------------------- --- ----------------------------------------------------------------------- ---------------------------------- --------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Pointer-types "Previous section in reading order")\]   \[[\>](#Variable-parameters "Next section in reading order")\]       \[[\<\<](#Pointers "Beginning of this chapter or previous chapter")\]   \[[Up](#Pointers "Up section")\]   \[[\>\>](#Decisions "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  -------------------------------------------------------------- ---------------------------------------------------------------- --- ----------------------------------------------------------------------- ---------------------------------- --------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Pointers-and-initialization-1}

9.3 Pointers and initialization {#pointers-and-initialization .section}
-------------------------------

[]{#index-Pointers-and-initialization}
[]{#index-Initialization-and-pointers}

You should not initialize pointers with a value when you declare them,
although the compiler will not prevent this. Doing so simply makes no
sense. For example, think about what happens in the following statement:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | int *my_int_ptr = 2;              |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

First, the program allocates space for a pointer to an integer.
Initially, the space will contain *garbage* (random data). It will not
contain actual data until the pointer is "pointed at" such data. To
cause the pointer to refer to a real variable, you need another
statement, such as the following:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | my_int_ptr = &my_int;             |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

On the other hand, if you use just the single initial assignment,
`int *my_int_ptr = 2;`, the program will try to fill the contents of the
memory location pointed to by `my_int_ptr` with the value 2. Since
`my_int_ptr` is filled with garbage, it can be *any* address. This means
that the value 2 might be stored anywhere. anywhere, and if it
overwrites something important, it may cause the program to crash.

The compiler will warn you against this. Heed the warning!

------------------------------------------------------------------------

[]{#Variable-parameters}

  ---------------------------------------------------------------------------- ----------------------------------------------------------------------- --- ----------------------------------------------------------------------- ---------------------------------- --------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Pointers-and-initialization "Previous section in reading order")\]   \[[\>](#Passing-pointers-correctly "Next section in reading order")\]       \[[\<\<](#Pointers "Beginning of this chapter or previous chapter")\]   \[[Up](#Pointers "Up section")\]   \[[\>\>](#Decisions "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ---------------------------------------------------------------------------- ----------------------------------------------------------------------- --- ----------------------------------------------------------------------- ---------------------------------- --------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Variable-parameters-1}

9.4 Variable parameters {#variable-parameters .section}
-----------------------

[]{#index-Variable-parameters-1} []{#index-Passing-by-reference}
[]{#index-Parameters_002c-variable-1}
[]{#index-Reference_002c-passing-by}

Now that you know something about pointers, we can discuss variable
parameters and passing by reference in more detail. (See section
[Parameters](#Parameters), to refresh your memory on this topic.)

There are two main ways to return information from a function. The most
common way uses the `return` command. However, `return` can only pass
one value at a time back to the calling function. The second way to
return information to a function uses variable parameters. Variable
parameters ("passing by reference") enable you to pass back an arbitrary
number of values, as in the following example:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | #include <stdio.h>                |
|                                   |                                   |
|                                   | int main();                       |
|                                   | void get_values (int *, int *);   |
|                                   |                                   |
|                                   | int main()                        |
|                                   | {                                 |
|                                   |   int num1, num2;                 |
|                                   |   get_values (&num1, &num2);      |
|                                   |                                   |
|                                   |   printf ("num1 = %d and num2 = % |
|                                   | d\n\n", num1, num2);              |
|                                   |                                   |
|                                   |   return 0;                       |
|                                   | }                                 |
|                                   |                                   |
|                                   |                                   |
|                                   | void get_values (int *num_ptr1, i |
|                                   | nt *num_ptr2)                     |
|                                   | {                                 |
|                                   |   *num_ptr1 = 10;                 |
|                                   |   *num_ptr2 = 20;                 |
|                                   | }                                 |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

The output from this program reads:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | num1 = 10 and num2 = 20           |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

Note that we do use a `return` command in this example --- in the `main`
function. Remember, `main` must always be declared of type `int` and
should always return an integer value. (See section [Style](#Style).)

When you use value parameters, the formal parameters (the parameters in
the function being called) are mere copies of the actual parameters (the
parameters in the function call). When you use variable parameters, on
the other hand, you are passing the addresses of the variables
themselves. Therefore, in the program above, it is not copies of the
variables `num1` and `num2` that are passed to `get_values`, but the
addresses of their actual memory locations. This information can be used
to alter the variables directly, and to return the new values.

  --------------------------------------------------------------------------------- ---- --
  [9.4.1 Passing pointers correctly](#Passing-pointers-correctly)                        
  [9.4.2 Another variable parameter example](#Another-variable-parameter-example)        
  --------------------------------------------------------------------------------- ---- --

------------------------------------------------------------------------

[]{#Passing-pointers-correctly}

  -------------------------------------------------------------------- ------------------------------------------------------------------------------- --- ----------------------------------------------------------------------- --------------------------------------------- --------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Variable-parameters "Previous section in reading order")\]   \[[\>](#Another-variable-parameter-example "Next section in reading order")\]       \[[\<\<](#Pointers "Beginning of this chapter or previous chapter")\]   \[[Up](#Variable-parameters "Up section")\]   \[[\>\>](#Decisions "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  -------------------------------------------------------------------- ------------------------------------------------------------------------------- --- ----------------------------------------------------------------------- --------------------------------------------- --------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Passing-pointers-correctly-1}

### 9.4.1 Passing pointers correctly {#passing-pointers-correctly .subsection}

You might be wondering why `main` calls the function `get_values` above
with ampersands before the parameters ---

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | get_values (&num1, &num2);        |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

--- while the function itself is defined with asterisks before its
parameters:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | void get_values (int *num_ptr1, i |
|                                   | nt *num_ptr2)                     |
|                                   | {                                 |
|                                   |   *num_ptr1 = 10;                 |
|                                   |   *num_ptr2 = 20;                 |
|                                   | }                                 |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

Think carefully for a moment about what is happening in these fragments
of code. The variables `num1` and `num2` in `main` are ordinary
integers, so when `main` prefixes them with ampersands (`&`) while
passing them to `get_values`, it is really passing integer pointers.
Remember, `&num1` should be read as "the address of the variable
`num1`".

The code reads like this:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | get_values (&num1, &num2);        |
|                                   |                                   |
|                                   | ``Evaluate the function get_value |
|                                   | s, passing to it the              |
|                                   | addresses at which the variables  |
|                                   | num1 and num2 are stored.''.      |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

The function `get_values` is defined like this:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | void get_values (int *num_ptr1, i |
|                                   | nt *num_ptr2)                     |
|                                   |                                   |
|                                   | ``Define the function get_values. |
|                                   |   It returns a void               |
|                                   | value (so it operates only via `` |
|                                   | side effects'' on the variable    |
|                                   | parameters it is passed).  It tak |
|                                   | es two parameters, both of type   |
|                                   | int *.  The first parameter is ca |
|                                   | lled num_ptr1 and is a            |
|                                   | pointer to an integer value, and  |
|                                   | the second parameter is called    |
|                                   | num_ptr2 and is also a pointer to |
|                                   |  an integer value.  When this     |
|                                   | function is called, it must be pa |
|                                   | ssed the addresses of variables,  |
|                                   | not the                           |
|                                   | variables themselves.''           |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

Remember that declaring a variable with an asterisk (`*`) before it
means "declare this variable to be a pointer", so the formal parameters
of `get_values` are integer pointers. The parameters *must* be declared
this way, because the `main` function sends the addresses of `num1` and
`num2` --- that is, by the time the `get_values` function receives the
parameters, they are *already* pointers --- hence their names in
`get_values`: `num_ptr1` and `num_ptr2`, rather than `num1` and `num2`.

In effect, we are "matching up" the data types of `num1` and `num2` with
those of `num_ptr1` and `num_ptr2`, respectively, when we prefix `num1`
and `num2` with ampersands while passing them, and prefix `num_ptr1` and
`num_ptr2` with asterisks in the parameter list of the function
`get_values`. We do not have to write `num_ptr1 = &num1;` and
`num_ptr2 = &num2;` --- the calling convention does that for us.

[]{#index-Actual-parameters_002c-passing-as-pointers}
[]{#index-Passing-actual-parameters-as-pointers}

**Important!** This is a general rule in C: when you pass actual
parameters as pointers using ampersands (e.g. `&num1`, "the address of
the variable `num1`"), you must use asterisks to declare as pointers the
corresponding formal parameters in the function to which you pass them,
(e.g. `int *num_ptr1`, "the contents of the location pointed to by
`num_ptr1`").

------------------------------------------------------------------------

[]{#Another-variable-parameter-example}

  --------------------------------------------------------------------------- -------------------------------------------------------------------- --- ----------------------------------------------------------------------- --------------------------------------------- --------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Passing-pointers-correctly "Previous section in reading order")\]   \[[\>](#Questions-for-Chapter-9 "Next section in reading order")\]       \[[\<\<](#Pointers "Beginning of this chapter or previous chapter")\]   \[[Up](#Variable-parameters "Up section")\]   \[[\>\>](#Decisions "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  --------------------------------------------------------------------------- -------------------------------------------------------------------- --- ----------------------------------------------------------------------- --------------------------------------------- --------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Another-variable-parameter-example-1}

### 9.4.2 Another variable parameter example {#another-variable-parameter-example .subsection}

[]{#index-Variable-parameters-2} []{#index-Parameters_002c-variable-2}

There is nothing mysterious about pointers, but they can be tricky. Here
is another example.

Notice that the pointers in both this example and the example above are
dereferenced with asterisks before they are used (for instance, when the
contents of the location pointed to by `height_ptr` are multiplied by
the integer `hscale` with the line `*height_ptr = *height_ptr * hscale;`
in the function `scale_dimensions` below).

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | #include <stdio.h>                |
|                                   |                                   |
|                                   | int main();                       |
|                                   | void scale_dimensions (int *, int |
|                                   |  *);                              |
|                                   |                                   |
|                                   | /* Scale some measurements */     |
|                                   |                                   |
|                                   | int main()                        |
|                                   | {                                 |
|                                   |   int height,width;               |
|                                   |                                   |
|                                   |   height = 4;                     |
|                                   |   width = 5;                      |
|                                   |                                   |
|                                   |   scale_dimensions (&height, &wid |
|                                   | th);                              |
|                                   |                                   |
|                                   |   printf ("Scaled height = %d\n", |
|                                   |  height);                         |
|                                   |   printf ("Scaled width = %d\n",  |
|                                   | width);                           |
|                                   |                                   |
|                                   |   return 0;                       |
|                                   | }                                 |
|                                   |                                   |
|                                   |                                   |
|                                   | void scale_dimensions (int *heigh |
|                                   | t_ptr, int *width_ptr)            |
|                                   | {                                 |
|                                   |   int hscale = 3;        /* scale |
|                                   |  factors */                       |
|                                   |   int wscale = 5;                 |
|                                   |                                   |
|                                   |   *height_ptr = *height_ptr * hsc |
|                                   | ale;                              |
|                                   |   *width_ptr = *width_ptr * wscal |
|                                   | e;                                |
|                                   | }                                 |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

------------------------------------------------------------------------

[]{#Questions-for-Chapter-9}

  ----------------------------------------------------------------------------------- ------------------------------------------------------ --- ----------------------------------------------------------------------- ---------------------------------- --------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Another-variable-parameter-example "Previous section in reading order")\]   \[[\>](#Decisions "Next section in reading order")\]       \[[\<\<](#Pointers "Beginning of this chapter or previous chapter")\]   \[[Up](#Pointers "Up section")\]   \[[\>\>](#Decisions "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ----------------------------------------------------------------------------------- ------------------------------------------------------ --- ----------------------------------------------------------------------- ---------------------------------- --------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Questions-for-Chapter-9-1}

9.5 Questions for Chapter 9 {#questions-for-chapter-9 .section}
---------------------------

1.  What is a pointer?
2.  How is a variable declared to be a pointer?
3.  What data types can pointers point to?
4.  Write a statement which converts a pointer to an integer into a
    pointer to a `double` type.
5.  Why is it incorrect to write `float *number = 2.65;` ?

  ------------------------------------------------------------ ---- ------------
  [10.1 `if`](#if)                                                  
  [10.2 `if… else…`](#if_002e_002e_002e-else_002e_002e_002e)        
  [10.3 Nested `if` statements](#Nested-if-statements)              
  • The ?\...:..                                                    operator::
  [10.5 The `switch` statement](#The-switch-statement)              
  [10.6 Example Listing](#Example-15)                               
  [10.7 Questions for Chapter 10](#Questions-for-Chapter-10)        
  ------------------------------------------------------------ ---- ------------

------------------------------------------------------------------------

[]{#Decisions}

  ------------------------------------------------------------------------ ----------------------------------------------- --- ----------------------------------------------------------------------- ----------------------------- ----------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Questions-for-Chapter-9 "Previous section in reading order")\]   \[[\>](#if "Next section in reading order")\]       \[[\<\<](#Pointers "Beginning of this chapter or previous chapter")\]   \[[Up](#Top "Up section")\]   \[[\>\>](#Loops "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ------------------------------------------------------------------------ ----------------------------------------------- --- ----------------------------------------------------------------------- ----------------------------- ----------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Decisions-1}

10. Decisions {#decisions .chapter}
=============

*Testing and Branching. Making conditions.*

[]{#index-Decisions}

Until now, our code examples have been linear: control has flowed in one
direction from start to finish. In this chapter, we will examine ways to
enable code to make decisions and to choose among options. You will
learn how to program code that will function in situations similar to
the following:

-   If the user hits the jackpot, print a message to say so: 'You\'ve
    won!'
-   If a bank balance is positive, then print 'C' for "credit";
    otherwise, print 'D' for "debit".
-   If the user has typed in one of five choices, then do something that
    corresponds to the choice, otherwise display an error message.

In the first case there is a simple "do or don't" choice. In the second
case, there are two choices. The final case contains several
possibilities.

C offers four main ways of coding decisions like the ones above. They
are listed below.

[]{#index-if-command} []{#index-else-command} []{#index-_003f-operator}
[]{#index-switch-command}

 `if…`

:   +-----------------------------------+-----------------------------------+
    |                                   | ``` {.smallexample}               |
    |                                   | if (condition)                    |
    |                                   | {                                 |
    |                                   |   do something                    |
    |                                   | }                                 |
    |                                   | ```                               |
    +-----------------------------------+-----------------------------------+

 `if…else…`

:   +-----------------------------------+-----------------------------------+
    |                                   | ``` {.smallexample}               |
    |                                   | if (condition)                    |
    |                                   | {                                 |
    |                                   |   do something                    |
    |                                   | }                                 |
    |                                   | else                              |
    |                                   | {                                 |
    |                                   |   do something else               |
    |                                   | }                                 |
    |                                   | ```                               |
    +-----------------------------------+-----------------------------------+

 `…?…:…`

:   +-----------------------------------+-----------------------------------+
    |                                   | ``` {.smallexample}               |
    |                                   | (condition) ? do something : do s |
    |                                   | omething else;                    |
    |                                   | ```                               |
    +-----------------------------------+-----------------------------------+

 `switch`

:   +-----------------------------------+-----------------------------------+
    |                                   | ``` {.smallexample}               |
    |                                   | switch (condition)                |
    |                                   | {                                 |
    |                                   |   case first case : do first thin |
    |                                   | g                                 |
    |                                   |   case second case : do second th |
    |                                   | ing                               |
    |                                   |   case third case : do third thin |
    |                                   | g                                 |
    |                                   | }                                 |
    |                                   | ```                               |
    +-----------------------------------+-----------------------------------+

  --------------------------------------------------------------- ---- --
  [10.1 `if`](#if)                                                     
  [10.2 `if… else…`](#if_002e_002e_002e-else_002e_002e_002e)           
  [10.3 Nested `if` statements](#Nested-if-statements)                 
  [10.4 The `?`...`:`... operator](#The-question-mark-operator)        
  [10.5 The `switch` statement](#The-switch-statement)                 
  [10.6 Example Listing](#Example-15)                                  
  [10.7 Questions for Chapter 10](#Questions-for-Chapter-10)           
  --------------------------------------------------------------- ---- --

------------------------------------------------------------------------

[]{#if}

  ---------------------------------------------------------- ---------------------------------------------------------------------------------- --- ------------------------------------------------------------------------ ----------------------------------- ----------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Decisions "Previous section in reading order")\]   \[[\>](#if_002e_002e_002e-else_002e_002e_002e "Next section in reading order")\]       \[[\<\<](#Decisions "Beginning of this chapter or previous chapter")\]   \[[Up](#Decisions "Up section")\]   \[[\>\>](#Loops "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ---------------------------------------------------------- ---------------------------------------------------------------------------------- --- ------------------------------------------------------------------------ ----------------------------------- ----------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#if-1}

10.1 `if` {#if .section}
---------

[]{#index-if-command-1}

The first form of the `if` statement is an all-or-nothing choice: if
some condition is satisfied, do something; otherwise, do nothing. For
example:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | if (condition) statement;         |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

or

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | if (condition)                    |
|                                   | {                                 |
|                                   |   compound statement              |
|                                   | }                                 |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

In the second example, instead of a single statement, a whole block of
statements is executed. In fact, wherever you can place a single
statement in C, you can place a *compound statement* instead: a block of
statements enclosed by curly brackets.

A *condition* is usually an expression that makes some sort of
comparison. It must be either true or false, and it must be enclosed in
parentheses: '(...)'. If the condition is true, then the statement or
compound statement following the condition will be executed; otherwise,
it will be ignored. For example:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | if (my_num == 0)                  |
|                                   | {                                 |
|                                   |   printf ("The number is zero.\n" |
|                                   | );                                |
|                                   | }                                 |
|                                   |                                   |
|                                   | if (my_num > 0)                   |
|                                   | {                                 |
|                                   |   printf ("The number is positive |
|                                   | .\n");                            |
|                                   | }                                 |
|                                   |                                   |
|                                   | if (my_num < 0)                   |
|                                   | {                                 |
|                                   |   printf ("The number is negative |
|                                   | .\n");                            |
|                                   | }                                 |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

The same code could be written more compactly in the following way:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | if (my_num == 0) printf ("The num |
|                                   | ber is zero.\n");                 |
|                                   | if (my_num > 0) printf ("The numb |
|                                   | er is positive.\n");              |
|                                   | if (my_num < 0) printf ("The numb |
|                                   | er is negative.\n");              |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

It is often a good idea stylistically to use curly brackets in an `if`
statement. It is no less efficient from the compiler's viewpoint, and
sometimes you will want to include more statements later. It also makes
`if` statements stand out clearly in the code. However, curly brackets
make no sense for short statements such as the following:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | if (my_num == 0) my_num++;        |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

The `if` command by itself permits only limited decisions. With the
addition of `else` in the next section, however, `if` becomes much more
flexible.

------------------------------------------------------------------------

[]{#if_002e_002e_002e-else_002e_002e_002e}

  --------------------------------------------------- ----------------------------------------------------------------- --- ------------------------------------------------------------------------ ----------------------------------- ----------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#if "Previous section in reading order")\]   \[[\>](#Nested-if-statements "Next section in reading order")\]       \[[\<\<](#Decisions "Beginning of this chapter or previous chapter")\]   \[[Up](#Decisions "Up section")\]   \[[\>\>](#Loops "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  --------------------------------------------------- ----------------------------------------------------------------- --- ------------------------------------------------------------------------ ----------------------------------- ----------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#if_2026-else_2026}

10.2 `if… else…` {#if-else .section}
----------------

Let's review the basic form of the `if… else…` statement:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | if (condition)                    |
|                                   | {                                 |
|                                   |   compound statement              |
|                                   | }                                 |
|                                   | else                              |
|                                   | {                                 |
|                                   |   compound statement              |
|                                   | }                                 |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

As with the bare `if` statement, there is a simplified version of the
`if… else…` statement without code blocks:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | if (condition) statement else sta |
|                                   | tement;                           |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

When the `if… else…` is executed, the condition in parentheses is
evaluated. If it is true, then the first statement or code block is
executed; otherwise, the second statement or code block is executed.
This can save unnecessary tests and make a program more efficient:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | if (my_num > 0)                   |
|                                   | {                                 |
|                                   |   printf ("The number is positive |
|                                   | .");                              |
|                                   | }                                 |
|                                   | else                              |
|                                   | {                                 |
|                                   |   printf ("The number is zero or  |
|                                   | negative.");                      |
|                                   | }                                 |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

It is not necessary to test `my_num` in the second block because that
block is not executed unless `my_num` is *not* greater than zero.

------------------------------------------------------------------------

[]{#Nested-if-statements}

  -------------------------------------------------------------------------------------- ----------------------------------------------------------------------- --- ------------------------------------------------------------------------ ----------------------------------- ----------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#if_002e_002e_002e-else_002e_002e_002e "Previous section in reading order")\]   \[[\>](#The-question-mark-operator "Next section in reading order")\]       \[[\<\<](#Decisions "Beginning of this chapter or previous chapter")\]   \[[Up](#Decisions "Up section")\]   \[[\>\>](#Loops "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  -------------------------------------------------------------------------------------- ----------------------------------------------------------------------- --- ------------------------------------------------------------------------ ----------------------------------- ----------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Nested-if-statements-1}

10.3 Nested `if` statements {#nested-if-statements .section}
---------------------------

[]{#index-if-command-2} []{#index-if-statements_002c-nested}
[]{#index-Nested-if-statements}

Consider the following two code examples. Their purposes are exactly the
same.

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | int my_num = 3;                   |
|                                   |                                   |
|                                   | if ((my_num > 2) && (my_num < 4)) |
|                                   | {                                 |
|                                   |   printf ("my_num is three");     |
|                                   | }                                 |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

or:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | int my_num =3;                    |
|                                   |                                   |
|                                   | if (my_num > 2)                   |
|                                   | {                                 |
|                                   |   if (my_num < 4)                 |
|                                   |   {                               |
|                                   |     printf ("my_num is three");   |
|                                   |   }                               |
|                                   | }                                 |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

Both of these code examples have the same result, but they arrive at it
in different ways. The first example, when translated into English,
might read, "If `my_num` is greater than two and `my_num` is less than
four (and `my_num` is an integer), then `my_num` has to be three." The
second method is more complicated. In English, it can be read, "If
`my_num` is greater than two, do what is in the first code block. Inside
it, `my_num` is always greater than two; otherwise the program would
never have arrived there. Now, if `my_num` is also less than four, then
do what is inside the second code block. Inside that block, `my_num` is
always less than four. We also know it is more than two, since the whole
of the second test happens inside the block where that's true. So,
assuming `my_num` is an integer, it must be three."

[]{#index-Compound-decisions} []{#index-Decisions_002c-compound}

In short, there are two ways of making compound decisions in C. You make
nested tests, or you can use the comparison operators `&&`, `||`, and so
on. In situations where sequences of comparison operators become too
complex, nested tests are often a more attractive option.

Consider the following example:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | if (i > 2)                        |
|                                   | {                                 |
|                                   |   /* i is greater than 2 here! */ |
|                                   | }                                 |
|                                   | else                              |
|                                   | {                                 |
|                                   |   /* i is less than or equal to 2 |
|                                   |  here! */                         |
|                                   | }                                 |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

The code blocks in this example provide "safe zones" wherein you can
rest assured that certain conditions hold. This enables you to think and
code in a structured way.

You can nest `if` statements in multiple levels, as in the following
example:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | #include <stdio.h>                |
|                                   |                                   |
|                                   | int main ()                       |
|                                   | {                                 |
|                                   |   int grade;                      |
|                                   |                                   |
|                                   |   printf("Type in your grade: "); |
|                                   |   scanf ("%d", &grade);           |
|                                   |                                   |
|                                   |   if (grade < 10)                 |
|                                   |   {                               |
|                                   |     printf ("Man, you're lame!  J |
|                                   | ust go away.\n");                 |
|                                   |   }                               |
|                                   |   else                            |
|                                   |   {                               |
|                                   |     if (grade < 65)               |
|                                   |     {                             |
|                                   |       printf ("You failed.\n");   |
|                                   |     }                             |
|                                   |     else                          |
|                                   |     {                             |
|                                   |       printf ("You passed!\n");   |
|                                   |       if (grade >= 90)            |
|                                   |       {                           |
|                                   |         printf ("And you got an A |
|                                   | !\n");                            |
|                                   |       }                           |
|                                   |       else                        |
|                                   |       {                           |
|                                   |         printf ("But you didn't g |
|                                   | et an A.  Sorry.\n");             |
|                                   |       }                           |
|                                   |     }                             |
|                                   |   }                               |
|                                   |   return 0;                       |
|                                   | }                                 |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

------------------------------------------------------------------------

[]{#The-question-mark-operator}

  --------------------------------------------------------------------- ----------------------------------------------------------------- --- ------------------------------------------------------------------------ ----------------------------------- ----------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Nested-if-statements "Previous section in reading order")\]   \[[\>](#The-switch-statement "Next section in reading order")\]       \[[\<\<](#Decisions "Beginning of this chapter or previous chapter")\]   \[[Up](#Decisions "Up section")\]   \[[\>\>](#Loops "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  --------------------------------------------------------------------- ----------------------------------------------------------------- --- ------------------------------------------------------------------------ ----------------------------------- ----------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#The-_003f_2026_003a_2026-operator}

10.4 The `?`...`:`... operator {#the-operator .section}
------------------------------

[]{#index-_003f-operator-1}

The `?`...`:`... operator is a sort of shorthand `if`...`else`...
statement. Because it is a little cryptic, it is not often used, but the
basic form is as follows:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | (condition) ?  expression1 : expr |
|                                   | ession2;                          |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

The program evaluates condition. If it is true (not zero), then
expression1 is returned; otherwise, expression2 is returned.

For example, in the short program below, the line
`bas = (foo > bar) ? foo : bar;` assigns `foo` to `bas` if `foo` is
greater than `bar`; otherwise, it assigns `bar` to `bas`.

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | #include <stdio.h>                |
|                                   |                                   |
|                                   | int main()                        |
|                                   | {                                 |
|                                   |   int foo = 10;                   |
|                                   |   int bar = 50;                   |
|                                   |   int bas;                        |
|                                   |                                   |
|                                   |   bas = (foo > bar) ? foo : bar;  |
|                                   |                                   |
|                                   |   printf("bas = %d\n\n", bas);    |
|                                   |                                   |
|                                   |   return 0;                       |
|                                   | }                                 |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

The program will print 'bas = 50' as a result.

------------------------------------------------------------------------

[]{#The-switch-statement}

  --------------------------------------------------------------------------- ------------------------------------------------------- --- ------------------------------------------------------------------------ ----------------------------------- ----------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#The-question-mark-operator "Previous section in reading order")\]   \[[\>](#Example-15 "Next section in reading order")\]       \[[\<\<](#Decisions "Beginning of this chapter or previous chapter")\]   \[[Up](#Decisions "Up section")\]   \[[\>\>](#Loops "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  --------------------------------------------------------------------------- ------------------------------------------------------- --- ------------------------------------------------------------------------ ----------------------------------- ----------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#The-switch-statement-1}

10.5 The `switch` statement {#the-switch-statement .section}
---------------------------

[]{#index-switch-command-1}

The `switch` construction is another way of making decisions in C code.
It is very flexible, but only tests for integer and character values. It
has the following general form:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | switch (integer or character expr |
|                                   | ession)                           |
|                                   | {                                 |
|                                   |   case constant1 : statement1;    |
|                                   |   break;          /* optional */  |
|                                   |                                   |
|                                   |   case constant2 : statement2;    |
|                                   |   break;          /* optional */  |
|                                   |                                   |
|                                   |   case constant3 : statement3;    |
|                                   |   break;          /* optional */  |
|                                   |   …                               |
|                                   | }                                 |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

[]{#index-Breaking-out-of-switch-statement}
[]{#index-switch-statement_002c-breaking-out-of}
[]{#index-break-command}

The integer or character expression in the parentheses is evaluated, and
the program checks whether it matches one of the constants in the
various *cases* listed. If there is a match, the statement following
that case will be executed, and execution will continue until either a
`break` statement or the closing curly bracket of the entire `switch`
statement is encountered.

One of the cases is called `default`. Statements after the `default`
case are executed when none of the other cases are satisfied. You only
need a default case if you are not sure you are covering every case with
the ones you list.

Here is an example program that uses the `switch` statement to translate
decimal digits into Morse code:

------------------------------------------------------------------------

[]{#Example-15}

  --------------------------------------------------------------------- --------------------------------------------------------------------- --- ------------------------------------------------------------------------ ----------------------------------- ----------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#The-switch-statement "Previous section in reading order")\]   \[[\>](#Questions-for-Chapter-10 "Next section in reading order")\]       \[[\<\<](#Decisions "Beginning of this chapter or previous chapter")\]   \[[Up](#Decisions "Up section")\]   \[[\>\>](#Loops "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  --------------------------------------------------------------------- --------------------------------------------------------------------- --- ------------------------------------------------------------------------ ----------------------------------- ----------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Example-Listing}

10.6 Example Listing {#example-listing .section}
--------------------

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | #include <stdio.h>                |
|                                   |                                   |
|                                   | int main ();                      |
|                                   | void morse (int);                 |
|                                   |                                   |
|                                   |                                   |
|                                   | int main ()                       |
|                                   | {                                 |
|                                   |   int digit;                      |
|                                   |                                   |
|                                   |   printf ("Enter any digit in the |
|                                   |  range 0 to 9: ");                |
|                                   |   scanf ("%d", &digit);           |
|                                   |                                   |
|                                   |   if ((digit < 0) || (digit > 9)) |
|                                   |   {                               |
|                                   |     printf ("Your number was not  |
|                                   | in the range 0 to 9.\n");         |
|                                   |   }                               |
|                                   |   else                            |
|                                   |   {                               |
|                                   |     printf ("The Morse code of th |
|                                   | at digit is ");                   |
|                                   |     morse (digit);                |
|                                   |   }                               |
|                                   |   return 0;                       |
|                                   | }                                 |
|                                   |                                   |
|                                   |                                   |
|                                   | void morse (int digit)        /*  |
|                                   | print out Morse code */           |
|                                   | {                                 |
|                                   |   switch (digit)                  |
|                                   |   {                               |
|                                   |     case 0 : printf ("-----");    |
|                                   |       break;                      |
|                                   |     case 1 : printf (".----");    |
|                                   |       break;                      |
|                                   |     case 2 : printf ("..---");    |
|                                   |       break;                      |
|                                   |     case 3 : printf ("...--");    |
|                                   |       break;                      |
|                                   |     case 4 : printf ("....-");    |
|                                   |       break;                      |
|                                   |     case 5 : printf (".....");    |
|                                   |       break;                      |
|                                   |     case 6 : printf ("-....");    |
|                                   |       break;                      |
|                                   |     case 7 : printf ("--...");    |
|                                   |       break;                      |
|                                   |     case 8 : printf ("---..");    |
|                                   |       break;                      |
|                                   |     case 9 : printf ("----.");    |
|                                   |   }                               |
|                                   |   printf ("\n\n");                |
|                                   | }                                 |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

The `morse` function selects one of the `printf` statements with
`switch`, based on the integer expression `digit`. After every `case` in
the switch, a `break` statement is used to jump `switch` statement's
closing bracket '}'. Without `break`, execution would *fall through* to
the next case and execute its `printf` statement.

Here is an example of using *fallthrough* in a constructive way. The
function `yes` accepts input from the user and tests whether it was 'y'
or 'Y'. (The `getchar` function is from the standard library and reads a
character of input from the terminal. See section
[`getchar`](#getchar).)

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | #include <stdio.h>                |
|                                   |                                   |
|                                   | int main ()                       |
|                                   | {                                 |
|                                   |   printf ("Will you join the Free |
|                                   |  Software movement? ");           |
|                                   |   if (yes())                      |
|                                   |   {                               |
|                                   |     printf("Great!  The price of  |
|                                   | freedom is eternal vigilance!\n\n |
|                                   | ");                               |
|                                   |   }                               |
|                                   |   else                            |
|                                   |   {                               |
|                                   |     printf("Too bad.  Maybe next  |
|                                   | life...\n\n");                    |
|                                   |   }                               |
|                                   |                                   |
|                                   |   return 0;                       |
|                                   | }                                 |
|                                   |                                   |
|                                   |                                   |
|                                   | int yes()                         |
|                                   | {                                 |
|                                   |   switch (getchar())              |
|                                   |   {                               |
|                                   |     case 'y' :                    |
|                                   |     case 'Y' : return 1;          |
|                                   |     default  : return 0;          |
|                                   |   }                               |
|                                   | }                                 |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

If the character is 'y', then the program falls through and meets the
statement `return 1`. If there were a `break` statement after
`case 'y'`, then the program would not be able to reach `case 'Y'`
unless an actual 'Y' were typed.

[]{#index-return-command-1}
[]{#index-Breaking-out-of-switch-statement-1}
[]{#index-switch-statement_002c-breaking-out-of-1}

**Note:** The `return` statements substitute for `break` in the above
code, but they do more than break out of `switch` --- they break out of
the whole function. This can be a useful trick.

------------------------------------------------------------------------

[]{#Questions-for-Chapter-10}

  ----------------------------------------------------------- -------------------------------------------------- --- ------------------------------------------------------------------------ ----------------------------------- ----------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Example-15 "Previous section in reading order")\]   \[[\>](#Loops "Next section in reading order")\]       \[[\<\<](#Decisions "Beginning of this chapter or previous chapter")\]   \[[Up](#Decisions "Up section")\]   \[[\>\>](#Loops "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ----------------------------------------------------------- -------------------------------------------------- --- ------------------------------------------------------------------------ ----------------------------------- ----------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Questions-for-Chapter-10-1}

10.7 Questions for Chapter 10 {#questions-for-chapter-10 .section}
-----------------------------

1.  Translate the following into good C: "If 1 does not equal 42, print
    out 'Thank heavens for mathematics!' "
2.  Write a program to get a lot of numbers from the user and print out
    the maximum and minimum of those.
3.  Write an automatic teller machine program that simulates telling you
    your bank balance when you enter your account number and PIN number,
    but otherwise displays an error.
4.  Write a mock program for a car computer that tells you how many
    kilometers to the liter you're getting when you enter how many
    liters of gas you've used and how far you travelled.

------------------------------------------------------------------------

[]{#Loops}

  ------------------------------------------------------------------------- -------------------------------------------------- --- ------------------------------------------------------------------------ ----------------------------- ----------------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Questions-for-Chapter-10 "Previous section in reading order")\]   \[[\>](#while "Next section in reading order")\]       \[[\<\<](#Decisions "Beginning of this chapter or previous chapter")\]   \[[Up](#Top "Up section")\]   \[[\>\>](#Preprocessor-directives "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ------------------------------------------------------------------------- -------------------------------------------------- --- ------------------------------------------------------------------------ ----------------------------- ----------------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Loops-1}

11. Loops {#loops .chapter}
=========

[]{#index-Loops}

*Controlling repetitive processes. Nesting loops*

*Loops* are a kind of C construct that enable the programmer to execute
a sequence of instructions over and over, with some condition specifying
when they will stop. There are three kinds of loop in C:

[]{#index-while-command} []{#index-do-_2026-while-command}
[]{#index-for-command}

-   `while`
-   `do` ... `while`
-   `for`

  ------------------------------------------------------------------------ ---- --
  [11.1 `while`](#while)                                                        
  [11.2 `do`...`while`](#do_002e_002e_002ewhile)                                
  [11.3 `for`](#for)                                                            
  [11.4 The flexibility of `for`](#The-flexibility-of-for)                      
  [11.5 Terminating and speeding loops](#Terminating-and-speeding-loops)        
  [11.6 Nested loops](#Nested-loops)                                            
  [11.7 Questions for Chapter 11](#Questions-for-Chapter-11)                    
  ------------------------------------------------------------------------ ---- --

------------------------------------------------------------------------

[]{#while}

  ------------------------------------------------------ ------------------------------------------------------------------- --- -------------------------------------------------------------------- ------------------------------- ----------------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Loops "Previous section in reading order")\]   \[[\>](#do_002e_002e_002ewhile "Next section in reading order")\]       \[[\<\<](#Loops "Beginning of this chapter or previous chapter")\]   \[[Up](#Loops "Up section")\]   \[[\>\>](#Preprocessor-directives "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ------------------------------------------------------ ------------------------------------------------------------------- --- -------------------------------------------------------------------- ------------------------------- ----------------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#while-1}

11.1 `while` {#while .section}
------------

The simplest of the three is the `while` loop. It looks like this:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | while (condition)                 |
|                                   | {                                 |
|                                   |   do something                    |
|                                   | }                                 |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

The condition (for example, `(a > b)`) is evaluated every time the loop
is executed. If the condition is true, then statements in the curly
brackets are executed. If the condition is false, then those statements
are ignored, and the `while` loop ends. The program then executes the
next statement in the program.

The condition comes at the start of the loop, so it is tested at the
start of every *pass*, or time through the loop. If the condition is
false before the loop has been executed even once, then the statements
inside the curly brackets will never be executed. (See section
[`do`...`while`](#do_002e_002e_002ewhile), for an example of a loop
construction where this is not true.)

The following example prompts the user to type in a line of text, and
then counts all the spaces in the line. The loop terminates when the
user hits the \<RET\> key and then prints out the number of spaces. (See
section [`getchar`](#getchar), for more information on the standard
library `getchar` function.)

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | #include <stdio.h>                |
|                                   |                                   |
|                                   | int main()                        |
|                                   | {                                 |
|                                   |   char ch;                        |
|                                   |   int count = 0;                  |
|                                   |                                   |
|                                   |   printf ("Type in a line of text |
|                                   | .\n");                            |
|                                   |                                   |
|                                   |   while ((ch = getchar()) != '\n' |
|                                   | )                                 |
|                                   |   {                               |
|                                   |     if (ch == ' ')                |
|                                   |     {                             |
|                                   |       count++;                    |
|                                   |     }                             |
|                                   |   }                               |
|                                   |                                   |
|                                   |   printf ("Number of spaces = %d. |
|                                   | \n\n", count);                    |
|                                   |   return 0;                       |
|                                   | }                                 |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

------------------------------------------------------------------------

[]{#do_002e_002e_002ewhile}

  ------------------------------------------------------ ------------------------------------------------ --- -------------------------------------------------------------------- ------------------------------- ----------------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#while "Previous section in reading order")\]   \[[\>](#for "Next section in reading order")\]       \[[\<\<](#Loops "Beginning of this chapter or previous chapter")\]   \[[Up](#Loops "Up section")\]   \[[\>\>](#Preprocessor-directives "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ------------------------------------------------------ ------------------------------------------------ --- -------------------------------------------------------------------- ------------------------------- ----------------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#do_2026while}

11.2 `do`...`while` {#dowhile .section}
-------------------

The `do`..`while` loop has the form:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | do                                |
|                                   | {                                 |
|                                   |   do something                    |
|                                   | }                                 |
|                                   | while (condition);                |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

[]{#index-Difference-between-while-and-do}
[]{#index-while-and-do_002c-difference-between}
[]{#index-do-and-while_002c-difference-between}

Notice that the condition is at the *end* of this loop. This means that
a `do..while` loop will always be executed at least once, before the
test is made to determine whether it should continue. This is the chief
difference between `while` and `do`...`while`.

The following program accepts a line of input from the user. If the line
contains a string of characters delimited with double quotation marks,
such as '\"Hello!\"', the program prints the string, with quotation
marks. For example, if the user types in the following string:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | I walked into a red sandstone bui |
|                                   | lding. "Oof!" [Careful, Nick!]    |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

...then the program will print the following string:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | "Oof!"                            |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

If the line contains only one double quotation mark, then the program
will display an error, and if it contains no double quotation marks, the
program will print nothing.

Notice that the `do`...`while` loop in `main` waits to detect a linefeed
character (`\n`), while the one in `get_substring` looks for a double
quotation mark ('\"'), but checks for a linefeed in the *loop body*, or
main code block of the loop, so that it can exit the loop if the user
entered a linefeed prematurely (before the second '\"').

This is one of the more complex examples we have examined so far, and
you might find it useful to *trace* the code, or follow through it step
by step.

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | #include <stdio.h>                |
|                                   |                                   |
|                                   | int main();                       |
|                                   | void get_substring();             |
|                                   |                                   |
|                                   |                                   |
|                                   | int main()                        |
|                                   | {                                 |
|                                   |   char ch;                        |
|                                   |                                   |
|                                   |   printf ("Enter a string with a  |
|                                   | quoted substring:\n\n");          |
|                                   |                                   |
|                                   |   do                              |
|                                   |   {                               |
|                                   |     ch = getchar();               |
|                                   |     if (ch == '"')                |
|                                   |     {                             |
|                                   |       putchar(ch);                |
|                                   |       get_substring();            |
|                                   |     }                             |
|                                   |   }                               |
|                                   |   while (ch != '\n');             |
|                                   |                                   |
|                                   |   return 0;                       |
|                                   | }                                 |
|                                   |                                   |
|                                   |                                   |
|                                   | void get_substring()              |
|                                   | {                                 |
|                                   |   char ch;                        |
|                                   |                                   |
|                                   |   do                              |
|                                   |   {                               |
|                                   |     ch = getchar();               |
|                                   |     putchar(ch);                  |
|                                   |                                   |
|                                   |     if (ch == '\n')               |
|                                   |     {                             |
|                                   |       printf ("\nString was not c |
|                                   | losed ");                         |
|                                   |       printf ("before end of line |
|                                   | .\n");                            |
|                                   |       break;                      |
|                                   |     }                             |
|                                   |   }                               |
|                                   |   while (ch != '"');              |
|                                   |                                   |
|                                   |   printf ("\n\n");                |
|                                   | }                                 |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

------------------------------------------------------------------------

[]{#for}

  ----------------------------------------------------------------------- ------------------------------------------------------------------- --- -------------------------------------------------------------------- ------------------------------- ----------------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#do_002e_002e_002ewhile "Previous section in reading order")\]   \[[\>](#The-flexibility-of-for "Next section in reading order")\]       \[[\<\<](#Loops "Beginning of this chapter or previous chapter")\]   \[[Up](#Loops "Up section")\]   \[[\>\>](#Preprocessor-directives "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ----------------------------------------------------------------------- ------------------------------------------------------------------- --- -------------------------------------------------------------------- ------------------------------- ----------------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#for-1}

11.3 `for` {#for .section}
----------

[]{#index-for-command-1}

The most complex loop in C is the `for` loop. The `for` construct, as it
was developed in earlier computer languages such as BASIC and Pascal,
was intended to behave in the following way:

> For all values of variable from value1 to value2, in steps of
> `value3`, repeat the following sequence of commands...

The `for` loop in C is much more versatile than its counterpart in those
earlier languages. The `for` loop looks like this in C:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | for (initialization; condition; i |
|                                   | ncrement)                         |
|                                   | {                                 |
|                                   |   do something;                   |
|                                   | }                                 |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

In normal usage, these expressions have the following significance.

-   initialization

    This is an expression that initializes the *control variable*, or
    the variable tested in the condition part of the `for` statement.
    (Sometimes this variable is called the loop's *index*.) The
    initialization part is only carried out once before the start of the
    loop. Example: `index = 1`.

-   condition

    This is a conditional expression that is tested every time through
    the loop, just as in a `while` loop. It is evaluated at the
    *beginning* of every loop, and the loop is only executed if the
    expression is true. Example: `index <= 20`.

-   increment

    This is an expression that is used to alter the value of the control
    variable. In earlier languages, this usually meant adding or
    subtracting 1 from the variable. In C, it can be almost anything.
    Examples: `index++`, `index *= 20`, or `index /= 2.3`.

For example, the following `for` loop prints out the integers from 1 to
10:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | int my_int;                       |
|                                   |                                   |
|                                   | for (my_int = 1; my_int <= 10; my |
|                                   | _int++)                           |
|                                   | {                                 |
|                                   |   printf ("%d ", my_int);         |
|                                   |   printf("\n");                   |
|                                   | }                                 |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

The following example prints out all prime numbers between 1 and the
macro value `MAX_INT`. (A prime numbers is a number that cannot be
divided by any number except 1 and itself without leaving a remainder.)
This program checks whether a number is a prime by dividing it by all
smaller integers up to half its size. (See section [Preprocessor
directives](#Preprocessor-directives), for more information on macros.)

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | #include <stdio.h>                |
|                                   |                                   |
|                                   | #define MAX_INT  500              |
|                                   | #define TRUE      1               |
|                                   | #define FALSE     0               |
|                                   |                                   |
|                                   | int main ()                       |
|                                   | {                                 |
|                                   |   int poss_prime;                 |
|                                   |                                   |
|                                   |   for (poss_prime = 2; poss_prime |
|                                   |  <= MAX_INT; poss_prime++)        |
|                                   |   {                               |
|                                   |     if (prime(poss_prime))        |
|                                   |     {                             |
|                                   |       printf ("%d ", poss_prime); |
|                                   |     }                             |
|                                   |   }                               |
|                                   |   printf("\n\n");                 |
|                                   |   return 0;                       |
|                                   | }                                 |
|                                   |                                   |
|                                   |                                   |
|                                   | prime (int poss_prime)       /* c |
|                                   | heck whether poss_prime is prime  |
|                                   | */                                |
|                                   | {                                 |
|                                   |   int poss_factor;                |
|                                   |                                   |
|                                   |   for (poss_factor = 2; poss_fact |
|                                   | or <= poss_prime/2; poss_factor++ |
|                                   | )                                 |
|                                   |   {                               |
|                                   |     if (poss_prime % poss_factor  |
|                                   | == 0)                             |
|                                   |     {                             |
|                                   |       return (FALSE);             |
|                                   |     }                             |
|                                   |   }                               |
|                                   |                                   |
|                                   |   return (TRUE);                  |
|                                   | }                                 |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

The program should print the following sequence of integers:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | 2 3 5 7 11 13 17 19 23 29 31 37 4 |
|                                   | 1 43 47 53 59 61 67 71 73 79 83 8 |
|                                   | 9 97                              |
|                                   | 101 103 107 109 113 127 131 137 1 |
|                                   | 39 149 151 157 163 167 173 179 18 |
|                                   | 1 191                             |
|                                   | 193 197 199 211 223 227 229 233 2 |
|                                   | 39 241 251 257 263 269 271 277 28 |
|                                   | 1 283                             |
|                                   | 293 307 311 313 317 331 337 347 3 |
|                                   | 49 353 359 367 373 379 383 389 39 |
|                                   | 7 401                             |
|                                   | 409 419 421 431 433 439 443 449 4 |
|                                   | 57 461 463 467 479 487 491 499    |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

------------------------------------------------------------------------

[]{#The-flexibility-of-for}

  ---------------------------------------------------- --------------------------------------------------------------------------- --- -------------------------------------------------------------------- ------------------------------- ----------------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#for "Previous section in reading order")\]   \[[\>](#Terminating-and-speeding-loops "Next section in reading order")\]       \[[\<\<](#Loops "Beginning of this chapter or previous chapter")\]   \[[Up](#Loops "Up section")\]   \[[\>\>](#Preprocessor-directives "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ---------------------------------------------------- --------------------------------------------------------------------------- --- -------------------------------------------------------------------- ------------------------------- ----------------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#The-flexibility-of-for-1}

11.4 The flexibility of `for` {#the-flexibility-of-for .section}
-----------------------------

[]{#index-for-command-2} []{#index-Flexibility-of-for-command}
[]{#index-for-command_002c-flexibility-of}

As mentioned above, C's `for` construct is quite versatile. You can use
almost any statement you like for its initialization, condition, and
increment parts, including an empty statement. For example, omitting the
initialization and increment parts creates what is essentially a `while`
loop:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | int my_int = 1;                   |
|                                   |                                   |
|                                   | for ( ; my_int <= 20; )           |
|                                   | {                                 |
|                                   |   printf ("%d ", my_int);         |
|                                   |   my_int++;                       |
|                                   | }                                 |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

Omitting the condition part as well produces an *infinite loop*, or loop
that never ends:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | for ( ; ; )                       |
|                                   | {                                 |
|                                   |   printf("Aleph Null bottles of b |
|                                   | eer on the wall...\n");           |
|                                   | }                                 |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

You can break out of an "infinite loop" with the `break` or `return`
commands. (See section [Terminating and speeding
loops](#Terminating-and-speeding-loops).)

Consider the following loop:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | for (my_int = 2; my_int <= 1000;  |
|                                   | my_int = my_int * my_int)         |
|                                   | {                                 |
|                                   |   printf ("%d ", my_int);         |
|                                   | }                                 |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

This loop begins with 2, and each time through the loop, `my_int` is
squared.

Here's another odd `for` loop:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | char ch;                          |
|                                   |                                   |
|                                   | for (ch = '*'; ch != '\n'; ch = g |
|                                   | etchar())                         |
|                                   | {                                 |
|                                   |   /* do something */              |
|                                   | }                                 |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

This loop starts off by initializing `ch` with an asterisk. It checks
that `ch` is not a linefeed character (which it isn't, the first time
through), then reads a new value of `ch` with the library function
`getchar` and executes the code inside the curly brackets. When it
detects a line feed, the loop ends.

It is also possible to combine several increment parts in a `for` loop
using the comma operator `,`. (See section [The comma
operator](#The-comma-operator), for more information.)

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | #include <stdio.h>                |
|                                   |                                   |
|                                   | int main()                        |
|                                   | {                                 |
|                                   |   int up, down;                   |
|                                   |                                   |
|                                   |   for (up = 0, down=10; up < down |
|                                   | ; up++, down--)                   |
|                                   |   {                               |
|                                   |     printf("up = %d, down= %d\n", |
|                                   | up,down);                         |
|                                   |   }                               |
|                                   |                                   |
|                                   |   return 0;                       |
|                                   | }                                 |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

The example above will produce the following output:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | up = 0, down= 10                  |
|                                   | up = 1, down= 9                   |
|                                   | up = 2, down= 8                   |
|                                   | up = 3, down= 7                   |
|                                   | up = 4, down= 6                   |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

One feature of the `for` loop that unnerves some programmers is that
even the value of the loop's conditional expression can be altered from
within the loop itself:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | int index, number = 20;           |
|                                   |                                   |
|                                   | for (index = 0; index <= number;  |
|                                   | index++)                          |
|                                   | {                                 |
|                                   |   if (index == 9)                 |
|                                   |   {                               |
|                                   |     number = 30;                  |
|                                   |   }                               |
|                                   | }                                 |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

In many languages, this technique is syntactically forbidden. Not so in
the flexible language C. It is rarely a good idea, however, because it
can make your code confusing and hard to maintain.

------------------------------------------------------------------------

[]{#Terminating-and-speeding-loops}

  ----------------------------------------------------------------------- ------------------------------------------------------------------------- --- -------------------------------------------------------------------- ------------------------------- ----------------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#The-flexibility-of-for "Previous section in reading order")\]   \[[\>](#Terminating-loops-with-break "Next section in reading order")\]       \[[\<\<](#Loops "Beginning of this chapter or previous chapter")\]   \[[Up](#Loops "Up section")\]   \[[\>\>](#Preprocessor-directives "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ----------------------------------------------------------------------- ------------------------------------------------------------------------- --- -------------------------------------------------------------------- ------------------------------- ----------------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Terminating-and-speeding-loops-1}

11.5 Terminating and speeding loops {#terminating-and-speeding-loops .section}
-----------------------------------

[]{#index-Terminating-loops} []{#index-Speeding-loops}
[]{#index-Loops_002c-terminating} []{#index-Loops_002c-speeding}

C provides simple ways of terminating or speeding up any of the three
loops we have discussed, whether or not it has run its course. The three
main commands to do so are `break`, `return`, and `continue`.

  -------------------------------------------------------------------------- ---- --
  [11.5.1 Terminating loops with `break`](#Terminating-loops-with-break)          
  [11.5.2 Terminating loops with `return`](#Terminating-loops-with-return)        
  [11.5.3 Speeding loops with `continue`](#Speeding-loops-with-continue)          
  -------------------------------------------------------------------------- ---- --

------------------------------------------------------------------------

[]{#Terminating-loops-with-break}

  ------------------------------------------------------------------------------- -------------------------------------------------------------------------- --- -------------------------------------------------------------------- -------------------------------------------------------- ----------------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Terminating-and-speeding-loops "Previous section in reading order")\]   \[[\>](#Terminating-loops-with-return "Next section in reading order")\]       \[[\<\<](#Loops "Beginning of this chapter or previous chapter")\]   \[[Up](#Terminating-and-speeding-loops "Up section")\]   \[[\>\>](#Preprocessor-directives "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ------------------------------------------------------------------------------- -------------------------------------------------------------------------- --- -------------------------------------------------------------------- -------------------------------------------------------- ----------------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Terminating-loops-with-break-1}

### 11.5.1 Terminating loops with `break` {#terminating-loops-with-break .subsection}

[]{#index-Terminating-loops-with-break}
[]{#index-Loops_002c-terminating-with-break} []{#index-break-command-1}
[]{#index-break_002c-terminating-loops-with}

The usual statement to terminate a loop is the same statement that is
used to jump out of `switch` statements:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | break;                            |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

If this statement is encountered within a loop, the loop will end
immediately. For instance, here is an inefficient way of assigning 12 to
`my_int`:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | for (my_int = 1; my_int <= 100; m |
|                                   | y_int++)                          |
|                                   | {                                 |
|                                   |   if (my_int == 12)               |
|                                   |   {                               |
|                                   |     break;                        |
|                                   |   }                               |
|                                   | }                                 |
|                                   |                                   |
|                                   | printf("my_int = %d\n\n", my_int) |
|                                   | ;                                 |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

------------------------------------------------------------------------

[]{#Terminating-loops-with-return}

  ----------------------------------------------------------------------------- ------------------------------------------------------------------------- --- -------------------------------------------------------------------- -------------------------------------------------------- ----------------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Terminating-loops-with-break "Previous section in reading order")\]   \[[\>](#Speeding-loops-with-continue "Next section in reading order")\]       \[[\<\<](#Loops "Beginning of this chapter or previous chapter")\]   \[[Up](#Terminating-and-speeding-loops "Up section")\]   \[[\>\>](#Preprocessor-directives "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ----------------------------------------------------------------------------- ------------------------------------------------------------------------- --- -------------------------------------------------------------------- -------------------------------------------------------- ----------------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Terminating-loops-with-return-1}

### 11.5.2 Terminating loops with `return` {#terminating-loops-with-return .subsection}

[]{#index-Terminating-loops-with-return}
[]{#index-Loops_002c-terminating-with-return}
[]{#index-return-command-2}
[]{#index-return_002c-terminating-loops-with}

Suppose that a program is in the middle of a loop (or some nested loops)
in a complex function, and suddenly the function finds its answer. This
is where the `return` statement comes in handy. The `return` command
will jump out of any number of loops and pass the value back to the
calling function without having to finish the loops or the rest of the
function. (See section [Nested loops](#Nested-loops), for clarification
of the idea of placing one loop inside another.)

Example:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | #include <stdio.h>                |
|                                   |                                   |
|                                   | int main()                        |
|                                   | {                                 |
|                                   |   printf ("%d\n\n", returner(5, 1 |
|                                   | 0));                              |
|                                   |   printf ("%d\n\n", returner(5, 5 |
|                                   | 000));                            |
|                                   |   return 0;                       |
|                                   | }                                 |
|                                   |                                   |
|                                   |                                   |
|                                   | int returner (int foo, int bar)   |
|                                   | {                                 |
|                                   |   while (foo <= 1000)             |
|                                   |   {                               |
|                                   |     if (foo > bar)                |
|                                   |     {                             |
|                                   |       return (foo);               |
|                                   |     }                             |
|                                   |                                   |
|                                   |     foo++;                        |
|                                   |   }                               |
|                                   |                                   |
|                                   |   return foo;                     |
|                                   | }                                 |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

The function `returner` contains a `while` loop that increments the
variable `foo` and tests it against a value of 1000. However, if at any
point the value of `foo` exceeds the value of the variable `bar`, the
function will exit the loop, immediately returning the value of `foo` to
the calling function. Otherwise, when `foo` reaches 1000, the function
will increment `foo` one more time and return it to `main`.

Because of the values it passes to `returner`, the `main` function will
first print a value of 11, then 1001. Can you see why?

------------------------------------------------------------------------

[]{#Speeding-loops-with-continue}

  ------------------------------------------------------------------------------ --------------------------------------------------------- --- -------------------------------------------------------------------- -------------------------------------------------------- ----------------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Terminating-loops-with-return "Previous section in reading order")\]   \[[\>](#Nested-loops "Next section in reading order")\]       \[[\<\<](#Loops "Beginning of this chapter or previous chapter")\]   \[[Up](#Terminating-and-speeding-loops "Up section")\]   \[[\>\>](#Preprocessor-directives "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ------------------------------------------------------------------------------ --------------------------------------------------------- --- -------------------------------------------------------------------- -------------------------------------------------------- ----------------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Speeding-loops-with-continue-1}

### 11.5.3 Speeding loops with `continue` {#speeding-loops-with-continue .subsection}

[]{#index-Speeding-loops-1} []{#index-Optimizing-loops}
[]{#index-continue_002c-speeding-loops-with}
[]{#index-continue_002c-optimizing-loops-with}

Instead of terminating a loop, you might want to speed it to its next
pass, perhaps to avoid executing irrelevant statements. To do so, you
should use the `continue` statement. When a `continue` statement is
encountered, the program will skip the rest of the loop's code block and
jump straight to the start of the next pass through the loop.

Here is an example that uses the `continue` statement to avoid division
by zero (which causes a run-time error):

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | for (my_int = -10; my_int <= 10;  |
|                                   | my_int++)                         |
|                                   | {                                 |
|                                   |   if (my_int == 0)                |
|                                   |   {                               |
|                                   |     continue;                     |
|                                   |   }                               |
|                                   |                                   |
|                                   |   printf ("%d", 20/i);            |
|                                   | }                                 |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

------------------------------------------------------------------------

[]{#Nested-loops}

  ----------------------------------------------------------------------------- --------------------------------------------------------------------- --- -------------------------------------------------------------------- ------------------------------- ----------------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Speeding-loops-with-continue "Previous section in reading order")\]   \[[\>](#Questions-for-Chapter-11 "Next section in reading order")\]       \[[\<\<](#Loops "Beginning of this chapter or previous chapter")\]   \[[Up](#Loops "Up section")\]   \[[\>\>](#Preprocessor-directives "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ----------------------------------------------------------------------------- --------------------------------------------------------------------- --- -------------------------------------------------------------------- ------------------------------- ----------------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Nested-loops-1}

11.6 Nested loops {#nested-loops .section}
-----------------

[]{#index-Nested-loops} []{#index-Loops_002c-nested}
[]{#index-Multidimensional-arrays}
[]{#index-Arrays_002c-multidimensional}

Just as decisions can be nested, so can loops; that is, you can place
loops inside other loops. This can be useful, for example, when you are
coding multidimensional arrays. (See section [Arrays](#Arrays).)

The example below prints a square of asterisks by nesting a `printf`
command inside an *inner loop*, which is itself nested inside an *outer
loop*.

Any kind of loop can be nested. For example, the code below could have
been written with `while` loops instead of `for` loops:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | #include <stdio.h>                |
|                                   |                                   |
|                                   | #define SIZE 5                    |
|                                   |                                   |
|                                   | int main()                        |
|                                   | {                                 |
|                                   |   int square_y, square_x;         |
|                                   |                                   |
|                                   |   printf ("\n");                  |
|                                   |                                   |
|                                   |   for (square_y = 1; square_y <=  |
|                                   | SIZE; square_y++)                 |
|                                   |   {                               |
|                                   |     for (square_x = 1; square_x < |
|                                   | = SIZE; square_x++)               |
|                                   |     {                             |
|                                   |       printf("*");                |
|                                   |     }                             |
|                                   |     printf ("\n");                |
|                                   |   }                               |
|                                   |                                   |
|                                   |   printf ("\n");                  |
|                                   |   return 0;                       |
|                                   | }                                 |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

The output of the above code looks like this:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | *****                             |
|                                   | *****                             |
|                                   | *****                             |
|                                   | *****                             |
|                                   | *****                             |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

------------------------------------------------------------------------

[]{#Questions-for-Chapter-11}

  ------------------------------------------------------------- -------------------------------------------------------------------- --- -------------------------------------------------------------------- ------------------------------- ----------------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Nested-loops "Previous section in reading order")\]   \[[\>](#Preprocessor-directives "Next section in reading order")\]       \[[\<\<](#Loops "Beginning of this chapter or previous chapter")\]   \[[Up](#Loops "Up section")\]   \[[\>\>](#Preprocessor-directives "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ------------------------------------------------------------- -------------------------------------------------------------------- --- -------------------------------------------------------------------- ------------------------------- ----------------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Questions-for-Chapter-11-1}

11.7 Questions for Chapter 11 {#questions-for-chapter-11 .section}
-----------------------------

1.  How many kinds of loop does C offer, and what are they?
2.  When is the condition tested in each of the loops?
3.  Which of the loops is always executed at least once?
4.  Write a program that copies all input to output line by line.
5.  Write a program to get 10 numbers from the user and add them
    together.
6.  Rewrite the nested loops example to print a square with `while`
    loops instead of `for` loops.

------------------------------------------------------------------------

[]{#Preprocessor-directives}

  ------------------------------------------------------------------------- ------------------------------------------------------------- --- -------------------------------------------------------------------- ----------------------------- --------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Questions-for-Chapter-11 "Previous section in reading order")\]   \[[\>](#A-few-directives "Next section in reading order")\]       \[[\<\<](#Loops "Beginning of this chapter or previous chapter")\]   \[[Up](#Top "Up section")\]   \[[\>\>](#Libraries "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ------------------------------------------------------------------------- ------------------------------------------------------------- --- -------------------------------------------------------------------- ----------------------------- --------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Preprocessor-directives-1}

12. Preprocessor directives {#preprocessor-directives .chapter}
===========================

*Making programming versatile.*

[]{#index-Preprocessor} []{#index-Preprocessor-directives}
[]{#index-Directives_002c-preprocessor}

GCC, the GNU Compiler Collection, contains a C *preprocessor*. A
preprocessor is a program that examines C code before it is compiled and
manipulates it in various ways. There are two main uses of a
preprocessor. One is to include external files, such as header files.
The other is to define *macros*, which are names (possibly with
arguments) that are expanded by the preprocessor into pieces of text or
C code. Macros that are expanded into text are usually displayed to the
user, but macros that are expanded into C code are executed with the
rest of the C code that surrounds them.

  -------------------------------------------------------- ---- --
  [12.1 A few directives](#A-few-directives)                    
  [12.2 Macros](#Macros)                                        
  [12.3 Extended macro example](#Extended-macro-example)        
  [12.4 Questions](#Questions-12)                               
  -------------------------------------------------------- ---- --

------------------------------------------------------------------------

[]{#A-few-directives}

  ------------------------------------------------------------------------ --------------------------------------------------- --- -------------------------------------------------------------------------------------- ------------------------------------------------- --------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Preprocessor-directives "Previous section in reading order")\]   \[[\>](#Macros "Next section in reading order")\]       \[[\<\<](#Preprocessor-directives "Beginning of this chapter or previous chapter")\]   \[[Up](#Preprocessor-directives "Up section")\]   \[[\>\>](#Libraries "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ------------------------------------------------------------------------ --------------------------------------------------- --- -------------------------------------------------------------------------------------- ------------------------------------------------- --------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#A-few-directives-1}

12.1 A few directives {#a-few-directives .section}
---------------------

[]{#index-Preprocessor-directives-1}
[]{#index-Directives_002c-preprocessor-1}

All preprocessor `directives`, or commands, are preceded by a hash mark
('\#'). One example you have already seen in previous chapters is the
`#include` directive:

[]{#index-_0023include-preprocessor-directive}

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | #include <stdio.h>                |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

This directive tells the preprocessor to *include* the file '`stdio.h`';
in other words, to treat it as though it were part of the program text.

A file to be included may itself contain `#include` directives, thus
encompassing other files. When this happens, the included files are said
to be *nested*.

Here are a few other directives:

[]{#index-_0023if-preprocessor-directive}

`#if … #endif`

The `#if` directive is followed by an expression on the same line. The
lines of code between `#if` and `#endif` will be compiled only if the
expression is true. This is called *conditional compilation*.

[]{#index-_0023else-preprocessor-directive}

`#else`

This is part of an `#if` preprocessor statement and works in the same
way with `#if` that the regular C `else` does with the regular `if`.

[]{#index-_0023line-preprocessor-directive}

`#line constant filename`

This causes the compiler to act as though the next line is line number
constant and is part of the file filename. Mainly used for debugging.

[]{#index-_0023error-preprocessor-directive}

`#error`

This forces the compiler to abort. Also intended for debugging.

Below is an example of conditional compilation. The following code
displays '23' to the screen.

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | #include <stdio.h>                |
|                                   |                                   |
|                                   | #define CHOICE 500                |
|                                   |                                   |
|                                   | int my_int = 0;                   |
|                                   |                                   |
|                                   | #if (CHOICE == 500)               |
|                                   | void set_my_int()                 |
|                                   | {                                 |
|                                   |   my_int = 23;                    |
|                                   | }                                 |
|                                   | #else                             |
|                                   | void set_my_int()                 |
|                                   | {                                 |
|                                   |   my_int = 17;                    |
|                                   | }                                 |
|                                   | #endif                            |
|                                   |                                   |
|                                   | int main ()                       |
|                                   | {                                 |
|                                   |   set_my_int();                   |
|                                   |   printf("%d\n", my_int);         |
|                                   |                                   |
|                                   |   return 0;                       |
|                                   | }                                 |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

------------------------------------------------------------------------

[]{#Macros}

  ----------------------------------------------------------------- ------------------------------------------------------------ --- -------------------------------------------------------------------------------------- ------------------------------------------------- --------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#A-few-directives "Previous section in reading order")\]   \[[\>](#Macro-functions "Next section in reading order")\]       \[[\<\<](#Preprocessor-directives "Beginning of this chapter or previous chapter")\]   \[[Up](#Preprocessor-directives "Up section")\]   \[[\>\>](#Libraries "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ----------------------------------------------------------------- ------------------------------------------------------------ --- -------------------------------------------------------------------------------------- ------------------------------------------------- --------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Macros-1}

12.2 Macros {#macros .section}
-----------

[]{#index-Macros} []{#index-_0023define-preprocessor-directive}

Macros can make long, ungainly pieces of code into short words. The
simplest use of macros is to give constant values meaningful names. For
example:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | #define MY_PHONE 5551234          |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

This allows the programmer to use the word `MY_PHONE` to mean the number
5551234. In this case, the word is longer than the number, but it is
more meaningful and makes a program read more naturally. It can also be
centralised in a header file, where it is easily changed; this
eliminates tedious search-and-replace procedures on code if the value
appears frequently in the code. It has been said, with some humorous
exaggeration, that the only values that should appear "naked" in C code
instead of as macros or variables are 1 and 0.

The difference between defining a macro for 5551234 called `MY_PHONE`
and declaring a long integer variable called `my_phone` with the same
value is that the variable `my_phone` has the value 5551234 only
provisionally; it can be incremented with the statement `my_phone++;`,
for example. In some sense, however, the macro `MY_PHONE` *is* that
value, and *only* that value --- the C preprocessor simply searches
through the C code before it is compiled and replaces every instance of
`MY_PHONE` with `5551234`. Issuing the command `MY_PHONE++;` is no more
or less sensible than issuing the command `5551234++;`.

Any piece of C code can be made into a macro, Macros are not merely
constants referred to at compile time, but are strings that are
physically replaced with their values by the preprocessor before
compilation. For example:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | #define SUM 1 + 2 + 3 + 4         |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

would allow `SUM` to be used instead of `1 + 2 + 3 + 4`. Usually, this
would equal 10, so that in the statement `example1 = SUM + 10;`, the
variable `example1` equals 20. Sometimes, though, this macro will be
evaluated differently; for instance, in the statement
`example2 = SUM * 10;`, the variable `example2` equals 46, instead of
100, as you might think. Can you figure out why? Hint: it has to do with
the order of operations.

The quotation marks in the following macro allow the string to be called
by the identifier `SONG` instead of typing it out over and over. Because
the text '99 bottles of beer on the wall\...' is enclosed by double
quotation marks, it will never be interpreted as C code.

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | #define SONG "99 bottles of beer  |
|                                   | on the wall..."                   |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

Macros cannot define more than a single line, but they can be used
anywhere except inside strings. (Anything enclosed in string quotes is
assumed to be untouchable by the compiler.)

Some macros are defined already in the file '`stdio.h`', for example,
`NULL` (the value 0).

There are a few more directives for macro definition besides `#define`:
[]{#index-Preprocessor-directives-2}
[]{#index-Directives_002c-preprocessor-2}

[]{#index-_0023undef-preprocessor-directive}

`#undef`

This undefines a macro, leaving the name free.

[]{#index-_0023ifdef-preprocessor-directive}

`#ifdef`

This is a kind of `#if` that is followed by a macro name. If that macro
is defined then this directive is true. `#ifdef` works with `#else` in
the same way that `#if` does.

[]{#index-_0023ifndef-preprocessor-directive}

`#ifndef`

This is the opposite of `#ifdef`. It is also followed by a macro name.
If that name is not defined then this is true. It also works with
`#else`.

Here is a code example using some macro definition directives from this
section, and some conditional compilation directives from the last
section as well.

[]{#index-Preprocessor-directives_002c-example}
[]{#index-Directives_002c-preprocessor_002c-example}

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | #include <stdio.h>                |
|                                   |                                   |
|                                   | #define CHOICE 500                |
|                                   |                                   |
|                                   | int my_int = 0;                   |
|                                   |                                   |
|                                   | #undef CHOICE                     |
|                                   | #ifdef CHOICE                     |
|                                   | void set_my_int()                 |
|                                   | {                                 |
|                                   |   my_int = 23;                    |
|                                   | }                                 |
|                                   | #else                             |
|                                   | void set_my_int()                 |
|                                   | {                                 |
|                                   |   my_int = 17;                    |
|                                   | }                                 |
|                                   | #endif                            |
|                                   |                                   |
|                                   | int main ()                       |
|                                   | {                                 |
|                                   |   set_my_int();                   |
|                                   |   printf("%d\n", my_int);         |
|                                   |                                   |
|                                   |   return 0;                       |
|                                   | }                                 |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

The above code example displays '17' on the screen.

  -------------------------------------------- ---- --
  [12.2.1 Macro functions](#Macro-functions)        
  -------------------------------------------- ---- --

------------------------------------------------------------------------

[]{#Macro-functions}

  ------------------------------------------------------- ------------------------------------------------------------------- --- -------------------------------------------------------------------------------------- -------------------------------- --------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Macros "Previous section in reading order")\]   \[[\>](#Extended-macro-example "Next section in reading order")\]       \[[\<\<](#Preprocessor-directives "Beginning of this chapter or previous chapter")\]   \[[Up](#Macros "Up section")\]   \[[\>\>](#Libraries "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ------------------------------------------------------- ------------------------------------------------------------------- --- -------------------------------------------------------------------------------------- -------------------------------- --------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Macro-functions-1}

### 12.2.1 Macro functions {#macro-functions .subsection}

[]{#index-Macro-functions} []{#index-Functions_002c-macro}

Macros can also accept parameters and return values. Macros that do so
are called *macro functions*. To create a macro function, simply define
a macro with a parameter that has whatever name you like, such as
`my_val`. For example, one macro defined in the standard libraries is
`abs`, which returns the absolute value of its parameter. Let us define
our own version, `ABS`, below. (Note that we are defining it in upper
case not only to avoid conflicting with `abs`, but also because all
macros should be defined in upper case, in the GNU coding style. See
section [Style](#Style).)

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | #define ABS(my_val) ((my_val) < 0 |
|                                   | ) ? -(my_val) : (my_val)          |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

This macro uses the `?…:…` command to return a positive number no matter
what value is assigned to `my_val` --- if `my_val` is defined as a
positive number, the macro returns the same number, and if `my_val` is
defined as a negative number, the macro returns its negative (which will
be positive). (See section [Decisions](#Decisions), for more information
on the `?…:…` structure. If you write `ABS(-4)`, then the preprocessor
will substitute `-4` for `my_val`; if you write `ABS(i)`, then the
preprocessor will substitute `i` for `my_val`, and so on. Macros can
take more than one parameter, as in the code example below.

[]{#index-Macro-functions_002c-caveats}
[]{#index-Functions_002c-macro_002c-caveats}

One caveat: macros are substituted whole wherever they are used in a
program: this is potentially a huge amount of code repetition. The
advantage of a macro over an actual function, however, is speed. No time
is taken up in passing control to a new function, because control never
leaves the home function; the macro just makes the function a bit
longer.

A second caveat: function calls cannot be used as macro parameters. The
following code will not work:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | ABS (cos(36))                     |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

Here is an example of macro functions in use:

[]{#index-Macro-functions_002c-example}
[]{#index-Functions_002c-macro_002c-example}

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | #include <stdio.h>                |
|                                   |                                   |
|                                   | #define STRING1          "A macro |
|                                   |  definition\n"                    |
|                                   | #define STRING2          "must be |
|                                   |  all on one line!\n"              |
|                                   | #define EXPRESSION1      1 + 2 +  |
|                                   | 3 + 4                             |
|                                   | #define EXPRESSION2      EXPRESSI |
|                                   | ON1 + 10                          |
|                                   | #define ABS(x)           ((x) < 0 |
|                                   | ) ? -(x) : (x)                    |
|                                   | #define MAX(a,b)         (a < b)  |
|                                   | ?  (b) : (a)                      |
|                                   | #define BIGGEST(a,b,c)   (MAX(a,b |
|                                   | ) < c) ?  (c) : (MAX(a,b))        |
|                                   |                                   |
|                                   | int main ()                       |
|                                   | {                                 |
|                                   |   printf (STRING1);               |
|                                   |   printf (STRING2);               |
|                                   |   printf ("%d\n", EXPRESSION1);   |
|                                   |   printf ("%d\n", EXPRESSION2);   |
|                                   |   printf ("%d\n", ABS(-5));       |
|                                   |   printf ("Biggest of 1, 2, and 3 |
|                                   |  is %d\n", BIGGEST(1,2,3));       |
|                                   |                                   |
|                                   |   return 0;                       |
|                                   | }                                 |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

The output from the code example above is as follows:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | A macro definition                |
|                                   | must be all on one line!          |
|                                   | 10                                |
|                                   | 20                                |
|                                   | 5                                 |
|                                   | Biggest of 1, 2, and 3 is 3       |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

------------------------------------------------------------------------

[]{#Extended-macro-example}

  ---------------------------------------------------------------- --------------------------------------------------------- --- -------------------------------------------------------------------------------------- ------------------------------------------------- --------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Macro-functions "Previous section in reading order")\]   \[[\>](#Questions-12 "Next section in reading order")\]       \[[\<\<](#Preprocessor-directives "Beginning of this chapter or previous chapter")\]   \[[Up](#Preprocessor-directives "Up section")\]   \[[\>\>](#Libraries "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ---------------------------------------------------------------- --------------------------------------------------------- --- -------------------------------------------------------------------------------------- ------------------------------------------------- --------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Extended-macro-example-1}

12.3 Extended macro example {#extended-macro-example .section}
---------------------------

[]{#index-Macro-functions_002c-example-1}
[]{#index-Functions_002c-macro_002c-example-1}

Here are some examples of macros taken from actual working C code, in
this case the code of GNU Emacs, the text editor of choice for many C
programmers, and in fact the editor in which this edition of the book
was written.

Most of the macro examples below define various types of integer as
having certain sizes. It can be very useful when doing advanced C
programming to know whether a long integer, for instance, is 32 or 64
bits long on your system; if you select the wrong size, your code might
crash or might not even compile. In the case of Emacs, the maximum size
of certain variables (how many bits they contain) affects every aspect
of its operation, even determining how long an Emacs text file can be.

Each piece of code below is prefixed with the name of the file from
which the code is taken, and followed by a note on some interesting
features of the macros defined.

-   '`emacs/src/config.h`'

    +-----------------------------------+-----------------------------------+
    |                                   | ``` {.smallexample}               |
    |                                   | /* Note that lisp.h uses this in  |
    |                                   | a preprocessor conditional, so it |
    |                                   |    would not work to use sizeof.  |
    |                                   |  That being so, we do all of them |
    |                                   |    without sizeof, for uniformity |
    |                                   | 's sake.  */                      |
    |                                   | #ifndef BITS_PER_INT              |
    |                                   | #define BITS_PER_INT 32           |
    |                                   | #endif                            |
    |                                   |                                   |
    |                                   | #ifndef BITS_PER_LONG             |
    |                                   | #ifdef _LP64                      |
    |                                   | #define BITS_PER_LONG 64          |
    |                                   | #else                             |
    |                                   | #define BITS_PER_LONG 32          |
    |                                   | #endif                            |
    |                                   | #endif                            |
    |                                   | ```                               |
    +-----------------------------------+-----------------------------------+

    In the middle of this set of macros, from '`config.h`', the Emacs
    programmer used the characters '/\*' and '\*/' to create an ordinary
    C comment. C comments can be interspersed with macros freely.

    The macro `BITS_PER_INT` is defined here to be 32 (but only if it is
    not already defined, thanks to the `#ifndef` directive). The Emacs
    code will then treat integers as having 32 bits. (See section
    [Integer variables](#Integer-variables).)

    The second chunk of macro code in this example checks to see whether
    `BITS_PER_LONG` is defined. If it is not, but `_LP64` is defined, it
    defines `BITS_PER_LONG` to be 64, so that all long integers will be
    treated as having 64 bits. (`_LP64` is a GCC macro that is defined
    on 64-bit systems. It stands for "longs and pointers are 64 bits".)
    If `_LP64` is *not* present, the code assumes it is on a 32-bit
    system and defines `BITS_PER_LONG` to be 32.

-   '`emacs/src/lisp.h`'

    +-----------------------------------+-----------------------------------+
    |                                   | ``` {.smallexample}               |
    |                                   | /* These are default choices for  |
    |                                   | the types to use.  */             |
    |                                   | #ifdef _LP64                      |
    |                                   | #ifndef EMACS_INT                 |
    |                                   | #define EMACS_INT long            |
    |                                   | #define BITS_PER_EMACS_INT BITS_P |
    |                                   | ER_LONG                           |
    |                                   | #endif                            |
    |                                   | #ifndef EMACS_UINT                |
    |                                   | #define EMACS_UINT unsigned long  |
    |                                   | #endif                            |
    |                                   | #else /* not _LP64 */             |
    |                                   | #ifndef EMACS_INT                 |
    |                                   | #define EMACS_INT int             |
    |                                   | #define BITS_PER_EMACS_INT BITS_P |
    |                                   | ER_INT                            |
    |                                   | #endif                            |
    |                                   | #ifndef EMACS_UINT                |
    |                                   | #define EMACS_UINT unsigned int   |
    |                                   | #endif                            |
    |                                   | #endif                            |
    |                                   | ```                               |
    +-----------------------------------+-----------------------------------+

    This set of macros, from '`lisp.h`', again checks to see whether
    `_LP64` is defined. If it is, it defines `EMACS_INT` as `long` (if
    it is not already defined), and `BITS_PER_EMACS_INT` to be the same
    as `BITS_PER_LONG`, which was defined in '`config.h`', above. It
    then defines `EMACS_UINT` to be an `unsigned long`, if it is not
    already defined.

    If `_LP64` is *not* defined, it is assumed we are on a 32-bit
    system. `EMACS_INT` is defined to be an `int` if it is not already
    defined, and `EMACS_UINT` is defined to be an `unsigned int` if it
    is not already defined.

    Again, note that the programmer has freely interspersed a comment
    with the preprocessor code.

-   '`emacs/src/lisp.h`'

    +-----------------------------------+-----------------------------------+
    |                                   | ``` {.smallexample}               |
    |                                   | /* These values are overridden by |
    |                                   |  the m- file on some machines.  * |
    |                                   | /                                 |
    |                                   | #ifndef VALBITS                   |
    |                                   | #define VALBITS (BITS_PER_EMACS_I |
    |                                   | NT - 4)                           |
    |                                   | #endif                            |
    |                                   | ```                               |
    +-----------------------------------+-----------------------------------+

    Here is another example from '`lisp.h`'. The macro `VALBITS`, which
    defines another size of integer internal to Emacs, is defined as
    four less than `BITS_PER_EMACS_INT` --- that is, 60 on 64-bit
    systems, and 28 on 32-bit systems.

-   '`emacs/src/lisp.h`'

    +-----------------------------------+-----------------------------------+
    |                                   | ``` {.smallexample}               |
    |                                   | #ifndef XINT   /* Some machines n |
    |                                   | eed to do this differently.  */   |
    |                                   | #define XINT(a) ((EMACS_INT) (((a |
    |                                   | ) << (BITS_PER_EMACS_INT - VALBIT |
    |                                   | S)) \                             |
    |                                   |                                   |
    |                                   |   >> (BITS_PER_EMACS_INT - VALBIT |
    |                                   | S)))                              |
    |                                   | #endif                            |
    |                                   | ```                               |
    +-----------------------------------+-----------------------------------+

    The interesting feature of the `XINT` macro above is not only that
    it is a function, but that it is broken across multiple lines with
    the backslash character ('\\'). The GCC preprocessor simply deletes
    the backslash, deletes the preceding whitespace from the next line,
    and appends it where the backslash was. In this way, it is possible
    to treat long, multi-line macros as though they are actually on a
    single line. (See section [Advanced operators](#Advanced-operators),
    for more information on the the advanced operators `<<` and `>>`.)

------------------------------------------------------------------------

[]{#Questions-12}

  ----------------------------------------------------------------------- ------------------------------------------------------ --- -------------------------------------------------------------------------------------- ------------------------------------------------- --------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Extended-macro-example "Previous section in reading order")\]   \[[\>](#Libraries "Next section in reading order")\]       \[[\<\<](#Preprocessor-directives "Beginning of this chapter or previous chapter")\]   \[[Up](#Preprocessor-directives "Up section")\]   \[[\>\>](#Libraries "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ----------------------------------------------------------------------- ------------------------------------------------------ --- -------------------------------------------------------------------------------------- ------------------------------------------------- --------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Questions}

12.4 Questions {#questions .section}
--------------

1.  Define a macro called `BIRTHDAY` which equals the day of the month
    upon which your birthday falls.
2.  Write an instruction to the preprocessor to include the math library
    '`math.h`'.
3.  A macro is always a number. True or false?

------------------------------------------------------------------------

[]{#Libraries}

  ------------------------------------------------------------- --------------------------------------------------------- --- -------------------------------------------------------------------------------------- ----------------------------- ------------------------------------ --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Questions-12 "Previous section in reading order")\]   \[[\>](#Header-files "Next section in reading order")\]       \[[\<\<](#Preprocessor-directives "Beginning of this chapter or previous chapter")\]   \[[Up](#Top "Up section")\]   \[[\>\>](#Arrays "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ------------------------------------------------------------- --------------------------------------------------------- --- -------------------------------------------------------------------------------------- ----------------------------- ------------------------------------ --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Libraries-1}

13. Libraries {#libraries .chapter}
=============

*Plug-in C expansions. Header files.*

[]{#index-Libraries}

The core of the C language is small and simple, but special
functionality is provided in the form of *external libraries* of
ready-made functions. Standardized libraries make C code extremely
*portable*, or easy to compile on many different computers.

Libraries are files of ready-compiled code that the compiler merges, or
*links*, with a C program during compilation. For example, there are
libraries of mathematical functions, string handling functions, and
input/output functions. Indeed, most of the facilities C offers are
provided as libraries.

Some libraries are provided for you. You can also make your own, but to
do so, you will need to know how GNU builds libraries. We will discuss
that later. (See section [Building a library](#Building-a-library).)

Most C programs include at least one library. You need to ensure both
that the library is linked to your program and that its header files are
included in your program.

[]{#index-glibc-library}

The standard C library, or '`glibc`', is linked automatically with every
program, but header files are never included automatically, so you must
always include them yourself. Thus, you must always include '`stdio.h`'
in your program if you intend to use the standard input/output features
of C, even though '`glibc`', which contains the input/output routines,
is linked automatically.

[]{#index-Libraries_002c-linking-to-your-code}
[]{#index-Linking-libraries-to-your-code}

Other libraries, however, are not linked automatically. You must link
them to your program yourself. For example, to link the math library
'`libm.so`', type

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | gcc -o program_name program_name. |
|                                   | c -lm                             |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

The command-line option to link '`libm.so`' is simply '-lm', without the
'lib' or the '.so', or in the case of static libraries, '.a'. (See
section [Kinds of library](#Kinds-of-library).)

The '-l' option was created because the average GNU system already has
many libraries, and more can be added at any time. This means that
sometimes two libraries provide alternate definitions of the same
function. With judicious use of the '-l' option, however, you can
usually clarify to the compiler which definition of the function should
be used. Libraries specified earlier on the command line take precedence
over those defined later, and code from later libraries is only linked
in if it matches a *reference* (function definition, macro, global
variable, etc.) that is still undefined. (See section [Compiling
multiple files](#Compiling-multiple-files), for more information.)

In summary, you must always do two things:

-   link the library with a '-l' option to gcc (a step that may be
    skipped in the case of '`glibc`').
-   include the library header files (a step you must always follow,
    even for '`glibc`').

  ------------------------------------------------------------ ---- --
  [13.1 Header files](#Header-files)                                
  [13.2 Kinds of library](#Kinds-of-library)                        
  [13.3 Common library functions](#Common-library-functions)        
  [13.4 Mathematical functions](#Mathematical-functions)            
  [13.5 Questions for Chapter 13](#Questions-for-Chapter-13)        
  ------------------------------------------------------------ ---- --

------------------------------------------------------------------------

[]{#Header-files}

  ---------------------------------------------------------- ------------------------------------------------------------- --- ------------------------------------------------------------------------ ----------------------------------- ------------------------------------ --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Libraries "Previous section in reading order")\]   \[[\>](#Kinds-of-library "Next section in reading order")\]       \[[\<\<](#Libraries "Beginning of this chapter or previous chapter")\]   \[[Up](#Libraries "Up section")\]   \[[\>\>](#Arrays "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ---------------------------------------------------------- ------------------------------------------------------------- --- ------------------------------------------------------------------------ ----------------------------------- ------------------------------------ --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Header-files-1}

13.1 Header files {#header-files .section}
-----------------

[]{#index-Header-files} []{#index-Files_002c-header}

As mentioned above, libraries have *header files* that define
information to be used in conjunction with the libraries, such as
functions and data types. When you include a header file, the compiler
adds the functions, data types, and other information in the header file
to the list of reserved words and commands in the language. After that,
you cannot use the names of functions or macros in the header file to
mean anything other than what the library specifies, in any source code
file that includes the header file.

[]{#index-glibc-library-1} []{#index-stdio_002eh-header-file}

The most commonly used header file is for the standard input/output
routines in '`glibc`' and is called '`stdio.h`'. This and other header
files are included with the `#include` command at the top of a source
code file. For example,

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | #include "name.h"                 |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

includes a header file from the current directory (the directory in
which your C source code file appears), and

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | #include <name.h>                 |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

[]{#index-_002fusr_002finclude-directory}

includes a file from a *system directory* --- a standard GNU directory
like '`/usr/include`'. (The `#include` command is actually a
*preprocessor directive*, or instruction to a program used by the C
compiler to simplify C code. (See section [Preprocessor
directives](#Preprocessor-directives), for more information.)

Here is an example that uses the `#include` directive to include the
standard '`stdio.h`' header in order to print a greeting on the screen
with the `printf` command. (The characters '\\n' cause `printf` to move
the cursor to the next line.)

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | #include <stdio.h>                |
|                                   |                                   |
|                                   | int main ()                       |
|                                   | {                                 |
|                                   |   printf ("C standard I/O file is |
|                                   |  included.\n");                   |
|                                   |   printf ("Hello world!\n");      |
|                                   |                                   |
|                                   |   return 0;                       |
|                                   | }                                 |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

If you save this code in a file called '`hello.c`', you can compile this
program with the following command:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | gcc -o hello hello.c              |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

As mentioned earlier, you can use some library functions without having
to link library files explicitly, since every program is always linked
with the *standard C library*. This is called '`libc`' on older
operating systems such as Unix, but '`glibc`' ("GNU libc") on GNU
systems. The '`glibc`' file includes standard functions for
input/output, date and time calculation, string manipulation, memory
allocation, mathematics, and other language features.

Most of the standard '`glibc`' functions can be incorporated into your
program just by using the `#include` directive to include the proper
header files. For example, since '`glibc`' includes the standard
input/output routines, all you need to do to be able to call `printf` is
put the line `#include <stdio.h>` at the beginning of your program, as
in the example that follows.

Note that '`stdio.h`' is just one of the many header files you will
eventually use to access '`glibc`'. The GNU C library is automatically
linked with every C program, but you will eventually need a variety of
header files to access it. These header files are not included in your
code automatically --- you must include them yourself!

[]{#index-math_002eh-header-file}

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | #include <stdio.h>                |
|                                   | #include <math.h>                 |
|                                   |                                   |
|                                   | int main ()                       |
|                                   | {                                 |
|                                   |   double x, y;                    |
|                                   |                                   |
|                                   |   y = sin (x);                    |
|                                   |   printf ("Math library ready\n") |
|                                   | ;                                 |
|                                   |                                   |
|                                   |   return 0;                       |
|                                   | }                                 |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

[]{#index-sin-function}

However, programs that use a special function outside of '`glibc`' ---
including mathematical functions that are nominally part of '`glibc`',
such as function `sin` in the example above! --- must use the '-l'
option to `gcc` in order to link the appropriate libraries. If you saved
this code above in a file called '`math.c`', you could compile it with
the following command:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | gcc -o math math.c -lm            |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

The option '-lm' links in the library '`libm.so`', which is where the
mathematics routines are actually located on a GNU system.

To learn which header files you must include in your program in order to
use the features of '`glibc`' that interest you, consult
[(libc)Top](libc.html#Top) section 'Table of Contents' in The GNU C
Library Reference Manual. This document lists all the functions, data
types, and so on contained in '`glibc`', arranged by topic and header
file. (See section [Common library
functions](#Common-library-functions), for a partial list of these
header files.)

**Note:** Strictly speaking, you need not always use a system header
file to access the functions in a library. It is possible to write your
own declarations that mimic the ones in the standard header files. You
might want to do this if the standard header files are too large, for
example. In practice, however, this rarely happens, and this technique
is better left to advanced C programmers; using the header files that
came with your GNU system is a more reliable way to access libraries.

  ------------------------------------------------------------ ---- --
  [13.2 Kinds of library](#Kinds-of-library)                        
  [13.3 Common library functions](#Common-library-functions)        
  [13.5 Questions for Chapter 13](#Questions-for-Chapter-13)        
  ------------------------------------------------------------ ---- --

------------------------------------------------------------------------

[]{#Kinds-of-library}

  ------------------------------------------------------------- --------------------------------------------------------------------- --- ------------------------------------------------------------------------ ----------------------------------- ------------------------------------ --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Header-files "Previous section in reading order")\]   \[[\>](#Common-library-functions "Next section in reading order")\]       \[[\<\<](#Libraries "Beginning of this chapter or previous chapter")\]   \[[Up](#Libraries "Up section")\]   \[[\>\>](#Arrays "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ------------------------------------------------------------- --------------------------------------------------------------------- --- ------------------------------------------------------------------------ ----------------------------------- ------------------------------------ --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Kinds-of-library-1}

13.2 Kinds of library {#kinds-of-library .section}
---------------------

[]{#index-Kinds-of-library} []{#index-Library_002c-kinds-of}
[]{#index-Static-libraries} []{#index-Shared-libraries}
[]{#index-Libraries_002c-static} []{#index-Libraries_002c-shared}

There are two kinds of library: *static libraries* and *shared
libraries*. When you link to a static library, the code for the entire
library is merged with the object code for your program. If you link to
many static libraries, your executable will be enormous.

Shared libraries were developed in the late 1980s to reduce the code
size of programs on operating systems like GNU. When you link to a
shared library, the library's code is not merged with your program's
object code. Instead, *stub code* is inserted into your object code. The
stub code is very small and merely calls the functions in the shared
library --- the operating system does the rest. An executable created
with a shared library can therefore be far smaller than one created with
a static library. Shared libraries can also reduce the amount of memory
used.

Although shared libraries seem to have every advantage over static
libraries, static libraries are still useful. For example, sometimes you
will wish to distribute an executable to people whose computers do not
have the libraries that yours does. In that case, you might link to a
static version of the libraries. This will incorporate the library
functions that you need into your executable, so that it will run on
systems that don't have those libraries. (It is also sometimes easier to
debug a program that is linked to static libraries than one linked to
shared libraries. See section [Introduction to
GDB](#Introduction-to-GDB), for more information.)

[]{#index-_002ea-file-suffix-1} []{#index-_002eso-file-suffix-1}

The file name for a library always starts with 'lib' and ends with
either '.a' (if it is static) or '.so' (if it is shared). For example,
'`libm.a`' is the static version of the C math library, and '`libm.so`'
is the shared version. As explained above, you must use the '-l' option
with the name of a library, minus its 'lib' prefix and '.a' or '.so'
suffix, to link that library to your program (except the library
'`glibc`', which is always linked). For example, the following shell
command creates an executable program called '`math`' from the source
code file '`math.c`' and the library '`libm.so`'.

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | gcc -o math math.c -lm            |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

The shared version of the library is always linked by default. If you
want to link the static version of the library, you must use the GCC
option '\--static'. The following example links '`libm.a`' instead of
'`libm.so`'.

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | gcc -o math math.c -lm --static   |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

Type 'info gcc' at your shell prompt for more information about GCC
options.

------------------------------------------------------------------------

[]{#Common-library-functions}

  ----------------------------------------------------------------- --------------------------------------------------------------- --- ------------------------------------------------------------------------ ----------------------------------- ------------------------------------ --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Kinds-of-library "Previous section in reading order")\]   \[[\>](#Character-handling "Next section in reading order")\]       \[[\<\<](#Libraries "Beginning of this chapter or previous chapter")\]   \[[Up](#Libraries "Up section")\]   \[[\>\>](#Arrays "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ----------------------------------------------------------------- --------------------------------------------------------------- --- ------------------------------------------------------------------------ ----------------------------------- ------------------------------------ --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Common-library-functions-1}

13.3 Common library functions {#common-library-functions .section}
-----------------------------

*Checking character types. Handling strings. Doing maths.*

[]{#index-Common-library-functions}
[]{#index-Library-functions_002c-common}
[]{#index-Functions_002c-common-library}

The libraries in GCC contain a repertoire of standard functions and
macros. There are many different kinds of function and macro in the
libraries. Here are a few of the different kinds available, with the
header files you can use to access them:

[]{#index-ctype_002eh-header-file} []{#index-math_002eh-header-file-1}
[]{#index-string_002eh-header-file}

-   Character handling: '`ctype.h`'
-   Mathematics: '`math.h`'
-   String manipulation: '`string.h`'

[]{#index-_002fusr_002finclude-directory-1}
[]{#index-_002fusr_002finclude_002flinux-directory}
[]{#index-_002dI-option-of-GCC}

You may find it useful to read the header files yourself. They are
usually found in the directories '`/usr/include`' and its subdirectories
on GNU/Linux systems. The three header files listed above can be found
in '`/usr/include`'; there is a second version of '`ctype.h`' in
'`/usr/include/linux`'.[(3)](#FOOT3){#DOCF3}

  -------------------------------------------------- ---- --
  [13.3.1 Character handling](#Character-handling)        
  -------------------------------------------------- ---- --

------------------------------------------------------------------------

[]{#Character-handling}

  ------------------------------------------------------------------------- ------------------------------------------------------------------- --- ------------------------------------------------------------------------ -------------------------------------------------- ------------------------------------ --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Common-library-functions "Previous section in reading order")\]   \[[\>](#Mathematical-functions "Next section in reading order")\]       \[[\<\<](#Libraries "Beginning of this chapter or previous chapter")\]   \[[Up](#Common-library-functions "Up section")\]   \[[\>\>](#Arrays "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ------------------------------------------------------------------------- ------------------------------------------------------------------- --- ------------------------------------------------------------------------ -------------------------------------------------- ------------------------------------ --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Character-handling-1}

### 13.3.1 Character handling {#character-handling .subsection}

[]{#index-Character-handling} []{#index-glibc-library-2}
[]{#index-ctype_002eh-header-file-1}

Let's examine some simple library functions and see how they are used.
Some of the functions that are available on GNU systems for handling
individual characters are described below. They are all macros, so the
usual caveats about macro parameters apply. (See section [Macro
functions](#Macro-functions).) All of the functions below accept single
variables of type `char` as parameters. To use any of them, you must
include the system header file '`ctype.h`'; the library used is simply
`glibc`, which is linked automatically.

[]{#index-isalnum-function}

`isalnum`

Returns true if and only if the parameter is alphanumeric: that is, an
alphabetic character (see `isalpha`) or a digit (see `isdigit`).

[]{#index-isalpha-function}

`isalpha`

Returns true if and only if the parameter is alphabetic. An *alphabetic*
character is any character from 'A' through 'Z' or 'a' through 'z'.

[]{#index-isascii-function}

`isascii`

Returns true if and only if the parameter is a valid ASCII character:
that is, it has an integer value in the range 0 through 127. (Remember,
the `char` type in C is actually a kind of integer!)

[]{#index-iscntrl-function}

`iscntrl`

Returns true if and only if the parameter is a control character.
Control characters vary from system to system, but are usually defined
as characters in the range 0 to 31.

[]{#index-isdigit-function}

`isdigit`

Returns true if and only if the parameter is a digit in the range 0
through 9.

[]{#index-isgraph-function}

`isgraph`

Returns true if and only if the parameter is graphic: that is, if the
character is either alphanumeric (see `isalnum`) or punctuation (see
`ispunct`). All graphical characters are valid ASCII characters, but
ASCII also includes non-graphical characters such as control characters
(see `iscntrl`) and whitespace (see `isspace`).

[]{#index-islower-function}

`islower`

Returns true if and only if the parameter is a lower-case alphabetic
character (see `isalpha`).

[]{#index-isprint-function}

`isprint`

Returns true if and only if the parameter is a printable character: that
is, the character is either graphical (see `isgraph`) or a space
character.

[]{#index-ispunct-function}

`ispunct`

Returns true if and only if the parameter is a punctuation character.

[]{#index-isspace-function}

`isspace`

Returns true if and only if the parameter is a whitespace character.
What is defined as whitespace varies from system to system, but it
usually includes space characters and tab characters, and sometimes
newline characters.

[]{#index-isupper-function}

`isupper`

Returns true if and only if the parameter is an upper-case alphabetic
character (see `isalpha`).

[]{#index-isxdigit-function}

`isxdigit`

Returns true if and only if the parameter is a valid hexadecimal digit:
that is, a decimal digit (see `isdigit`), or a letter from 'a' through
'f' or 'A' through 'F'.

[]{#index-toascii-function}

`toascii`

Returns the parameter stripped of its eighth bit, so that it has an
integer value from 0 through 127 and is therefore a valid ASCII
character. (See `isascii`.)

[]{#index-tolower-function}

`tolower`

Converts a character into its lower-case counterpart. Does not affect
characters which are already in lower case.

[]{#index-toupper-function}

`toupper`

Converts a character into its upper-case counterpart. Does not affect
characters which are already in upper case.

[]{#index-Character-functions_002c-example-of}

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | /******************************** |
|                                   | ************************/         |
|                                   | /*                                |
|                                   |                        */         |
|                                   | /* Demonstration of character uti |
|                                   | lity functions         */         |
|                                   | /*                                |
|                                   |                        */         |
|                                   | /******************************** |
|                                   | ************************/         |
|                                   |                                   |
|                                   | #include <stdio.h>                |
|                                   | #include <ctype.h>                |
|                                   |                                   |
|                                   | #define  allchars    ch = 0; isas |
|                                   | cii(ch); ch++                     |
|                                   |                                   |
|                                   | int main ()           /* A crimin |
|                                   | ally long main program! */        |
|                                   |                                   |
|                                   | {                                 |
|                                   |   char ch;                        |
|                                   |                                   |
|                                   |   printf ("\n\nVALID CHARACTERS F |
|                                   | ROM isgraph:\n\n");               |
|                                   |   for (allchars)                  |
|                                   |     {                             |
|                                   |       if (isgraph(ch))            |
|                                   |     {                             |
|                                   |       printf ("%c ",ch);          |
|                                   |     }                             |
|                                   |     }                             |
|                                   |                                   |
|                                   |   printf ("\n\nVALID CHARACTERS F |
|                                   | ROM isalnum:\n\n");               |
|                                   |   for (allchars)                  |
|                                   |     {                             |
|                                   |       if (isalnum(ch))            |
|                                   |     {                             |
|                                   |       printf ("%c ",ch);          |
|                                   |     }                             |
|                                   |     }                             |
|                                   |                                   |
|                                   |   printf ("\n\nVALID CHARACTERS F |
|                                   | ROM isalpha:\n\n");               |
|                                   |   for (allchars)                  |
|                                   |     {                             |
|                                   |       if (isalpha(ch))            |
|                                   |     {                             |
|                                   |       printf ("%c ",ch);          |
|                                   |     }                             |
|                                   |     }                             |
|                                   |                                   |
|                                   |   printf ("\n\nVALID CHARACTERS F |
|                                   | ROM isupper:\n\n");               |
|                                   |   for (allchars)                  |
|                                   |     {                             |
|                                   |       if (isupper(ch))            |
|                                   |     {                             |
|                                   |       printf ("%c ",ch);          |
|                                   |     }                             |
|                                   |     }                             |
|                                   |                                   |
|                                   |   printf ("\n\nVALID CHARACTERS F |
|                                   | ROM islower:\n\n");               |
|                                   |   for (allchars)                  |
|                                   |     {                             |
|                                   |       if (islower(ch))            |
|                                   |     {                             |
|                                   |       printf ("%c ",ch);          |
|                                   |     }                             |
|                                   |     }                             |
|                                   |                                   |
|                                   |   printf ("\n\nVALID CHARACTERS F |
|                                   | ROM isdigit:\n\n");               |
|                                   |   for (allchars)                  |
|                                   |     {                             |
|                                   |       if (isdigit(ch))            |
|                                   |     {                             |
|                                   |       printf ("%c ",ch);          |
|                                   |     }                             |
|                                   |     }                             |
|                                   |                                   |
|                                   |   printf ("\n\nVALID CHARACTERS F |
|                                   | ROM isxdigit:\n\n");              |
|                                   |   for (allchars)                  |
|                                   |     {                             |
|                                   |       if (isxdigit(ch))           |
|                                   |     {                             |
|                                   |       printf ("%c ",ch);          |
|                                   |     }                             |
|                                   |     }                             |
|                                   |                                   |
|                                   |   printf ("\n\nVALID CHARACTERS F |
|                                   | ROM ispunct:\n\n");               |
|                                   |   for (allchars)                  |
|                                   |     {                             |
|                                   |       if (ispunct(ch))            |
|                                   |     {                             |
|                                   |       printf ("%c ",ch);          |
|                                   |     }                             |
|                                   |     }                             |
|                                   |                                   |
|                                   |   printf ("\n\n");                |
|                                   |                                   |
|                                   |   return 0;                       |
|                                   | }                                 |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

The output of the above code example is as follows:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | VALID CHARACTERS FROM isgraph:    |
|                                   |                                   |
|                                   | ! " # $ % & ' ( ) * + , - . / 0 1 |
|                                   |  2 3 4 5 6 7 8 9 : ; < = > ? @ A  |
|                                   | B C D                             |
|                                   | E F G H I J K L M N O P Q R S T U |
|                                   |  V W X Y Z [ \ ] ^ _ ` a b c d e  |
|                                   | f g h                             |
|                                   | i j k l m n o p q r s t u v w x y |
|                                   |  z { | } ~                        |
|                                   |                                   |
|                                   | VALID CHARACTERS FROM isalnum:    |
|                                   |                                   |
|                                   | 0 1 2 3 4 5 6 7 8 9 A B C D E F G |
|                                   |  H I J K L M N O P Q R S T U V W  |
|                                   | X Y Z                             |
|                                   | a b c d e f g h i j k l m n o p q |
|                                   |  r s t u v w x y z                |
|                                   |                                   |
|                                   | VALID CHARACTERS FROM isalpha:    |
|                                   |                                   |
|                                   | A B C D E F G H I J K L M N O P Q |
|                                   |  R S T U V W X Y Z a b c d e f g  |
|                                   | h i j                             |
|                                   | k l m n o p q r s t u v w x y z   |
|                                   |                                   |
|                                   | VALID CHARACTERS FROM isupper:    |
|                                   |                                   |
|                                   | A B C D E F G H I J K L M N O P Q |
|                                   |  R S T U V W X Y Z                |
|                                   |                                   |
|                                   | VALID CHARACTERS FROM islower:    |
|                                   |                                   |
|                                   | a b c d e f g h i j k l m n o p q |
|                                   |  r s t u v w x y z                |
|                                   |                                   |
|                                   | VALID CHARACTERS FROM isdigit:    |
|                                   |                                   |
|                                   | 0 1 2 3 4 5 6 7 8 9               |
|                                   |                                   |
|                                   | VALID CHARACTERS FROM isxdigit:   |
|                                   |                                   |
|                                   | 0 1 2 3 4 5 6 7 8 9 A B C D E F a |
|                                   |  b c d e f                        |
|                                   |                                   |
|                                   | VALID CHARACTERS FROM ispunct:    |
|                                   |                                   |
|                                   | ! " # $ % & ' ( ) * + , - . / : ; |
|                                   |  < = > ? @ [ \ ] ^ _ ` { | } ~    |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

------------------------------------------------------------------------

[]{#Mathematical-functions}

  ------------------------------------------------------------------- --------------------------------------------------------------------- --- ------------------------------------------------------------------------ ----------------------------------- ------------------------------------ --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Character-handling "Previous section in reading order")\]   \[[\>](#Questions-for-Chapter-13 "Next section in reading order")\]       \[[\<\<](#Libraries "Beginning of this chapter or previous chapter")\]   \[[Up](#Libraries "Up section")\]   \[[\>\>](#Arrays "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ------------------------------------------------------------------- --------------------------------------------------------------------- --- ------------------------------------------------------------------------ ----------------------------------- ------------------------------------ --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Mathematical-functions-1}

13.4 Mathematical functions {#mathematical-functions .section}
---------------------------

[]{#index-Mathematical-function} []{#index-Functions_002c-mathematical}

Let us now examine some simple math library functions. (This section
presupposes some familiarity on your part with trigonometry. If you have
none, you might want to skip this section for now -- but reading it
won't hurt you!)

The following mathematical functions, among others, are available on GNU
systems. Many of the functions described below are macros, so the usual
caveats about macro parameters apply. (See section [Macro
functions](#Macro-functions).) All of these functions require parameters
of type `double` or `long float`. Constants used must be written in
floating point form: for instance, write '7.0' instead of just '7'.

[]{#index-math_002eh-header-file-2} []{#index-tgmath_002eh-header-file}
[]{#index-limits_002eh-header-file}

Here is a list of some functions you can expect to find in the headers
'`math.h`', '`tgmath.h`', and '`limits.h`'.

[]{#index-abs-function}

`abs`

Returns the unsigned value of the parameter in brackets. This function
is a macro; see `fabs` for a proper function version.

[]{#index-acos-function}

`acos`

Returns the arccosine (or inverse cosine) of the parameter, which must
lie between -1.0 and +1.0 inclusive. (The result is always in radians.)

[]{#index-asin-function}

`asin`

Returns the arcsine (or inverse sine) of the parameter, which must lie
between -1.0 and +1.0 inclusive. (The result is always in radians.)

[]{#index-atan-function}

`atan`

Returns the arctangent (or inverse tangent) of the parameter. (The
result is always in radians.)

[]{#index-atan2-function}

`atan2`

This is a special function for calculating the inverse tangent of the
second parameter divided by the first. `atan2` will find the result more
accurately than `atan` will.

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | result = atan2 (x, y);            |
|                                   | result = atan2 (x, 3.14);         |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

[]{#index-ceil-function}

`ceil`

Returns the ceiling for the parameter: that is, the integer just above
it. In effect, rounds the parameter up.

[]{#index-cos-function}

`cos`

Returns the cosine of the parameter in radians. (The parameter is also
assumed to be specified in radians.)

[]{#index-cosh-function}

`cosh`

Returns the hyperbolic cosine of the parameter.

[]{#index-exp-function}

`exp`

Returns the exponential function of the parameter (i.e. *e* to the power
of the parameter).

[]{#index-fabs-function}

`fabs`

Returns the absolute or unsigned value of the parameter in brackets.
This is the version that is a proper function; see `abs` if you want one
that is a macro.

[]{#index-floor-function}

`floor`

Returns the floor for the parameter: that is, the integer just below it.
In effect, rounds the parameter down to the nearest integer value, i.e.
truncates it.

[]{#index-log-function}

`log`

Returns the natural logarithm of the parameter. The parameter used must
be greater than zero, but does not have to be declared as unsigned.

[]{#index-log10-function}

`log10`

Returns the base 10 logarithm of the parameter. The parameter used must
be greater than zero, but does not have to be declared as unsigned.

[]{#index-pow-function}

`pow`

Returns the first parameter raised to the power of the second.

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | result = pow (x,y); /*raise x to  |
|                                   | the power y */                    |
|                                   | result = pow (x,2); /* square x * |
|                                   | /                                 |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

[]{#index-sin-function-1}

`sin`

Returns the sine of the parameter in radians. (The parameter is also
assumed to be specified in radians.)

[]{#index-sinh-function}

`sinh`

Returns the hyperbolic sine of the parameter. (Pronounced "shine" or
"sinch".)

[]{#index-sqrt-function-1}

`sqrt`

Returns the positive square root of the parameter.

[]{#index-tan-function}

`tan`

Returns the tangent of the parameter in radians. (The parameter is also
assumed to be specified in radians.)

[]{#index-tanh-function}

`tanh`

Returns the hyperbolic tangent of the parameter.

Here is a code example that uses a few of the math library routines
listed above.

[]{#index-Math-functions_002c-example-of}

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | #include <stdio.h>                |
|                                   | #include <math.h>                 |
|                                   |                                   |
|                                   | int main()                        |
|                                   | {                                 |
|                                   |   double my_pi;                   |
|                                   |                                   |
|                                   |   my_pi = 4 * atan(1.0);          |
|                                   |                                   |
|                                   |   /* Print the value of pi we jus |
|                                   | t calculated, to 32 digits. */    |
|                                   |   printf ("my_pi = %.32f\n", my_p |
|                                   | i);                               |
|                                   |                                   |
|                                   |   /* Print value of pi from math  |
|                                   | library, to 32 digits. */         |
|                                   |   printf ("M_PI  = %.32f\n", M_PI |
|                                   | );                                |
|                                   |                                   |
|                                   |   return 0;                       |
|                                   | }                                 |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

If you save the above example as '`pi.c`', you will have to enter a
command such as the one below to compile it.

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | gcc pi.c -o pi -lm                |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

When you compile and run the code example, it should print the following
results:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | my_pi = 3.14159265358979311599796 |
|                                   | 346854419                         |
|                                   | M_PI  = 3.14159265358979311599796 |
|                                   | 346854419                         |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

------------------------------------------------------------------------

[]{#Questions-for-Chapter-13}

  ----------------------------------------------------------------------- --------------------------------------------------- --- ------------------------------------------------------------------------ ----------------------------------- ------------------------------------ --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Mathematical-functions "Previous section in reading order")\]   \[[\>](#Arrays "Next section in reading order")\]       \[[\<\<](#Libraries "Beginning of this chapter or previous chapter")\]   \[[Up](#Libraries "Up section")\]   \[[\>\>](#Arrays "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ----------------------------------------------------------------------- --------------------------------------------------- --- ------------------------------------------------------------------------ ----------------------------------- ------------------------------------ --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Questions-for-Chapter-13-1}

13.5 Questions for Chapter 13 {#questions-for-chapter-13 .section}
-----------------------------

1.  How do you incorporate a library file into a C program?
2.  Name the most commonly used library file in C.
3.  Is it possible to define new functions with the same names as
    standard library functions?
4.  What type of data is returned from mathematical functions?
5.  True or false? All mathematical calculations are performed using
    doubles.
6.  Name five kinds of error which can occur in a mathematical function.

------------------------------------------------------------------------

[]{#Arrays}

  ------------------------------------------------------------------------- --------------------------------------------------------- --- ------------------------------------------------------------------------ ----------------------------- ------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Questions-for-Chapter-13 "Previous section in reading order")\]   \[[\>](#Array-bounds "Next section in reading order")\]       \[[\<\<](#Libraries "Beginning of this chapter or previous chapter")\]   \[[Up](#Top "Up section")\]   \[[\>\>](#Strings "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ------------------------------------------------------------------------- --------------------------------------------------------- --- ------------------------------------------------------------------------ ----------------------------- ------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Arrays-1}

14. Arrays {#arrays .chapter}
==========

*Rows and tables of storage.*

[]{#index-Arrays}

Suppose you have a long list of numbers, but you don't want to assign
them to variables individually. For example, you are writing a simple
program for a restaurant to keep a list of the amount each diner has on
his or her tab, but you don't want to go through the tedium of writing a
list like the following:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | float alfies_tab, bettys_tab, cha |
|                                   | rlies_tab …;                      |
|                                   |                                   |
|                                   | alfies_tab = 88.33;               |
|                                   | bettys_tab = 17.23;               |
|                                   | charlies_tab = 55.55;             |
|                                   | etc.                              |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

A list like that could run to hundreds or thousands of entries, and for
each diner you'd have to write "special-case" code referring to every
diner's data individually. No, what you really want is a single table in
which you can find the tab corresponding to a particular diner. You can
then look up the tab of the diner with dining club card number 7712 in
row number 7712 of the table much more easily.

[]{#index-Arrays_002c-multidimensional-1}

This is why arrays were invented. Arrays are a convenient way to group
many variables under a single variable name. They are like pigeonholes,
with each compartment storing a single value. Arrays can be
one-dimensional like a list, two-dimensional like a chessboard, or
three-dimensional like an apartment building --- in fact, they can have
any arbitrary dimensionality, including ones humans cannot visualise
easily.

[]{#index-Arrays_002c-defining}

An array is defined using square brackets `[…]`. For example: an array
of three integers called `my_list` would be declared thus:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | int my_list[3];                   |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

This statement would cause space for three adjacent integers to be
created in memory, as in the diagram below. Notice that there is no
space between the name of the array above (`my_array`) and the opening
square bracket '\['.

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   |           ----------------------- |
|                                   | -------------                     |
|                                   | my_list: |           |            |
|                                   | |            |                    |
|                                   |           ----------------------- |
|                                   | -------------                     |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

The number in the square brackets of the declaration is referred to as
the *subscript* of the array, and it must be an integer greater than or
equal to zero.

The three integer "pigeonholes" in the above array are called its
*locations*, and the values filling them are called the array's
*elements*. The position of an element in the array is called its
*index* (the plural is *indices*). In the following example, 5, 17, and
23 are the array's elements, and 0, 1, and 2 are its corresponding
indices.

[]{#index-Zero_002dbased-arrays-in-C}
[]{#index-Arrays_002c-zero_002dbased-nature-of}
[]{#index-One_002dbased-arrays} []{#index-Arrays_002c-one_002dbased}

Notice also that although we are creating space for three integers,
arrays in C are *zero-based*, so the indices of the array run (0, 1, 2).
If arrays in C were *one-based*, the indices would run (1, 2, 3).

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | int my_list[3];                   |
|                                   | my_list[0] = 5;                   |
|                                   | my_list[1] = 17;                  |
|                                   | my_list[2] = 23;                  |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

The above example would result in an array that "looks like" the
following diagram. (Of course, an array is merely an arrangement of
bytes in the computer's memory, so it does not *look like* much of
anything, literally speaking.)

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | index:         0           1      |
|                                   |       2                           |
|                                   |           ----------------------- |
|                                   | -------------                     |
|                                   | my_list: |     5     |    17      |
|                                   | |    23      |                    |
|                                   |           ----------------------- |
|                                   | -------------                     |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

Note that every element in an array must be of the same type, for
example, integer. It is not possible in C to have arrays that contain
multiple data types. However, if you want an array with multiple data
types, you might instead be able to use multiple arrays of different
data types that contain the same number of elements. For example, to
continue our restaurant tab example above, one array, `diner_names`
might contain a list of the names of the diners. If you are looking for
a particular diner, say Xavier Nougat, you might find that the index of
his name in `diner_names` is 7498. If you have programmed an associated
floating-point array called `diner_tabs`, you might look up element 7498
in that array and find that his tab is \$99.34.

  ------------------------------------------------------------ ---- --
  [14.1 Array bounds](#Array-bounds)                                
  [14.2 Arrays and `for` loops](#Arrays-and-for-loops)              
  [14.3 Multidimensional arrays](#Multidimensional-arrays)          
  [14.4 Arrays and nested loops](#Arrays-and-nested-loops)          
  [14.5 Initializing arrays](#Initializing-arrays)                  
  [14.6 Arrays as Parameters](#Arrays-as-Parameters)                
  [14.7 Questions for Chapter 14](#Questions-for-Chapter-14)        
  ------------------------------------------------------------ ---- --

------------------------------------------------------------------------

[]{#Array-bounds}

  ------------------------------------------------------- ----------------------------------------------------------------- --- --------------------------------------------------------------------- -------------------------------- ------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Arrays "Previous section in reading order")\]   \[[\>](#Arrays-and-for-loops "Next section in reading order")\]       \[[\<\<](#Arrays "Beginning of this chapter or previous chapter")\]   \[[Up](#Arrays "Up section")\]   \[[\>\>](#Strings "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ------------------------------------------------------- ----------------------------------------------------------------- --- --------------------------------------------------------------------- -------------------------------- ------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Array-bounds-1}

14.1 Array bounds {#array-bounds .section}
-----------------

[]{#index-Array-bounds} []{#index-Arrays_002c-bounds-of}
[]{#index-Bounds-of-arrays}

In keeping with C's free-wheeling, "I assume you know what you're doing"
policy, the compiler does not complain if you try to write to elements
of an array that do not exist. For example, the code below defines an
array with five elements. (Remember, C arrays are zero-based.)

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | char my_array[4];                 |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

Given the line of code below, your program will happily try to write the
character '\*' at location 10000. Unfortunately, as may happen when
writing to an uninitialized pointer, this may crash the program, but
will probably do nothing worse on a GNU system. (See section [Pointers
and initialization](#Pointers-and-initialization).)

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | my_array[10000] = '*';            |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

The first and last positions in an array are called its *bounds*.
Remember that the bounds of an array are zero and the integer that
equals the number of elements it contains, minus one.

Although C will not warn you at compile-time when you exceed the bounds
of an array, the debugger can tell you at run-time. See section
[Introduction to GDB](#Introduction-to-GDB), for more information.

------------------------------------------------------------------------

[]{#Arrays-and-for-loops}

  ------------------------------------------------------------- -------------------------------------------------------------------- --- --------------------------------------------------------------------- -------------------------------- ------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Array-bounds "Previous section in reading order")\]   \[[\>](#Multidimensional-arrays "Next section in reading order")\]       \[[\<\<](#Arrays "Beginning of this chapter or previous chapter")\]   \[[Up](#Arrays "Up section")\]   \[[\>\>](#Strings "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ------------------------------------------------------------- -------------------------------------------------------------------- --- --------------------------------------------------------------------- -------------------------------- ------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Arrays-and-for-loops-1}

14.2 Arrays and `for` loops {#arrays-and-for-loops .section}
---------------------------

[]{#index-Arrays-and-for-loops} []{#index-for-loops-and-arrays}
[]{#index-for-command-3} []{#index-Arrays_002c-initializing}
[]{#index-Initializing-arrays}

When you declare an array, the computer allocates a block of memory for
it, but the block contains garbage (random values). Therefore, before
using an array, you should initialise it. It is usually a good idea to
set all elements in the array to zero.

The easiest way to initialise an array is with a `for` loop. The
following example loops through every element in the array `my_array`
and sets each to zero.

Remember, because arrays in C are zero-based, the indices of the array
`my_array` in the example below run 0 through 9, rather than 1 through
10. The effect is the same, however: an array of `ARRAY_SIZE` (that is,
10) elements.

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | #include <stdio.h>                |
|                                   | #define ARRAY_SIZE 10             |
|                                   |                                   |
|                                   | int main ()                       |
|                                   | {                                 |
|                                   |   int index, my_array[ARRAY_SIZE] |
|                                   | ;                                 |
|                                   |                                   |
|                                   |   for (index = 0; index < ARRAY_S |
|                                   | IZE; index++)                     |
|                                   |     {                             |
|                                   |       my_array[index] = 0;        |
|                                   |       printf ("my_array[%d] = %d\ |
|                                   | n", index, my_array[index]);      |
|                                   |     }                             |
|                                   |   printf("\n");                   |
|                                   |                                   |
|                                   |   return 0;                       |
|                                   | }                                 |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

The output from the above example is as follows:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | my_array[0] = 0                   |
|                                   | my_array[1] = 0                   |
|                                   | my_array[2] = 0                   |
|                                   | my_array[3] = 0                   |
|                                   | my_array[4] = 0                   |
|                                   | my_array[5] = 0                   |
|                                   | my_array[6] = 0                   |
|                                   | my_array[7] = 0                   |
|                                   | my_array[8] = 0                   |
|                                   | my_array[9] = 0                   |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

You can use similar code to fill the array with different values. The
following code example is nearly identical to the one above, but the
line `my_array[index] = index;` fills each element of the array with its
own index:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | #include <stdio.h>                |
|                                   | #define ARRAY_SIZE 5              |
|                                   |                                   |
|                                   | int main ()                       |
|                                   | {                                 |
|                                   |   int index, my_array[ARRAY_SIZE] |
|                                   | ;                                 |
|                                   |                                   |
|                                   |   for (index = 0; index < ARRAY_S |
|                                   | IZE; index++)                     |
|                                   |     {                             |
|                                   |       my_array[index] = index;    |
|                                   |       printf ("my_array[%d] = %d\ |
|                                   | n", index, my_array[index]);      |
|                                   |     }                             |
|                                   |   printf("\n");                   |
|                                   |                                   |
|                                   |   return 0;                       |
|                                   | }                                 |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

The output is as follows:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | my_array[0] = 0                   |
|                                   | my_array[1] = 1                   |
|                                   | my_array[2] = 2                   |
|                                   | my_array[3] = 3                   |
|                                   | my_array[4] = 4                   |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

Here is a human's-eye view of the *internal representation* of the array
(how the array \"looks\" to the computer):

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | index        0   1   2   3   4    |
|                                   |             -------------------   |
|                                   | element    | 0 | 1 | 2 | 3 | 4 |  |
|                                   |             -------------------   |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

You can use loops to do more than initialize an array. The next code
example demonstrates the use of `for` loops with an array to find prime
numbers. The example uses a mathematical device called the Sieve of
Erastosthenes. Erastosthenes of Cyrene discovered that one can find all
prime numbers by first writing down a list of integers from 2 (the first
prime number) up to some arbitrary number, then deleting all multiples
of 2 (which are by definition not prime numbers), finding the next
undeleted number after 2 (which is 3), deleting all its multiples,
finding the next undeleted number after that (5), deleting all its
multiples, and so on. When you have finished this process, all numbers
that remain are primes.

The following code example creates a Sieve of Erastosthenes for integers
up to 4999, initializes all elements with 1, then deletes all composite
(non-prime) numbers by replacing the elements that have an index equal
to the composite with the macro `DELETED`, which equals 0.

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | #include <stdio.h>                |
|                                   |                                   |
|                                   | #define ARRAY_SIZE 5000           |
|                                   | #define DELETED    0              |
|                                   |                                   |
|                                   | int sieve[ARRAY_SIZE];            |
|                                   |                                   |
|                                   |                                   |
|                                   | int main ()                       |
|                                   | {                                 |
|                                   |   printf ("Results of Sieve of Er |
|                                   | astosthenes:\n\n");               |
|                                   |                                   |
|                                   |   fill_sieve();                   |
|                                   |   delete_nonprimes();             |
|                                   |   print_primes();                 |
|                                   | }                                 |
|                                   |                                   |
|                                   |                                   |
|                                   | fill_sieve ()                     |
|                                   | {                                 |
|                                   |   int index;                      |
|                                   |                                   |
|                                   |   for (index = 2; index < ARRAY_S |
|                                   | IZE; index++)                     |
|                                   |     sieve[index] = 1;             |
|                                   | }                                 |
|                                   |                                   |
|                                   |                                   |
|                                   | delete_nonprimes ()               |
|                                   | {                                 |
|                                   |   int index;                      |
|                                   |                                   |
|                                   |   for (index = 2; index < ARRAY_S |
|                                   | IZE; index++)                     |
|                                   |     {                             |
|                                   |       if (sieve[index] != DELETED |
|                                   | )                                 |
|                                   |     delete_multiples_of_prime (in |
|                                   | dex);                             |
|                                   |     }                             |
|                                   | }                                 |
|                                   |                                   |
|                                   |                                   |
|                                   | delete_multiples_of_prime (int pr |
|                                   | ime)                              |
|                                   | {                                 |
|                                   |   int index, multiplier = 2;      |
|                                   |                                   |
|                                   |   for (index = prime * multiplier |
|                                   | ; index < ARRAY_SIZE; index = pri |
|                                   | me * multiplier++)                |
|                                   |     sieve[index] = DELETED;       |
|                                   | }                                 |
|                                   |                                   |
|                                   |                                   |
|                                   | print_primes ()                   |
|                                   | {                                 |
|                                   |   int index;                      |
|                                   |                                   |
|                                   |   for (index = 2; index < ARRAY_S |
|                                   | IZE; index++)                     |
|                                   |     {                             |
|                                   |       if (sieve[index] != DELETED |
|                                   | )                                 |
|                                   |     printf ("%d ", index);        |
|                                   |     }                             |
|                                   |   printf("\n\n");                 |
|                                   | }                                 |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

Part of the output from the above program is shown below, for values up
to 500. (The full output is considerably longer.)

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | Results of Sieve of Erastosthenes |
|                                   | :                                 |
|                                   |                                   |
|                                   | 2 3 5 7 11 13 17 19 23 29 31 37 4 |
|                                   | 1 43 47 53 59 61 67 71 73 79 83 8 |
|                                   | 9 97                              |
|                                   | 101 103 107 109 113 127 131 137 1 |
|                                   | 39 149 151 157 163 167 173 179 18 |
|                                   | 1 191                             |
|                                   | 193 197 199 211 223 227 229 233 2 |
|                                   | 39 241 251 257 263 269 271 277 28 |
|                                   | 1 283                             |
|                                   | 293 307 311 313 317 331 337 347 3 |
|                                   | 49 353 359 367 373 379 383 389 39 |
|                                   | 7 401                             |
|                                   | 409 419 421 431 433 439 443 449 4 |
|                                   | 57 461 463 467 479 487 491 499 …  |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

------------------------------------------------------------------------

[]{#Multidimensional-arrays}

  --------------------------------------------------------------------- -------------------------------------------------------------------- --- --------------------------------------------------------------------- -------------------------------- ------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Arrays-and-for-loops "Previous section in reading order")\]   \[[\>](#Arrays-and-nested-loops "Next section in reading order")\]       \[[\<\<](#Arrays "Beginning of this chapter or previous chapter")\]   \[[Up](#Arrays "Up section")\]   \[[\>\>](#Strings "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  --------------------------------------------------------------------- -------------------------------------------------------------------- --- --------------------------------------------------------------------- -------------------------------- ------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Multidimensional-arrays-1}

14.3 Multidimensional arrays {#multidimensional-arrays .section}
----------------------------

[]{#index-Arrays_002c-multidimensional-2}
[]{#index-Multidimensional-arrays-1} []{#index-GNU-Chess}
[]{#index-Chess_002c-GNU}
[]{#index-Chessboard_002c-represented-by-array}

Suppose that you are writing a chess-playing program like [GNU
Chess](http://www.gnu.org/software/chess/chess.html). A chessboard is an
8-by-8 grid. What data structure would you use to represent it?

You could use an array that has a chessboard-like structure, that is, a
*two-dimensional array*, to store the positions of the chess pieces.
Two-dimensional arrays use two indices to pinpoint an individual element
of the array. This is very similar to what is called "algebraic
notation", already commonly used in chess circles to record games and
chess problems.

In principle, there is no limit to the number of subscripts (or
dimensions) an array can have. Arrays with more than one dimension are
called *multidimensional arrays*. Although humans cannot easily
visualize objects with more than three dimensions, representing
multidimensional arrays presents no problem to computers.

In practice, however, the amount of memory in a computer tends to place
limits on how large an array can be. For example, a simple
four-dimensional array of double-precision numbers, merely twenty
elements wide in each dimension, already takes up [![\$20\^4 \*
8\$](ctut_5.svg)]{.MATH}, or 1,280,000 bytes of memory --- about a
megabyte. (Each element of the array takes up 8 bytes, because doubles
are 64 bits wide. See section [Floating point
variables](#Floating-point-variables), for more information.)

You can declare an array of two dimensions as follows:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | variable_type array_name[size1][s |
|                                   | ize2]                             |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

In the above example, variable\_type is the name of some type of
variable, such as `int`. Also, size1 and size2 are the sizes of the
array's first and second dimensions, respectively. Here is an example of
defining an 8-by-8 array of integers, similar to a chessboard. Remember,
because C arrays are zero-based, the indices on each side of the
chessboard array run 0 through 7, rather than 1 through 8. The effect is
the same, however: a two-dimensional array of 64 elements.

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | int chessboard[8][8];             |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

To pinpoint an element in this grid, simply supply the indices in both
dimensions.

Every element in this grid needs two indices to pin-point it. Normally,
C programmers think of element 0,0 of a two-dimensional array as being
the upper-left corner. The computer, however, knows nothing of left and
right, and for our purposes (attempting to conform to international
chess notation), it makes more sense to mentally "flop" the array
vertically so that element 0,0 is the lower-left corner of the board,
and 7,7 the upper-right. Thus, the first index gives the row number for
the grid and the second index gives the column number. For example, 1,0
is the square directly above the lower-left corner. Suppose that a value
of 1 for an array location means a the chess king is on the space in
question. To indicate the White king's usual position (that is, square
a5 in algebraic chess notation or 0,4 in our zero-based integer
notation), you would write this:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | chessboard[0][4] = 1;             |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

Since computer memory is essentially one-dimensional, with memory
locations running straight from 0 up through the highest location in
memory, a multidimensional array cannot be stored in memory as a grid.
Instead, the array is dissected and stored in rows. Consider the
following two-dimensional array.

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   |         -----------               |
|                                   | row 0  | 1 | 2 | 3 |              |
|                                   |         -----------               |
|                                   | row 1  | 4 | 5 | 6 |              |
|                                   |         -----------               |
|                                   | row 2  | 7 | 8 | 9 |              |
|                                   |         -----------               |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

Note that the numbers inside the boxes are not the actual indices of the
array, which is two-dimensional and has two indices for each element,
but only arbitrary placeholders to enable you to see which elements
correspond in the following example. The row numbers do correspond to
the first index of the array, so they are numbered from 0 to 2 rather
than 1 to 3.

To the computer, the array above actually "looks" like this:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | --------------------------------- |
|                                   | ---                               |
|                                   | | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | |
|                                   |  9 |                              |
|                                   | --------------------------------- |
|                                   | ---                               |
|                                   | |   row 0   |   row 1   |   row 2 |
|                                   |    |                              |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

Another way of saying that arrays are stored by row is that the second
index *varies fastest*. A two-dimensional array is always thought of as
follows:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | array_name[row][column]           |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

Every row stored will contain elements of many columns. The column index
runs from 0 to size - 1 inside every row in the one-dimensional
representation (where size is the number of columns in the array), so
the column index is changing faster than the row index, as the
one-dimensional representation of the array inside the computer is
traversed.

You can represent a three-dimensional array, such as a cube, in a
similar way:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | variable_type array_name[size1][s |
|                                   | ize2][size3]                      |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

Arrays do not have to be shaped like squares and cubes; you can give
each dimension of the array a different size, as follows:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | int non_cube[2][6][8];            |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

Three-dimensional arrays (and higher) are stored in the same basic way
as two-dimensional ones. They are kept in computer memory as a linear
sequence of variables, and the last index is always the one that varies
fastest (then the next-to-last, and so on).

------------------------------------------------------------------------

[]{#Arrays-and-nested-loops}

  ------------------------------------------------------------------------ ---------------------------------------------------------------- --- --------------------------------------------------------------------- -------------------------------- ------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Multidimensional-arrays "Previous section in reading order")\]   \[[\>](#Initializing-arrays "Next section in reading order")\]       \[[\<\<](#Arrays "Beginning of this chapter or previous chapter")\]   \[[Up](#Arrays "Up section")\]   \[[\>\>](#Strings "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ------------------------------------------------------------------------ ---------------------------------------------------------------- --- --------------------------------------------------------------------- -------------------------------- ------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Arrays-and-nested-loops-1}

14.4 Arrays and nested loops {#arrays-and-nested-loops .section}
----------------------------

[]{#index-Arrays_002c-multidimensional_002c-initializing}
[]{#index-Multidimensional-arrays_002c-initializing}
[]{#index-Initializing-multidimensional-arrays}
[]{#index-Arrays_002c-initializing-1} []{#index-Initializing-arrays-1}
[]{#index-Nested-for-loops} []{#index-for-loops_002c-nested}
[]{#index-Nested-loops-1} []{#index-Loops_002c-nested-1}
[]{#index-Arrays-and-nested-loops} []{#index-Nested-loops-and-arrays}

To initialize multidimensional arrays, you can use nested `for` loops.
Three nested loops are needed to initialize a three-dimensional array:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | #include <stdio.h>                |
|                                   |                                   |
|                                   | #define SIZE1 3                   |
|                                   | #define SIZE2 3                   |
|                                   | #define SIZE3 3                   |
|                                   |                                   |
|                                   | int main ()                       |
|                                   | {                                 |
|                                   |   int fast, faster, fastest;      |
|                                   |   int my_array[SIZE1][SIZE2][SIZE |
|                                   | 3];                               |
|                                   |                                   |
|                                   |   for (fast = 0; fast < SIZE1; fa |
|                                   | st++)                             |
|                                   |     {                             |
|                                   |       for (faster = 0; faster < S |
|                                   | IZE2; faster++)                   |
|                                   |     {                             |
|                                   |       for (fastest = 0; fastest < |
|                                   |  SIZE3; fastest++)                |
|                                   |         {                         |
|                                   |           my_array[fast][faster][ |
|                                   | fastest] = 0;                     |
|                                   |           printf("my_array[%d][%d |
|                                   | ][%d] DONE\n", fast, faster, fast |
|                                   | est);                             |
|                                   |         }                         |
|                                   |     }                             |
|                                   |     }                             |
|                                   |   printf("\n");                   |
|                                   | }                                 |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

In this example, the variables `fast`, `faster`, and `fastest` contain
the indices of the array, and vary fast, faster, and fastest,
respectively. In the example output below, you can see that the
`fastest` index changes every line, while the `faster` index changes
every three lines, and the `fast` index changes only every nine lines.

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | my_array[0][0][0] DONE            |
|                                   | my_array[0][0][1] DONE            |
|                                   | my_array[0][0][2] DONE            |
|                                   | my_array[0][1][0] DONE            |
|                                   | my_array[0][1][1] DONE            |
|                                   | my_array[0][1][2] DONE            |
|                                   | my_array[0][2][0] DONE            |
|                                   | my_array[0][2][1] DONE            |
|                                   | my_array[0][2][2] DONE            |
|                                   | my_array[1][0][0] DONE            |
|                                   | my_array[1][0][1] DONE            |
|                                   | my_array[1][0][2] DONE            |
|                                   | my_array[1][1][0] DONE            |
|                                   | my_array[1][1][1] DONE            |
|                                   | my_array[1][1][2] DONE            |
|                                   | my_array[1][2][0] DONE            |
|                                   | my_array[1][2][1] DONE            |
|                                   | my_array[1][2][2] DONE            |
|                                   | my_array[2][0][0] DONE            |
|                                   | my_array[2][0][1] DONE            |
|                                   | my_array[2][0][2] DONE            |
|                                   | my_array[2][1][0] DONE            |
|                                   | my_array[2][1][1] DONE            |
|                                   | my_array[2][1][2] DONE            |
|                                   | my_array[2][2][0] DONE            |
|                                   | my_array[2][2][1] DONE            |
|                                   | my_array[2][2][2] DONE            |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

**Note:** Although in this example we have followed the order in which
indices vary inside the computer, you do not have to do so in your own
code. For example, we could have switched the nesting of the innermost
`fastest` and outermost `fast` loops, and every element would still have
been initialized. It is better, however, to be systematic about
initializing multidimensional arrays.

------------------------------------------------------------------------

[]{#Initializing-arrays}

  ------------------------------------------------------------------------ ----------------------------------------------------------------- --- --------------------------------------------------------------------- -------------------------------- ------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Arrays-and-nested-loops "Previous section in reading order")\]   \[[\>](#Arrays-as-Parameters "Next section in reading order")\]       \[[\<\<](#Arrays "Beginning of this chapter or previous chapter")\]   \[[Up](#Arrays "Up section")\]   \[[\>\>](#Strings "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ------------------------------------------------------------------------ ----------------------------------------------------------------- --- --------------------------------------------------------------------- -------------------------------- ------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Initializing-arrays-1}

14.5 Initializing arrays {#initializing-arrays .section}
------------------------

[]{#index-Arrays_002c-initializing-2} []{#index-Initializing-arrays-2}

As mentioned above, you must initialize your arrays or they will contain
garbage. There are two main ways to do so. The first is by assigning
values to array elements individually, either as shown in the example
below, or with `for` loops. (See section [Arrays and `for`
loops](#Arrays-and-for-loops), above.)

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | my_array[0] = 42;                 |
|                                   | my_array[1] = 52;                 |
|                                   | my_array[2] = 23;                 |
|                                   | my_array[3] = 100;                |
|                                   | …                                 |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

The second method is more efficient and less tedious. It uses a single
assignment operator (`=`) and a few curly brackets (`{…}`).

Recall that arrays are stored by row, with the last index varying
fastest. A 3 by 3 array could be initialized in the following way:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | int my_array[3][3] =              |
|                                   | {                                 |
|                                   |   {10, 23, 42},                   |
|                                   |   {1, 654, 0},                    |
|                                   |   {40652, 22, 0}                  |
|                                   | };                                |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

Here is a small program that uses the above initialization:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | #include <stdio.h>                |
|                                   |                                   |
|                                   | int main()                        |
|                                   | {                                 |
|                                   |   int row, column;                |
|                                   |                                   |
|                                   |   int my_array[3][3] =            |
|                                   |   {                               |
|                                   |     {10, 23, 42},                 |
|                                   |     {1, 654, 0},                  |
|                                   |     {40652, 22, 0}                |
|                                   |   };                              |
|                                   |                                   |
|                                   |   for (row = 0; row <=2; row++)   |
|                                   |     {                             |
|                                   |       for (column = 0; column <=  |
|                                   | 2; column++)                      |
|                                   |     {                             |
|                                   |       printf("%d\t", my_array[row |
|                                   | ][column]);                       |
|                                   |     }                             |
|                                   |       printf("\n");               |
|                                   |     }                             |
|                                   |                                   |
|                                   |   printf("\n");                   |
|                                   |                                   |
|                                   |   return 0;                       |
|                                   | }                                 |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

The internal curly brackets are unnecessary, but they help to
distinguish the rows of the array. The following code has the same
effect as the first example:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | int my_array[3][3] =              |
|                                   | {                                 |
|                                   |   10, 23, 42,                     |
|                                   |   1, 654, 0,                      |
|                                   |   40652, 22, 0                    |
|                                   | };                                |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

The same array initialization could even be written this way:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | int my_array[3][3] =              |
|                                   |   {10, 23, 42, 1, 654, 0, 40652,  |
|                                   | 22, 0};                           |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

Using any of these three array initializations, the program above will
print the following text:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | 10      23      42                |
|                                   | 1       654     0                 |
|                                   | 40652   22      0                 |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

**Note 1:** Be careful to place commas after every array element except
the last one before a closing curly bracket ('}'). Be sure you also
place a semicolon after the final curly bracket of an array initializer,
since here curly brackets are not delimiting a code block.

**Note 2:** All the expressions in an array initializer must be
constants, not variables; that is, values such as `235` and `'q'` are
acceptable, depending on the type of the array, but expressions such as
the integer variable `my_int` are not.

**Note 3:** If there are not enough expressions in the array initializer
to fill the array, the remaining elements will be set to 0 if the array
is static, but will be filled with garbage otherwise.

------------------------------------------------------------------------

[]{#Arrays-as-Parameters}

  -------------------------------------------------------------------- --------------------------------------------------------------------- --- --------------------------------------------------------------------- -------------------------------- ------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Initializing-arrays "Previous section in reading order")\]   \[[\>](#Questions-for-Chapter-14 "Next section in reading order")\]       \[[\<\<](#Arrays "Beginning of this chapter or previous chapter")\]   \[[Up](#Arrays "Up section")\]   \[[\>\>](#Strings "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  -------------------------------------------------------------------- --------------------------------------------------------------------- --- --------------------------------------------------------------------- -------------------------------- ------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Arrays-as-Parameters-1}

14.6 Arrays as Parameters {#arrays-as-parameters .section}
-------------------------

[]{#index-Arrays-as-parameters} []{#index-Passing-arrays-as-parameters}
[]{#index-Parameters_002c-arrays-as}
[]{#index-Parameters_002c-passing-arrays-as}
[]{#index-Pointers-and-arrays_002c-equivalence-of}
[]{#index-Arrays-and-pointers_002c-equivalence-of}
[]{#index-Equivalence-of-pointers-and-arrays}

There will be times when you want to pass an array as a parameter to a
function. (For example, you might want to pass an array of numbers to a
function that will sort them.)

In the following example, notice how the array `my_array` in `main` is
passed to the function `multiply` as an actual parameter with the name
`my_array`, but that the formal parameter in the `multiply` function is
defined as `int *the_array`: that is, an integer pointer. This is the
basis for much that you will hear spoken about the "equivalence of
pointers and arrays" --- much that is best ignored until you have more C
programming experience. The important thing to understand is that arrays
passed as parameters are considered to be pointers by the functions
receiving them. Therefore, they are always variable parameters, which
means that other functions can modify the original copy of the variable,
just as the function `multiply` does with the array `my_array` below.
(See section [Parameters](#Parameters).)

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | #include <stdio.h>                |
|                                   |                                   |
|                                   | void multiply (int *, int);       |
|                                   |                                   |
|                                   |                                   |
|                                   | int main()                        |
|                                   | {                                 |
|                                   |   int index;                      |
|                                   |   int my_array[5] = {0, 1, 2, 3,  |
|                                   | 4};                               |
|                                   |                                   |
|                                   |   multiply (my_array, 2);         |
|                                   |                                   |
|                                   |   for (index = 0; index < 5; inde |
|                                   | x++)                              |
|                                   |     printf("%d  ", my_array[index |
|                                   | ]);                               |
|                                   |                                   |
|                                   |   printf("\n\n");                 |
|                                   |   return 0;                       |
|                                   | }                                 |
|                                   |                                   |
|                                   |                                   |
|                                   | void multiply (int *the_array, in |
|                                   | t multiplier)                     |
|                                   | {                                 |
|                                   |   int index;                      |
|                                   |   for (index = 0; index < 5; inde |
|                                   | x++)                              |
|                                   |     the_array[index] *= multiplie |
|                                   | r;                                |
|                                   | }                                 |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

Even though the function `multiply` is declared `void` and therefore
does not return a result, it can still modify `my_array` directly,
because it is a variable parameter. Therefore, the result of the program
above is as follows:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | 0  2  4  6  8                     |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

If you find the interchangeability of arrays and pointers as formal
parameters in function declarations to be confusing, you can always
avoid the use of pointers, and declare formal parameters to be arrays,
as in the new version of the `multiply` function below. The result is
the same.

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | void multiply (int the_array[], i |
|                                   | nt multiplier)                    |
|                                   | {                                 |
|                                   |   int index;                      |
|                                   |   for (index = 0; index < 5; inde |
|                                   | x++)                              |
|                                   |     the_array[index] *= multiplie |
|                                   | r;                                |
|                                   | }                                 |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

------------------------------------------------------------------------

[]{#Questions-for-Chapter-14}

  --------------------------------------------------------------------- ---------------------------------------------------- --- --------------------------------------------------------------------- -------------------------------- ------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Arrays-as-Parameters "Previous section in reading order")\]   \[[\>](#Strings "Next section in reading order")\]       \[[\<\<](#Arrays "Beginning of this chapter or previous chapter")\]   \[[Up](#Arrays "Up section")\]   \[[\>\>](#Strings "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  --------------------------------------------------------------------- ---------------------------------------------------- --- --------------------------------------------------------------------- -------------------------------- ------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Questions-for-Chapter-14-1}

14.7 Questions for Chapter 14 {#questions-for-chapter-14 .section}
-----------------------------

1.  Declare an array of type `double`, measuring 4 by 5 elements.
2.  How do you pass an array as a parameter?
3.  When an array parameter is received by a function, does C allocate
    space for a local variable and copy the whole array to the new
    location?
4.  What does it mean to say that one dimension of an array "varies
    fastest"?
5.  Which dimension of an array varies fastest, the first or the last?

------------------------------------------------------------------------

[]{#Strings}

  ------------------------------------------------------------------------- ------------------------------------------------------------------------- --- --------------------------------------------------------------------- ----------------------------- ---------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Questions-for-Chapter-14 "Previous section in reading order")\]   \[[\>](#Conventions-and-declarations "Next section in reading order")\]       \[[\<\<](#Arrays "Beginning of this chapter or previous chapter")\]   \[[Up](#Top "Up section")\]   \[[\>\>](#Input-and-output "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ------------------------------------------------------------------------- ------------------------------------------------------------------------- --- --------------------------------------------------------------------- ----------------------------- ---------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Strings-1}

15. Strings {#strings .chapter}
===========

[]{#index-Strings} []{#index-String-values}

*Communication using arrays.*

So far we have examined variables that can contain integers,
floating-point numbers, and values that represent individual text
characters. But what if you need a variable that can contain a sequence
of text characters, such as a name in a database of diners at a
restaurant, as in the examples for last chapter? That's where strings
and string variables come in.

A *string value* is a sequence of text characters that can become a
value for a *string variable*. Both a string value and a string variable
can be referred to as a *string*, depending on context.

In C, a string value is represented by text characters enclosed by
double quotes:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | "This is a string value."         |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

A string can contain any character, including special control
characters, such as the tab character '\\t', the newline character
'\\n', the "bell" character '\\7' (which causes the terminal to beep
when it is displayed), and so on.

We have been using string values since we introduced the `printf`
command early in the book. (See section [The form of a C
program](#The-form-of-a-C-program).) To cause your terminal to beep
twice, include the following statement in a C program:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | printf("This is a string value. B |
|                                   | eep! Beep! \7\7");                |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

  -------------------------------------------------------------------- ---- --
  [15.1 Conventions and declarations](#Conventions-and-declarations)        
  [15.2 Initializing strings](#Initializing-strings)                        
  [15.3 String arrays](#String-arrays)                                      
  [15.4 String library functions](#String-library-functions)                
  [15.5 Questions for Chapter 15](#Questions-for-Chapter-15)                
  -------------------------------------------------------------------- ---- --

------------------------------------------------------------------------

[]{#Conventions-and-declarations}

  -------------------------------------------------------- ----------------------------------------------------------------- --- ---------------------------------------------------------------------- --------------------------------- ---------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Strings "Previous section in reading order")\]   \[[\>](#Initializing-strings "Next section in reading order")\]       \[[\<\<](#Strings "Beginning of this chapter or previous chapter")\]   \[[Up](#Strings "Up section")\]   \[[\>\>](#Input-and-output "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  -------------------------------------------------------- ----------------------------------------------------------------- --- ---------------------------------------------------------------------- --------------------------------- ---------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Conventions-and-declarations-1}

15.1 Conventions and declarations {#conventions-and-declarations .section}
---------------------------------

[]{#index-Strings_002c-confused-with-characters}
[]{#index-Characters_002c-confused-with-strings} []{#index-char-type-3}

Do not confuse strings in C with individual characters. By convention,
individual characters are enclosed in single quotes, like this: `'a'`,
and have the variable type `char`. On the other hand, string values are
enclosed in double quotes, like this: `"abcdefg"`. String variables are
either arrays of type `char` or have the type "pointer to `char`", that
is, `char *`.

Conceptually, a string is an array of characters (type `char`). In C,
string variables can theoretically be of any length, unlike languages
such as Pascal where strings hold a maximum of 255 characters. However,
the length of the string value is determined by the position of the
first null character (`'/0'`) in the string. Even though a string
*variable* might be 32,000 characters long, or longer, if the null
character first appears at position 5 in the character array, the string
value is considered to be of length 5 (and contains the characters in
positions 0 through 4, in sequence). You will rarely need to consider
this end marker, as most functions in C's string library add it or
remove it automatically.

------------------------------------------------------------------------

[]{#Initializing-strings}

  ----------------------------------------------------------------------------- ---------------------------------------------------------- --- ---------------------------------------------------------------------- --------------------------------- ---------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Conventions-and-declarations "Previous section in reading order")\]   \[[\>](#String-arrays "Next section in reading order")\]       \[[\<\<](#Strings "Beginning of this chapter or previous chapter")\]   \[[Up](#Strings "Up section")\]   \[[\>\>](#Input-and-output "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ----------------------------------------------------------------------------- ---------------------------------------------------------- --- ---------------------------------------------------------------------- --------------------------------- ---------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Initializing-strings-1}

15.2 Initializing strings {#initializing-strings .section}
-------------------------

[]{#index-Strings_002c-initializing} []{#index-Initializing-strings}
[]{#index-String-constants} []{#index-Constants_002c-string}

Initializing string variables (or character arrays) with string values
is in many ways even easier than initializing other kinds of arrays.
There are three main ways of assigning string constants to string
variables. (A *string constant* is a string value that was typed into
the source code, as opposed to one that is generated by the program or
entered by the user.)

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | #include <stdio.h>                |
|                                   | #include <string.h>               |
|                                   |                                   |
|                                   | int main()                        |
|                                   | {                                 |
|                                   |   /* Example 1 */                 |
|                                   |   char string1[] = "A string decl |
|                                   | ared as an array.\n";             |
|                                   |                                   |
|                                   |   /* Example 2 */                 |
|                                   |   char *string2 = "A string decla |
|                                   | red as a pointer.\n";             |
|                                   |                                   |
|                                   |   /* Example 3 */                 |
|                                   |   char string3[30];               |
|                                   |   strcpy(string3, "A string const |
|                                   | ant copied in.\n");               |
|                                   |                                   |
|                                   |   printf (string1);               |
|                                   |   printf (string2);               |
|                                   |   printf (string3);               |
|                                   |                                   |
|                                   |   return 0;                       |
|                                   | }                                 |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

1.  `char string1[] = "A string declared as an array.\n";`

    This is usually the best way to declare and initialize a string. The
    character array is declared explicitly. There is no size declaration
    for the array; just enough memory is allocated for the string,
    because the compiler knows how long the string constant is. The
    compiler stores the string constant in the character array and adds
    a null character ('\\0') to the end.

2.  `char *string2 = "A string declared as a pointer.\n";`

    The second of these initializations is a pointer to an array of
    characters. Just as in the last example, the compiler calculates the
    size of the array from the string constant and adds a null
    character. The compiler then assigns a pointer to the first
    character of the character array to the variable `string2`.

    **Note:** Most string functions will accept strings declared in
    either of these two ways. Consider the `printf` statements at the
    end of the example program above --- the statements to print the
    variables `string1` and `string2` are identical.

3.  `char string3[30];`

    Declaring a string in this way is useful when you don't know what
    the string variable will contain, but have a general idea of the
    length of its contents (in this case, the string can be a maximum of
    30 characters long). The drawback is that you will either have to
    use some kind of string function to assign the variable a value, as
    the next line of code does
    (` strcpy(string3, "A string constant copied in.\n");`), or you will
    have to assign the elements of the array the hard way, character by
    character. (See section [String library
    functions](#String-library-functions), for more information on the
    function `strcpy`.)

------------------------------------------------------------------------

[]{#String-arrays}

  --------------------------------------------------------------------- --------------------------------------------------------------------- --- ---------------------------------------------------------------------- --------------------------------- ---------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Initializing-strings "Previous section in reading order")\]   \[[\>](#String-library-functions "Next section in reading order")\]       \[[\<\<](#Strings "Beginning of this chapter or previous chapter")\]   \[[Up](#Strings "Up section")\]   \[[\>\>](#Input-and-output "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  --------------------------------------------------------------------- --------------------------------------------------------------------- --- ---------------------------------------------------------------------- --------------------------------- ---------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#String-arrays-1}

15.3 String arrays {#string-arrays .section}
------------------

[]{#index-String-arrays} []{#index-Arrays-of-strings}

Suppose you want to print out a screenful of text instead of a single
line. You could use one long character array, interspersed with '\\n'
characters where you want the lines to break, but you might find it
easier to use a *string array*. A string array is an array of strings,
which, of course, are themselves arrays of characters; in effect, a
string array is a two-dimensional character array.

Just as there are easy methods of initializing integer arrays, float
arrays, strings, and so on, there is also an easy way of initializing
string arrays. For example, here is a sample program which prints out a
menu for a full application program. That's all it does, but you might
imagine that when the user chooses '3' in the full program, the
application invokes the function `calculate_bill` we examined earlier.
(See section [Parameters](#Parameters).)

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | #include <stdio.h>                |
|                                   |                                   |
|                                   | char *menu[] =                    |
|                                   | {                                 |
|                                   |   "  ---------------------------- |
|                                   | ---------- ",                     |
|                                   |   " |            ++ MENU ++       |
|                                   |           |",                     |
|                                   |   " |           ~~~~~~~~~~~~      |
|                                   |           |",                     |
|                                   |   " |     (0) Edit Preferences    |
|                                   |           |",                     |
|                                   |   " |     (1) Print Charge Sheet  |
|                                   |           |",                     |
|                                   |   " |     (2) Print Log Sheet     |
|                                   |           |",                     |
|                                   |   " |     (3) Calculate Bill      |
|                                   |           |",                     |
|                                   |   " |     (q) Quit                |
|                                   |           |",                     |
|                                   |   " |                             |
|                                   |           |",                     |
|                                   |   " |                             |
|                                   |           |",                     |
|                                   |   " |     Please enter choice bel |
|                                   | ow.       |",                     |
|                                   |   " |                             |
|                                   |           |",                     |
|                                   |   "  ---------------------------- |
|                                   | ---------- "                      |
|                                   | };                                |
|                                   |                                   |
|                                   |                                   |
|                                   | int main()                        |
|                                   | {                                 |
|                                   |   int line_num;                   |
|                                   |                                   |
|                                   |   for (line_num = 0; line_num < 1 |
|                                   | 3; line_num++)                    |
|                                   |     {                             |
|                                   |       printf ("%s\n", menu[line_n |
|                                   | um]);                             |
|                                   |     }                             |
|                                   |                                   |
|                                   |   return 0;                       |
|                                   | }                                 |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

Notice that the string array `menu` is declared `char *menu[]`. This
method of defining a two-dimensional string array is a combination of
methods 1 and 2 for initializing strings from the last section. (See
section [Initializing strings](#Initializing-strings).) This is the most
convenient method; if you try to define `menu` with `char menu[][]`, the
compiler will return an "unspecified bounds error". You can get around
this by declaring the second subscript of `menu` explicitly (e.g.
`char menu[][80]`), but that necessitates you know the maximum length of
the strings you are storing in the array, which is something you may not
know and that it may be tedious to find out.

The elements of `menu` are initialized with string constants in the same
way that an integer array, for example, is initialized with integers,
separating each element with a comma. (See section [Initializing
arrays](#Initializing-arrays).)

------------------------------------------------------------------------

[]{#String-library-functions}

  -------------------------------------------------------------- --------------------------------------------------------------------- --- ---------------------------------------------------------------------- --------------------------------- ---------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#String-arrays "Previous section in reading order")\]   \[[\>](#Questions-for-Chapter-15 "Next section in reading order")\]       \[[\<\<](#Strings "Beginning of this chapter or previous chapter")\]   \[[Up](#Strings "Up section")\]   \[[\>\>](#Input-and-output "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  -------------------------------------------------------------- --------------------------------------------------------------------- --- ---------------------------------------------------------------------- --------------------------------- ---------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#String-library-functions-1}

15.4 String library functions {#string-library-functions .section}
-----------------------------

[]{#index-String-library-functions}
[]{#index-Library-functions_002c-string}
[]{#index-Functions_002c-string-library}
[]{#index-string_002eh-header-file-1}
[]{#index-stdlib_002eh-header-file}

The GNU C Library provides a number of very useful functions which
handle strings. Here is a list of the more common ones. To use the
functions beginning with 'ato', you must include the header file
'`stdlib.h`'; to use the functions beginning with 'str', you must
include the header file '`string.h`'.

-   []{#index-atof-function}
-   `atof` Converts an ASCII string to its floating-point equivalent;
    for example, converts '-23.5' to the value -23.5.

    +-----------------------------------+-----------------------------------+
    |                                   | ``` {.smallexample}               |
    |                                   | #include <stdio.h>                |
    |                                   | #include <stdlib.h>               |
    |                                   |                                   |
    |                                   | int main()                        |
    |                                   | {                                 |
    |                                   |   double my_value;                |
    |                                   |   char my_string[] = "+1776.23";  |
    |                                   |   my_value = atof(my_string);     |
    |                                   |   printf("%f\n", my_value);       |
    |                                   |                                   |
    |                                   |   return 0;                       |
    |                                   | }                                 |
    |                                   | ```                               |
    +-----------------------------------+-----------------------------------+

    The output from the above code is '1776.230000'.

    []{#index-atoi-function}

-   `atoi` Converts an ASCII string to its integer equivalent; for
    example, converts '-23.5' to the value -23.
    +-----------------------------------+-----------------------------------+
    |                                   | ``` {.smallexample}               |
    |                                   | int my_value;                     |
    |                                   | char my_string[] = "-23.5";       |
    |                                   | my_value = atoi(my_string);       |
    |                                   | printf("%d\n", my_value);         |
    |                                   | ```                               |
    +-----------------------------------+-----------------------------------+

    []{#index-atol-function}
-   `atol` Converts an ASCII string to its long integer equivalent; for
    example, converts '+2000000000' to the value 2000000000.
    +-----------------------------------+-----------------------------------+
    |                                   | ``` {.smallexample}               |
    |                                   | long my_value;                    |
    |                                   | char my_string[] = "+2000000000"; |
    |                                   | my_value = atol(my_string);       |
    |                                   | printf("%ld\n", my_value);        |
    |                                   | ```                               |
    +-----------------------------------+-----------------------------------+

    []{#index-strcat-function}
-   `strcat` *Concatenates* two strings: that is, joins them together
    into one string. Example:

    +-----------------------------------+-----------------------------------+
    |                                   | ``` {.smallexample}               |
    |                                   | char string1[50] = "Hello, ";     |
    |                                   | char string2[] = "world!\n";      |
    |                                   | strcat (string1, string2);        |
    |                                   | printf (string1);                 |
    |                                   | ```                               |
    +-----------------------------------+-----------------------------------+

    The example above attaches the contents of `string2` to the current
    contents of `string1`. The array `string1` then contains the string
    'Hello, world!\\n'.

    Notice that `string1` was declared to be 50 characters long, more
    than enough to contain the initial values of both `string1` and
    `string2`. You must be careful to allocate enough space in the
    string variable that will receive the concatenated data; otherwise,
    your program is likely to crash. Again, on a GNU system, although
    your program won't run, nothing more drastic than an error message
    from the operating system is likely to occur in such a case.

    []{#index-strcmp-function}

-   `strcmp` Compares two strings and returns a value that indicates
    which string comes first alphabetically. Example:

    +-----------------------------------+-----------------------------------+
    |                                   | ``` {.smallexample}               |
    |                                   | int comparison;                   |
    |                                   | char string1[] = "alpha";         |
    |                                   | char string2[] = "beta";          |
    |                                   |                                   |
    |                                   | comparison = strcmp (string1, str |
    |                                   | ing2);                            |
    |                                   | printf ("%d\n", comparison);      |
    |                                   | ```                               |
    +-----------------------------------+-----------------------------------+

    If the two strings are identical, `strcmp` returns 0. If the first
    string passed to `strcmp` comes alphabetically before the second
    (that is, the first string is "less than" the second one), `strcmp`
    returns a value less than 0. If the first string comes
    alphabetically after the second one (that is, the first string is
    "greater than" the second one), `strcmp` returns a value greater
    than zero. (Note that numbers come before letters in ASCII, and
    upper-case letters come before lower-case ones.)

    The example above prints out '-1', because 'alpha' is alphabetically
    "less than" 'beta'.

    In all cases below, `string1` comes alphabetically before `string2`,
    so `strcmp(string1, string2)` returns a negative value.

     '`string1`'

    :   `string2`

     'aaa'

    :   'aab'

     'aaa'

    :   'aaba'

     'aa'

    :   'aaa'

    []{#index-strcpy-function}

-   `strcpy` Copies a string into a string variable. Example:

    +-----------------------------------+-----------------------------------+
    |                                   | ``` {.smallexample}               |
    |                                   | char dest_string[50];             |
    |                                   | char source_string[] = "Are we no |
    |                                   | t men?";                          |
    |                                   |                                   |
    |                                   | /* Example 1 */                   |
    |                                   | strcpy (dest_string, source_strin |
    |                                   | g);                               |
    |                                   | printf ("%s\n", dest_string);     |
    |                                   |                                   |
    |                                   | /* Example 2 */                   |
    |                                   | strcpy (dest_string, "Are we havi |
    |                                   | ng fun yet?");                    |
    |                                   | printf ("%s\n", dest_string);     |
    |                                   | ```                               |
    +-----------------------------------+-----------------------------------+

    The example above produces this output:

    +-----------------------------------+-----------------------------------+
    |                                   | ``` {.smallexample}               |
    |                                   | Are we not men?                   |
    |                                   | Are we having fun yet?            |
    |                                   | ```                               |
    +-----------------------------------+-----------------------------------+

    **Notes:**

    -   The destination string in `strcmp` comes first, then the source
        string. This works in exactly the opposite way from the
        GNU/Linux shell command, `cp`.
    -   You can use `strcmp` to copy one string variable into another
        (Example 1), or to copy a string constant into a string variable
        (Example 2).
    -   Note the use of the characters '%s' in the `printf` statements
        to display a string, rather than '%d' to display an integer or
        '%f' to display a float.

    []{#index-strlen-function}

-   `strlen` Returns an integer that gives the length of a string in
    characters, not including the null character at the end of the
    string. The following example displays the number '5'.
    +-----------------------------------+-----------------------------------+
    |                                   | ``` {.smallexample}               |
    |                                   | int string_length                 |
    |                                   | char my_string[] = "fnord";       |
    |                                   |                                   |
    |                                   | string_length = strlen (my_string |
    |                                   | );                                |
    |                                   | printf ("%d\n", string_length);   |
    |                                   | ```                               |
    +-----------------------------------+-----------------------------------+

    []{#index-strncat-function}
-   `strncat` Works like `strcat`, but concatenates only a specified
    number of characters. The example below displays the string 'Hello,
    world! Bye'.
    +-----------------------------------+-----------------------------------+
    |                                   | ``` {.smallexample}               |
    |                                   | char string1[50] = "Hello, world! |
    |                                   |  ";                               |
    |                                   | char string2[] = "Bye now!";      |
    |                                   | strncat (string1, string2, 3);    |
    |                                   | printf ("%s\n", string1);         |
    |                                   | ```                               |
    +-----------------------------------+-----------------------------------+

    []{#index-strncmp-function}
-   `strncmp` Works like `strcmp`, but compares only a specified number
    of characters of both strings. The example below displays '0',
    because 'dogberry' and 'dogwood' are identical for their first three
    characters.
    +-----------------------------------+-----------------------------------+
    |                                   | ``` {.smallexample}               |
    |                                   | int comparison;                   |
    |                                   | char string1[] = "dogberry";      |
    |                                   | char string2[] = "dogwood";       |
    |                                   |                                   |
    |                                   | comparison = strncmp (string1, st |
    |                                   | ring2, 3);                        |
    |                                   | printf ("%d\n", comparison);      |
    |                                   | ```                               |
    +-----------------------------------+-----------------------------------+

    []{#index-strncpy-function}
-   `strncpy` Works like `strcpy`, but copies only a specified number of
    characters. The example below displays the string 'Are we', because
    only the first six characters of `source_string` are being copied
    into `dest_string`.

    +-----------------------------------+-----------------------------------+
    |                                   | ``` {.smallexample}               |
    |                                   | char dest_string[50];             |
    |                                   | char source_string[] = "Are we no |
    |                                   | t men?";                          |
    |                                   |                                   |
    |                                   | strncpy (dest_string, source_stri |
    |                                   | ng, 6);                           |
    |                                   | printf ("%s\n", dest_string);     |
    |                                   | ```                               |
    +-----------------------------------+-----------------------------------+

    **Note:** As in `strcmp`, the destination string in `strncmp` comes
    first, then the source string. This works in exactly the opposite
    way from the GNU/Linux shell command, `cp`.

    []{#index-strstr-function}

-   `strstr` Tests whether a substring is present in a larger string.
    Returns a pointer to the first occurrence of the substring in the
    larger string, or zero if the substring is not present. (When the
    substring is empty, `strstr` returns a pointer to the first
    character of the larger string.)

    The example below displays '\'foo\' is a substring of \'Got
    food?\'.'.

    +-----------------------------------+-----------------------------------+
    |                                   | ``` {.smallexample}               |
    |                                   | char string1[] = "Got food?";     |
    |                                   | char string2[] = "foo";           |
    |                                   |                                   |
    |                                   | if (strstr (string1, string2))    |
    |                                   |   printf("'%s' is a substring of  |
    |                                   | '%s'.\n", string2, string1);      |
    |                                   | ```                               |
    +-----------------------------------+-----------------------------------+

------------------------------------------------------------------------

[]{#Questions-for-Chapter-15}

  ------------------------------------------------------------------------- ------------------------------------------------------------- --- ---------------------------------------------------------------------- --------------------------------- ---------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#String-library-functions "Previous section in reading order")\]   \[[\>](#Input-and-output "Next section in reading order")\]       \[[\<\<](#Strings "Beginning of this chapter or previous chapter")\]   \[[Up](#Strings "Up section")\]   \[[\>\>](#Input-and-output "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ------------------------------------------------------------------------- ------------------------------------------------------------- --- ---------------------------------------------------------------------- --------------------------------- ---------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Questions-for-Chapter-15-1}

15.5 Questions for Chapter 15 {#questions-for-chapter-15 .section}
-----------------------------

1.  What are the three main ways of initializing string variables?
2.  How would you declare an array of strings?
3.  What information is returned by `strlen`?
4.  What does the function `strcat` do? How about `strncat`?
5.  Rewrite the Morse coder program more efficiently, using static
    strings. (See section [Example Listing](#Example-15), for the
    original version.)

------------------------------------------------------------------------

[]{#Input-and-output}

  ------------------------------------------------------------------------- ------------------------------------------------------------------------- --- ---------------------------------------------------------------------- ----------------------------- -------------------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Questions-for-Chapter-15 "Previous section in reading order")\]   \[[\>](#High_002dlevel-file-routines "Next section in reading order")\]       \[[\<\<](#Strings "Beginning of this chapter or previous chapter")\]   \[[Up](#Top "Up section")\]   \[[\>\>](#Putting-a-program-together "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ------------------------------------------------------------------------- ------------------------------------------------------------------------- --- ---------------------------------------------------------------------- ----------------------------- -------------------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Input-and-output-1}

16. Input and output {#input-and-output .chapter}
====================

[]{#index-Input-and-output} []{#index-Input} []{#index-Output}
[]{#index-GNU-C-Library}

*Input and output. Talking to the user. Why your printer is a file.*

In order for a program to do anything useful, it usually must do some
kind of input and output, whether input from the keyboard and output to
the screen, or input from and output to the computer's hard disk. While
the C language itself does not provide much in the way of input and
output functions, the GNU C Library contains so many facilities for
input and output that a whole book could be written about them. In this
chapter, we will focus on the basics. For more information on the
functions described in this chapter, and many more, we urge you to
consult [(The GNU C Library Reference
Manual)Top](The%20GNU%20C%20Library%20Reference%20Manual.html#Top).

Most objects from which you can receive input and to which you can send
output on a GNU system are considered to be files --- not only are files
on your hard disk (such as object code files, C source code files, and
ordinary ASCII text files) considered to be files, but also such
peripherals as your printer, your keyboard, and your computer monitor.
When you write a C program that prompts the user for input from the
keyboard, your program is *reading from*, or accepting input from, the
keyboard, in much the same way that it would read a text string from a
text file. Similarly, when your C program displays a text string on the
user's monitor, it is *writing to*, or sending output to, the terminal,
just as though it were writing a text string to a text file. In fact, in
many cases you'll be using the very same functions to read text from the
keyboard and from text files, and to write text to the terminal and to
text files.

[]{#index-Devices} []{#index-Peripherals}
[]{#index-Peripherals-as-devices}

This curious fact will be explored later in the chapter. For now it is
sufficient to say that when C treats your computer's peripherals as
files, they are known as *devices*, and each one has its own name,
called a *device name* or *pseudo-device name*. On a GNU system, the
printer might be called '`/dev/lp0`' (for "device line printer zero")
and the first floppy drive might be called '`/dev/fd0`' (for "device
floppy drive zero"). (Why zero in both cases? Most objects in the GNU
environment are counted by starting with zero, rather than one --- just
as arrays in C are zero-based.)

The advantage of treating devices as files is that it is often not
necessary to know how a particular device works, only that it is
connected to the computer and can be written to or read from. For
example, C programs often get their input from the keyboard, which C
refers to with the file name '`stdin`' (for "standard input"), and C
programs often send their output to the monitor's text display, referred
to as '`stdout`'. In some cases, '`stdin`' and '`stdout`' may refer to
things other than the keyboard and monitor; for example, the user may be
redirecting the output from your program to a text file with the `>`
command in GNU/Linux. The beauty of the way the standard input/output
library handles things is that your program will work just the same.

[]{#index-open-command} []{#index-fopen-command}
[]{#index-Opening-files} []{#index-Files_002c-opening}

Before you can read from or write to a file, you must first connect to
it, or *open* it, usually by either the `fopen` command, which returns
its stream, or the `open` command, which returns its file descriptor.
You can open a file for reading, writing, or both. You can also open a
file for *appending*, that is, writing data after the current end of the
file.

[]{#index-Streams} []{#index-File-descriptors}
[]{#index-Descriptors_002c-file}

Files are made known to functions not by their file names, except in a
few cases, but by identifiers called "streams" or "file descriptors".
For example, `printf` uses a stream as an identifier, not the name of
the file. So does `fclose`:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | fprintf (my_stream, "Just a littl |
|                                   | e hello from fprintf.\n");        |
|                                   | close_error = fclose (my_stream); |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

On the other hand, `fopen` takes a name, and returns a stream:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | my_stream = fopen (my_filename, " |
|                                   | w");                              |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

This is how you map from names to streams or file descriptors: you open
the file (for reading, writing, or both, or for appending), and the
value returned from the `open` or `fopen` function is the appropriate
file descriptor or stream.

[]{#index-High_002dlevel-file-operations}
[]{#index-Low_002dlevel-file-operations}
[]{#index-File-operations_002c-high_002dlevel}
[]{#index-File-operations_002c-low_002dlevel}
[]{#index-Files_002c-high_002dlevel-operations-on}
[]{#index-Files_002c-low_002dlevel-operations-on}

You can operate on a file either at a high level or at a low level.
Operating on a file at a high level means that you are using the file at
a high level of abstraction. (See section [Introduction](#Introduction),
to refresh your memory about the distinction between high and low levels
of abstraction.) Using high-level functions is usually safer and more
convenient than using low-level functions, so we will mostly concern
ourselves with high-level functions in this chapter, although we will
touch on some low-level functions toward the end.

[]{#index-Streams-1} []{#index-File-descriptors-1}
[]{#index-Descriptors_002c-file-1}

A high-level connection opened to a file is called a *stream*. A
low-level connection to a file is called a *file descriptor*. Streams
and file descriptors have different data types, as we shall see. You
must pass either a stream or a file descriptor to most input/output
functions, to tell them which file they are operating on. Certain
functions (usually high-level ones) expect to be passed streams, while
others (usually low-level ones) expect file descriptors. A few functions
will accept a simple filename instead of a stream or file descriptor,
but generally these are only the functions that initialize streams or
file descriptors in the first place.

You may consider it a nuisance to have to use a stream or a file
descriptor to access your file when a simple file name would seem to
suffice, but these two mechanisms allow a level of abstraction to exist
between your code and your files. Remember the "black box" analogy we
explored at the beginning of the book. By using the data in files only
through streams or file descriptors, we are guaranteed the ability to
write a rich variety of functions that can exploit the behavior of these
two "black box" abstractions.

Interestingly enough, although streams are considered to be for
"high-level" input/output, and file descriptors for "low-level" I/O, and
GNU systems support both, more Unix-like systems support streams than
file descriptors. You can expect any system running ISO C to support
streams, but non-GNU systems may not support file descriptors at all, or
may only implement a subset of the GNU functions that operate on file
descriptors. Most of the file descriptor functions in the GNU library
are included in the POSIX.1 standard, however.

Once you have finished your input and output operations on the file, you
must terminate your connection to it. This is called *closing* the file.
Once you have closed a file, you cannot read from or write to it anymore
until you open it again.

In summary, to use a file, a program must go through the following
routine:

-   Open the file for reading, writing, or both.
-   Read from or write to the file as appropriate, using file-handling
    functions provided by the GNU C Library.
-   Close the file

  ---------------------------------------------------------------------------------- ---- --
  [16.1 High-level file routines](#High_002dlevel-file-routines)                          
  [16.2 String output and input](#String-output-and-input)                                
  [16.3 Single-character input and output](#Single_002dcharacter-input-and-output)        
  [16.4 Programming with pipes](#Programming-with-pipes)                                  
  [16.5 Low-level file routines](#Low_002dlevel-file-routines)                            
  [16.6 Questions](#Questions-16)                                                         
  ---------------------------------------------------------------------------------- ---- --

------------------------------------------------------------------------

[]{#High_002dlevel-file-routines}

  ----------------------------------------------------------------- ----------------------------------------------------------- --- ------------------------------------------------------------------------------- ------------------------------------------ -------------------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Input-and-output "Previous section in reading order")\]   \[[\>](#Opening-a-file "Next section in reading order")\]       \[[\<\<](#Input-and-output "Beginning of this chapter or previous chapter")\]   \[[Up](#Input-and-output "Up section")\]   \[[\>\>](#Putting-a-program-together "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ----------------------------------------------------------------- ----------------------------------------------------------- --- ------------------------------------------------------------------------------- ------------------------------------------ -------------------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#High_002dlevel-file-routines-1}

16.1 High-level file routines {#high-level-file-routines .section}
-----------------------------

[]{#index-High_002dlevel-file-routines}
[]{#index-File-routines_002c-high_002dlevel}

You can recognise most of the high-level input/output functions that
operate on files because they begin with the letter 'f'; for example,
the high-level function for opening a file called `fopen`, as opposed to
the low-level file-opening function `open`. Some of them are more
generalized versions of functions with which you may already be
familiar; for example, the function `fprintf` behaves like the familiar
`printf`, but takes an additional parameter --- a stream --- and sends
all its output to that stream instead of simply sending its output to
'`stdout`', as `printf` does.

  ------------------------------------------------------------------------------------ ---- --
  [16.1.1 Opening a file](#Opening-a-file)                                                  
  [16.1.2 Closing a file](#Closing-a-file)                                                  
  [16.1.3 Block input and output](#Block-input-and-output)                                  
  [16.1.4 File position](#File-position)                                                    
  [16.1.5 Stream buffering](#Stream-buffering)                                              
  [16.1.6 End-of-file and error functions](#End_002dof_002dfile-and-error-functions)        
  ------------------------------------------------------------------------------------ ---- --

------------------------------------------------------------------------

[]{#Opening-a-file}

  ----------------------------------------------------------------------------- ----------------------------------------------------------- --- ------------------------------------------------------------------------------- ------------------------------------------------------ -------------------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#High_002dlevel-file-routines "Previous section in reading order")\]   \[[\>](#Closing-a-file "Next section in reading order")\]       \[[\<\<](#Input-and-output "Beginning of this chapter or previous chapter")\]   \[[Up](#High_002dlevel-file-routines "Up section")\]   \[[\>\>](#Putting-a-program-together "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ----------------------------------------------------------------------------- ----------------------------------------------------------- --- ------------------------------------------------------------------------------- ------------------------------------------------------ -------------------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Opening-a-file-1}

### 16.1.1 Opening a file {#opening-a-file .subsection}

[]{#index-Opening-files-1} []{#index-Files_002c-opening-1}
[]{#index-fopen-command-1}

The main high-level function for opening files is `fopen`. When you open
a file with the `fopen` function, the GNU C Library creates a new stream
and creates a connection between the stream and a file. If you pass this
function the name of a file that does not exist, that file will be
created. The `fopen` function normally returns a stream. A stream is a
flow of data from a source to a destination within a GNU system.
Programs can read characters from or write characters to a stream
without knowing either the source or destination of the data, which may
be a file on disk, a device such as a terminal meant as a human
interface, or something entirely different. Streams are represented by
variables of type `FILE *` --- `fopen` will return a null pointer if it
fails to open the file.

The first parameter to this function is a string containing the filename
of the file to open. The filename string can be either a constant or a
variable, as in the following two equivalent examples:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | FILE *my_stream;                  |
|                                   | my_stream = fopen ("foo", "r");   |
|                                   |                                   |
|                                   | FILE *my_stream;                  |
|                                   | char my_filename = "foo";         |
|                                   | my_stream2 = fopen (my_filename,  |
|                                   | "r");                             |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

The second parameter is a string containing one of the following sets of
characters:

 `r`

:   Open the file for reading only. The file must already exist.

 `w`

:   Open the file for writing only. If the file already exists, its
    current contents are deleted. If the file does not already exist, it
    is created.

 `r+`

:   Open the file for reading and writing. The file must already exist.
    The contents of the file are initially unchanged, but the file
    position is set to the beginning of the file.

 `w+`

:   Open the file for both writing and reading. If the file already
    exists, its current contents are deleted. If the file does not
    already exist, it is created.

 `a`

:   Open the file for appending only. Appending to a file is the same as
    writing to it, except that data is only written to the current end
    of the file. If the file does not already exist, it is created.

 `a+`

:   Open the file for both appending and reading. If the file exists,
    its contents are unchanged until appended to. If the file does not
    exist, it is created. The initial file position for reading is at
    the beginning of the file, but the file position for appending is at
    the end of the file.

See section [File position](#File-position), for more information on the
concept of file position.

You can also append the character 'x' after any of the strings in the
table above. This character causes `fopen` to fail rather than opening
the file if the file already exists. If you append 'x' to any of the
arguments above, you are guaranteed not to *clobber* (that is,
accidentally destroy) any file you attempt to open. (Any other
characters in this parameter are ignored on a GNU system, but may be
meaningful on other systems.)

The following example illustrates the proper use of `fopen` to open a
text file for reading (as well as highlighting the fact that you should
clean up after yourself by closing files after you are done with them).
Try running it once, then running it a second time after creating the
text file '`snazzyjazz.txt`' in the current directory with a GNU command
such as `touch snazzyjazz.txt`.

[]{#index-fopen-command-2} []{#index-fopen-command_002c-example-of}

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | #include <stdio.h>                |
|                                   |                                   |
|                                   | int main()                        |
|                                   | {                                 |
|                                   |   FILE *my_stream;                |
|                                   |                                   |
|                                   |   my_stream = fopen ("snazzyjazz. |
|                                   | txt", "r");                       |
|                                   | ```                               |
|                                   |                                   |
|                                   | ``` {.smallexample}               |
|                                   | ```                               |
|                                   |                                   |
|                                   | ``` {.smallexample}               |
|                                   |   if (my_stream == NULL)          |
|                                   |     {                             |
|                                   |       printf ("File could not be  |
|                                   | opened\n");                       |
|                                   |     }                             |
|                                   |   else                            |
|                                   |     {                             |
|                                   |       printf ("File opened!  Clos |
|                                   | ing it now...\n");                |
|                                   |       /* Close stream; skip error |
|                                   | -checking for brevity of example  |
|                                   | */                                |
|                                   |       fclose (my_stream);         |
|                                   |     }                             |
|                                   |   return 0;                       |
|                                   | }                                 |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

See section [Closing a file](#Closing-a-file), for more information on
the function `fclose`.

------------------------------------------------------------------------

[]{#Closing-a-file}

  --------------------------------------------------------------- ------------------------------------------------------------------- --- ------------------------------------------------------------------------------- ------------------------------------------------------ -------------------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Opening-a-file "Previous section in reading order")\]   \[[\>](#Block-input-and-output "Next section in reading order")\]       \[[\<\<](#Input-and-output "Beginning of this chapter or previous chapter")\]   \[[Up](#High_002dlevel-file-routines "Up section")\]   \[[\>\>](#Putting-a-program-together "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  --------------------------------------------------------------- ------------------------------------------------------------------- --- ------------------------------------------------------------------------------- ------------------------------------------------------ -------------------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Closing-a-file-1}

### 16.1.2 Closing a file {#closing-a-file .subsection}

[]{#index-Closing-files} []{#index-Files_002c-closing}
[]{#index-fclose-command}

The basic high-level function for closing files is `fclose`. Simply pass
this function a stream, and `fopen` will close it and break the
connection to the corresponding file, first reading any buffered input
and writing any buffered output. If the file was closed successfully,
`fclose` will return 0; otherwise, it will return `EOF`.

It is important to check for errors when you close a stream to which you
are writing. For example, when `fclose` attempts to write the output
remaining in its buffer, it might generate an error because the disk is
full. Following is an example of closing a file with write access, while
checking for errors.

[]{#index-fclose-command_002c-example-of}

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | #include <stdio.h>                |
|                                   |                                   |
|                                   | int main()                        |
|                                   | {                                 |
|                                   |   FILE *my_stream;                |
|                                   |   char my_filename[] = "snazzyjaz |
|                                   | z.txt";                           |
|                                   |   int close_error;                |
|                                   | ```                               |
|                                   |                                   |
|                                   | ``` {.smallexample}               |
|                                   | ```                               |
|                                   |                                   |
|                                   | ``` {.smallexample}               |
|                                   |   my_stream = fopen (my_filename, |
|                                   |  "w");                            |
|                                   |   fprintf (my_stream, "Just a lit |
|                                   | tle hello from fprintf.\n");      |
|                                   | ```                               |
|                                   |                                   |
|                                   | ``` {.smallexample}               |
|                                   | ```                               |
|                                   |                                   |
|                                   | ``` {.smallexample}               |
|                                   |   close_error = fclose (my_stream |
|                                   | );                                |
|                                   |                                   |
|                                   |   if (close_error != 0)           |
|                                   |     {                             |
|                                   |       printf ("File could not be  |
|                                   | closed.\n");                      |
|                                   |     }                             |
|                                   |   else                            |
|                                   |     {                             |
|                                   |       printf ("File closed.\n");  |
|                                   |     }                             |
|                                   |                                   |
|                                   |   return 0;                       |
|                                   | }                                 |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

------------------------------------------------------------------------

[]{#Block-input-and-output}

  --------------------------------------------------------------- ---------------------------------------------------------- --- ------------------------------------------------------------------------------- ------------------------------------------------------ -------------------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Closing-a-file "Previous section in reading order")\]   \[[\>](#File-position "Next section in reading order")\]       \[[\<\<](#Input-and-output "Beginning of this chapter or previous chapter")\]   \[[Up](#High_002dlevel-file-routines "Up section")\]   \[[\>\>](#Putting-a-program-together "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  --------------------------------------------------------------- ---------------------------------------------------------- --- ------------------------------------------------------------------------------- ------------------------------------------------------ -------------------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Block-input-and-output-1}

### 16.1.3 Block input and output {#block-input-and-output .subsection}

[]{#index-Block-input} []{#index-Block-output}
[]{#index-Input_002c-block} []{#index-Output_002c-block}
[]{#index-fread-function} []{#index-fwrite-function}

You can use the two functions in this section, `fread` and `fwrite`, to
read and write text in blocks of fixed size, rather than by line or
character. You can also use these two functions to read and write blocks
of binary data. This feature is useful if you want to read and write
data in the same format used by your program. For example, you can store
an entire multidimensional array of floating-point variables in a file
with the `fwrite` command, then read it back in directly later with the
`fread` command, without any loss of precision caused by converting the
floats to strings for use with the `fprintf` function, for example. (The
main drawback to using binary files rather than formatted ASCII text
files is that you cannot easily read and edit the files you create with
a text editor.)

[]{#index-Writing-arrays-to-streams}
[]{#index-Arrays_002c-writing-to-streams}
[]{#index-Streams_002c-writing-arrays-to} []{#index-fwrite-function-1}

For example, to write an array called `my_array`, containing
`object_count` data objects (such as integers), each of size
`object_size`, to the stream `my_stream`, you might use the following
line of code:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | fwrite (&my_array, object_size, o |
|                                   | bject_count, my_stream);          |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

[]{#index-Reading-arrays-from-streams}
[]{#index-Arrays_002c-reading-from-streams}
[]{#index-Streams_002c-reading-arrays-from} []{#index-fread-function-1}

To read `my_array` back from `my_stream`, you might then use the
following line:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | fread (&my_array, object_size, ob |
|                                   | ject_count, my_stream);           |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

Here is a short table to help you remember the directions in which
`fwrite` and `fread` work.

 `fwrite`

:   from an array, to a file

 `fread`

:   from a file, to an array

[]{#index-fwrite-function-2} []{#index-size_005ft-type}

The `fwrite` function takes four parameters. The first parameter to
`fwrite` is a void pointer (`void *`) to an array that contains the data
that will be written to the file. The second parameter is a variable of
type `size_t` specifying the size of each object to be written, and the
third parameter, also of type `size_t`, specifies the number of those
objects that are to be written. The final parameter is the stream to be
written to (type `FILE *`). If the value returned by `fopen` does not
match the third parameter passed (that is, the number of objects to be
written), then there was an error.

[]{#index-fread-function-2} []{#index-size_005ft-type-1}

Like `fwrite`, the `fread` function takes four parameters. Its first
parameter is a void pointer to the array that will be written to. Its
second parameter, of type `size_t`, specifies how large each object to
be read is, and its third parameter, of type `size_t`, specifies how
many of each object is to be read. The last parameter is simply the
stream to read from. Again, if the return value of this function does
not match the third parameter, which specifies how many object were to
be read, there was an error.

Here is an example that creates an array and fills it with multiples of
2, prints it out, writes the array's data to a file with `fwrite`,
zeroes the array and prints it out, reads the data from the file back
into the array with `fread`, then prints the array out again so you can
compare its data with the first set of data.

[]{#index-Writing-arrays-to-streams-1}
[]{#index-Arrays_002c-writing-to-streams-1}
[]{#index-Streams_002c-writing-arrays-to-1} []{#index-fwrite-function-3}
[]{#index-Reading-arrays-from-streams-1}
[]{#index-Arrays_002c-reading-from-streams-1}
[]{#index-Streams_002c-reading-arrays-from-1}
[]{#index-fread-function-3}

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | #include <stdio.h>                |
|                                   |                                   |
|                                   | int main()                        |
|                                   | {                                 |
|                                   |   int row, column;                |
|                                   |   FILE *my_stream;                |
|                                   |   int close_error;                |
|                                   |   char my_filename[] = "my_number |
|                                   | s.dat";                           |
|                                   |   size_t object_size = sizeof(int |
|                                   | );                                |
|                                   |   size_t object_count = 25;       |
|                                   |   size_t op_return;               |
|                                   | ```                               |
|                                   |                                   |
|                                   | ``` {.smallexample}               |
|                                   | ```                               |
|                                   |                                   |
|                                   | ``` {.smallexample}               |
|                                   |   int my_array[5][5] =            |
|                                   |   {                               |
|                                   |     2,  4,  6,  8, 10,            |
|                                   |     12, 14, 16, 18, 20,           |
|                                   |     22, 24, 26, 28, 30,           |
|                                   |     32, 34, 36, 38, 40,           |
|                                   |     42, 44, 46, 48, 50            |
|                                   |   };                              |
|                                   |   printf ("Initial values of arra |
|                                   | y:\n");                           |
|                                   |   for (row = 0; row <= 4; row++)  |
|                                   |     {                             |
|                                   |       for (column = 0; column <=4 |
|                                   | ; column++)                       |
|                                   |     {                             |
|                                   |       printf ("%d  ", my_array[ro |
|                                   | w][column]);                      |
|                                   |     }                             |
|                                   |       printf ("\n");              |
|                                   |     }                             |
|                                   | ```                               |
|                                   |                                   |
|                                   | ``` {.smallexample}               |
|                                   | ```                               |
|                                   |                                   |
|                                   | ``` {.smallexample}               |
|                                   |   my_stream = fopen (my_filename, |
|                                   |  "w");                            |
|                                   |   op_return = fwrite (&my_array,  |
|                                   | object_size, object_count, my_str |
|                                   | eam);                             |
|                                   |   if (op_return != object_count)  |
|                                   |     {                             |
|                                   |       printf ("Error writing data |
|                                   |  to file.\n");                    |
|                                   |     }                             |
|                                   |   else                            |
|                                   |     {                             |
|                                   |       printf ("Successfully wrote |
|                                   |  data to file.\n");               |
|                                   |     }                             |
|                                   |                                   |
|                                   |   /* Close stream; skip error-che |
|                                   | cking for brevity of example */   |
|                                   |   fclose (my_stream);             |
|                                   | ```                               |
|                                   |                                   |
|                                   | ``` {.smallexample}               |
|                                   | ```                               |
|                                   |                                   |
|                                   | ``` {.smallexample}               |
|                                   |   printf ("Zeroing array...\n");  |
|                                   |   for (row = 0; row <= 4; row++)  |
|                                   |     {                             |
|                                   |       for (column = 0; column <=4 |
|                                   | ; column++)                       |
|                                   |     {                             |
|                                   |       my_array[row][column] = 0;  |
|                                   |       printf ("%d  ", my_array[ro |
|                                   | w][column]);                      |
|                                   |     }                             |
|                                   |       printf ("\n");              |
|                                   |     }                             |
|                                   | ```                               |
|                                   |                                   |
|                                   | ``` {.smallexample}               |
|                                   | ```                               |
|                                   |                                   |
|                                   | ``` {.smallexample}               |
|                                   |   printf ("Now reading data back  |
|                                   | in...\n");                        |
|                                   |   my_stream = fopen (my_filename, |
|                                   |  "r");                            |
|                                   |   op_return = fread (&my_array, o |
|                                   | bject_size, object_count, my_stre |
|                                   | am);                              |
|                                   |   if (op_return != object_count)  |
|                                   |     {                             |
|                                   |       printf ("Error reading data |
|                                   |  from file.\n");                  |
|                                   |     }                             |
|                                   |   else                            |
|                                   |     {                             |
|                                   |       printf ("Successfully read  |
|                                   | data from file.\n");              |
|                                   |     }                             |
|                                   |   for (row = 0; row <= 4; row++)  |
|                                   |     {                             |
|                                   |       for (column = 0; column <=4 |
|                                   | ; column++)                       |
|                                   |     {                             |
|                                   |       printf ("%d  ", my_array[ro |
|                                   | w][column]);                      |
|                                   |     }                             |
|                                   |       printf ("\n");              |
|                                   |     }                             |
|                                   |                                   |
|                                   |   /* Close stream; skip error-che |
|                                   | cking for brevity of example */   |
|                                   |   fclose (my_stream);             |
|                                   |                                   |
|                                   |   return 0;                       |
|                                   | }                                 |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

If all goes well, the code example above will produce the following
output:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | Initial values of array:          |
|                                   | 2  4  6  8  10                    |
|                                   | 12  14  16  18  20                |
|                                   | 22  24  26  28  30                |
|                                   | 32  34  36  38  40                |
|                                   | 42  44  46  48  50                |
|                                   | Successfully wrote data to file.  |
|                                   | Zeroing array...                  |
|                                   | 0  0  0  0  0                     |
|                                   | 0  0  0  0  0                     |
|                                   | 0  0  0  0  0                     |
|                                   | 0  0  0  0  0                     |
|                                   | 0  0  0  0  0                     |
|                                   | Now reading data back in...       |
|                                   | Successfully read data from file. |
|                                   | 2  4  6  8  10                    |
|                                   | 12  14  16  18  20                |
|                                   | 22  24  26  28  30                |
|                                   | 32  34  36  38  40                |
|                                   | 42  44  46  48  50                |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

If you attempt to view the file '`my_numbers.dat`' produced by the
program above with a GNU command such as `more numbers.dat`, you will
see only garbage, because the information is stored in binary format,
not readable by humans. After attempting to view this binary file, your
terminal may continue to show only garbage and you may have to reset it.
You may be able to do this with a menu option (if you are running
`gnome-terminal`, for example), or you may have to type `reset` blindly.

------------------------------------------------------------------------

[]{#File-position}

  ----------------------------------------------------------------------- ------------------------------------------------------------- --- ------------------------------------------------------------------------------- ------------------------------------------------------ -------------------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Block-input-and-output "Previous section in reading order")\]   \[[\>](#Stream-buffering "Next section in reading order")\]       \[[\<\<](#Input-and-output "Beginning of this chapter or previous chapter")\]   \[[Up](#High_002dlevel-file-routines "Up section")\]   \[[\>\>](#Putting-a-program-together "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ----------------------------------------------------------------------- ------------------------------------------------------------- --- ------------------------------------------------------------------------------- ------------------------------------------------------ -------------------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#File-position-1}

### 16.1.4 File position {#file-position .subsection}

[]{#index-File-position}
[]{#index-File-position_002c-compared-to-bookmark}
[]{#index-Bookmark_002c-file-position-compared-to}

When a person reads a book, her "location" in the book can be specified
by a page number (and even a line number or word number, at finer levels
of detail). Just so, it is possible (and often useful!) to know the
location, or *file position*, of a stream reading from or writing to a
file. And just as we sometimes want to know which chapter a friend is
currently reading in a book, or to recommend that he flip backward or
forward to an interesting passage, so it is frequently useful to be able
to change the current file position to access a more interesting part of
the file.

At the high level of the functions in this section, GNU treats all
streams as streams of characters --- even binary streams like the one
associated with the file '`numbers.dat`' in the example for `fread` and
`fwrite`. (See section [Block input and
output](#Block-input-and-output).) This means that the file position of
any stream is a simple character count --- file position 0 means that we
are reading or writing the first character in the file, file position
522 means that we are reading the 523rd character, and so on. (Just as
with arrays in C, file positions are zero-based.)

[]{#index-Random_002daccess-files}
[]{#index-Files_002c-random_002daccess}
[]{#index-Random_002daccess-memory}
[]{#index-Memory_002c-random_002daccess} []{#index-RAM}

Not only does the file position of a stream describe where in the file
the stream is reading or writing, but reading or writing on the stream
advances the file position. During high-level access to a file, you can
change the file position at will. Any file that permits changing the
file position in an arbitrary way is called a *random-access file*.
(Many years ago, the people who invented computer jargon chose the word
"random" to be part of the phrase "random-access" because, from the
point of view of the computer, a random-access file can be read from or
written to at any location, as if at random. Of course, programmers are
not working randomly; they decide where their programs should read and
write. The term *RAM* for *random-access memory* comes from the same
source.)

[]{#index-ftell-function}

The main high-level function to tell where the current file position is,
is called appropriately, `ftell`. It accepts a single parameter --- a
file stream --- and returns a long integer representing the file
position.[(4)](#FOOT4){#DOCF4} (See [(Setting the File Position of a
Descriptor)File Position
Primitive](Setting%20the%20File%20Position%20of%20a%20Descriptor.html#File-Position-Primitive)
section 'libc' in The GNU C Library Reference Manual, for more
information.)

[]{#index-fseek-function}

The main function to seek a different file position is called `fseek`.
It accepts three parameters. The first parameter is the stream in
question, the second is a long integer offset, and the third parameter
is a constant that specifies whether the offset is relative to the
beginning of the file (`SEEK_SET`), to the current file position
(`SEEK_CUR`), or to the end of the file (`SEEK_END`). The `fseek`
function returns 0 if the operation was successful, or a nonzero integer
value otherwise. (A successful `fseek` operation also clears the
end-of-file indicator (see below), and discards the results of `ungetc`.
See section [`ungetc()`](#ungetc).)

[]{#index-rewind-macro}

There is a simple macro called `rewind` that will take the file pointer
back to the beginning of the file. You must simply pass it the stream
that you want to rewind; it does not return a value. It is the same as
calling `fseek` on the stream with an offset of 0 and a third parameter
of `SEEK_SET`, except that it resets the error indicator for the stream
and, as mentioned, there is no return value.

An example of these functions will not be useful until we have
introduced single-character I/O. See section [`getc` and
`fgetc`](#getc-and-fgetc), if you want to read a code example that uses
the `ftell`, `fseek`, and `rewind` functions.

------------------------------------------------------------------------

[]{#Stream-buffering}

  -------------------------------------------------------------- ------------------------------------------------------------------------------------ --- ------------------------------------------------------------------------------- ------------------------------------------------------ -------------------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#File-position "Previous section in reading order")\]   \[[\>](#End_002dof_002dfile-and-error-functions "Next section in reading order")\]       \[[\<\<](#Input-and-output "Beginning of this chapter or previous chapter")\]   \[[Up](#High_002dlevel-file-routines "Up section")\]   \[[\>\>](#Putting-a-program-together "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  -------------------------------------------------------------- ------------------------------------------------------------------------------------ --- ------------------------------------------------------------------------------- ------------------------------------------------------ -------------------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Stream-buffering-1}

### 16.1.5 Stream buffering {#stream-buffering .subsection}

[]{#index-Stream-buffering} []{#index-Buffering_002c-stream}
[]{#index-Buffers}

When you write characters to a stream, they are not usually stored in
the file on a character-by-character basis as soon as they are written
to the stream, but instead are accumulated in a *buffer* first, then
written to the file in a block when certain conditions are met. (A
buffer is an area of the computer's memory that acts as a temporary
holding area for input or output.) Similarly, when you are reading
characters from a stream, they are often *buffered*, or stored in a
buffer first.

It's important to understand how buffering works, or you may find your
programs behaving in an unexpected way, reading and writing characters
when you do not expect them to. (You can bypass stream buffering
entirely, however, by using low-level rather than high-level file
routines. See section [Low-level file
routines](#Low_002dlevel-file-routines), for more information.)

There are three main kinds of buffering you should know about:

-   []{#index-Buffering_002c-no} []{#index-No-buffering}
-   **No buffering:** When you write characters to an unbuffered stream,
    the operating system writes them to the file as soon as possible.
    []{#index-Line-buffering} []{#index-Buffering_002c-line}
-   **Line buffering:** When you write characters to a line-buffered
    stream, the operating system writes them to the file when it
    encounters a newline character. []{#index-Full-buffering}
    []{#index-Buffering_002c-full}
-   **Full buffering:** When you write characters to a fully-buffered
    stream, the operating system writes them to the file in blocks of
    arbitrary size.

[]{#index-Standard-input} []{#index-Standard-output}
[]{#index-stdin-device} []{#index-stdout-device}

Most streams are fully buffered when you open them, and this is usually
the best solution. However, streams connected to interactive devices
such as terminals are line-buffered when you open them; yes, this means
that '`stdin`' and '`stdout`' are line-buffered.

[]{#index-Daemons} []{#index-bdflush-daemon} []{#index-fflush-function}
[]{#index-Flushing-streams}

Having '`stdin`' and '`stdout`' be line-buffered is convenient, because
most meaningful chunks of data you write to them are terminated with a
newline character. In order to ensure that the data you read from or
write to a fully-buffered stream shows up right away, use the `fflush`
function. In the jargon, this is called *flushing* the stream. Flushing
moves the characters from the buffer to the file, if they haven't
already been moved. After the move, other functions can then work on the
characters.[(5)](#FOOT5){#DOCF5}

To use `fflush`, simply pass the function the stream you want to flush.
The `fflush` function returns 0 if successful, or the value `EOF` (which
is a macro defined in the GNU C Library) if there was a write error.

Note that using `fflush` is not always necessary; output is flushed
automatically when you try to write and the output buffer is already
full, when the stream is closed, when the program exits, when an input
operation on a stream actually reads data from the file, and of course,
when a newline is written to a line-buffered stream. (See section
[`fputs`](#fputs), for a code example that uses `fflush`.)

------------------------------------------------------------------------

[]{#End_002dof_002dfile-and-error-functions}

  ----------------------------------------------------------------- -------------------------------------------------------------------- --- ------------------------------------------------------------------------------- ------------------------------------------------------ -------------------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Stream-buffering "Previous section in reading order")\]   \[[\>](#String-output-and-input "Next section in reading order")\]       \[[\<\<](#Input-and-output "Beginning of this chapter or previous chapter")\]   \[[Up](#High_002dlevel-file-routines "Up section")\]   \[[\>\>](#Putting-a-program-together "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ----------------------------------------------------------------- -------------------------------------------------------------------- --- ------------------------------------------------------------------------------- ------------------------------------------------------ -------------------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#End_002dof_002dfile-and-error-functions-1}

### 16.1.6 End-of-file and error functions {#end-of-file-and-error-functions .subsection}

[]{#index-End_002dof_002dfile-functions} []{#index-Error-functions}
[]{#index-End_002dof_002dfile-indicator} []{#index-feof-function}

If a file has been read to its end (that is, the current file position
is the end of the file), a flag indicating this, called the *end-of-file
indicator*, will be set to `TRUE`. You can check whether the end-of-file
indicator has been set (and therefore whether the current file position
is the end of the file), with the `feof` function. This function takes a
single argument (a stream), and returns `TRUE` (a nonzero value) if the
end of the file has been reached, and `FALSE` (zero) otherwise.

[]{#index-Error-indicator} []{#index-ferror-function}

Another flag, the *error indicator*, indicates whether an error has
occurred during an earlier operation on the stream. It returns `TRUE` if
there has been an error, and `FALSE` otherwise. You can check the error
indicator for a stream with the `ferror` function. This function takes a
single argument (a stream), and returns `TRUE` (a nonzero value) if an
error has occured during an operation on the stream, and `FALSE` (zero)
otherwise.

Unfortunately, `ferror` will not tell you what the error was, or when it
occurred, only whether there has been an error. To get a more detailed
diagnosis, you can check the global system variable `errno`. (See
section [Usual file name errors](#Usual-file-name-errors).)

[]{#index-Error-indicator_002c-resetting}
[]{#index-End_002dof_002dfile-indicator_002c-resetting}
[]{#index-clearerr-function}

It is possible to reset the error and end-of-file indicators once they
have been set for a stream. To do so, simply pass the stream to the
function `clearerr`; this will set both the error and end-of-file
indicators back to 0. The `clearerr` function does not return a value.

You should not simply reset the error flag and try a stream operation
that failed a second time. Because of buffering, you may lose or repeat
data when writing, or access the wrong part of the file when reading.
Before you try a failed stream operation again, you should seek to a
known file position. (See section [File position](#File-position).)
However, most errors cannot be recovered from anyway --- trying the
operation again will likely result in the same error --- so it is
probably better to have your program report the error to the user and
exit than to write complicated error-recovery routines for stream
operation.

An example of these functions will not be useful until we have
introduced single-character I/O. See section [`getc` and
`fgetc`](#getc-and-fgetc), if you want to read a code example that uses
the `feof` and `ferror` functions.

------------------------------------------------------------------------

[]{#String-output-and-input}

  ---------------------------------------------------------------------------------------- ---------------------------------------------------------------------- --- ------------------------------------------------------------------------------- ------------------------------------------ -------------------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#End_002dof_002dfile-and-error-functions "Previous section in reading order")\]   \[[\>](#Unformatted-string-output "Next section in reading order")\]       \[[\<\<](#Input-and-output "Beginning of this chapter or previous chapter")\]   \[[Up](#Input-and-output "Up section")\]   \[[\>\>](#Putting-a-program-together "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ---------------------------------------------------------------------------------------- ---------------------------------------------------------------------- --- ------------------------------------------------------------------------------- ------------------------------------------ -------------------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#String-output-and-input-1}

16.2 String output and input {#string-output-and-input .section}
----------------------------

[]{#index-String-input} []{#index-String-output}
[]{#index-Input_002c-string} []{#index-Output_002c-string}
[]{#index-puts-function} []{#index-fputs-function}
[]{#index-gets-function} []{#index-fgets-function}
[]{#index-getline-function} []{#index-getdelim-function}

We will now examine some high-level file functions for reading strings
from and writing strings to streams. The two string output methods we
will examine (`puts` and `fputs`) are very safe to use, but the input
methods run from the antiquated and very dangerous `gets` to the safer
`fgets`, to `getline` and `getdelim`, two GNU-specific extensions to the
C language that are extremely safe to use.

It is important to use the safer and better GNU functions when you can.
However, you will probably still want to learn how to read and
understand older (but still free) code that is unsafe (perhaps to update
it and make it safe), so this book describes functions like `gets`
despite the fact that they are unsafe.

  ------------------------------------------------------------------------------------------------------ ---- --
  [16.2.1 Unformatted string output](#Unformatted-string-output)                                              
  [16.2.2 Formatted string output](#Formatted-string-output)                                                  
  [16.2.3 `fprintf`](#fprintf)                                                                                
  [16.2.4 `asprintf`](#asprintf)                                                                              
  [16.2.5 Deprecated formatted string output functions](#Deprecated-formatted-string-output-functions)        
  [16.2.6 String input](#String-input)                                                                        
  [16.2.7 Deprecated string input functions](#Deprecated-string-input-functions)                              
  [16.2.8 Formatted string input](#Formatted-string-input)                                                    
  [16.2.9 Deprecated formatted string input functions](#Deprecated-formatted-string-input-functions)          
  [16.2.10 `fscanf`](#fscanf)                                                                                 
  ------------------------------------------------------------------------------------------------------ ---- --

------------------------------------------------------------------------

[]{#Unformatted-string-output}

  ------------------------------------------------------------------------ ------------------------------------------------- --- ------------------------------------------------------------------------------- ------------------------------------------------- -------------------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#String-output-and-input "Previous section in reading order")\]   \[[\>](#puts "Next section in reading order")\]       \[[\<\<](#Input-and-output "Beginning of this chapter or previous chapter")\]   \[[Up](#String-output-and-input "Up section")\]   \[[\>\>](#Putting-a-program-together "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ------------------------------------------------------------------------ ------------------------------------------------- --- ------------------------------------------------------------------------------- ------------------------------------------------- -------------------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Unformatted-string-output-1}

### 16.2.1 Unformatted string output {#unformatted-string-output .subsection}

[]{#index-Unformatted-string-output}
[]{#index-String-output_002c-unformatted}
[]{#index-Output_002c-unformatted-string}

The functions in this section are for output of strings to streams. They
are generally very safe to use.

  ---------------------------- ---- --
  [16.2.1.1 `puts`](#puts)          
  [16.2.1.2 `fputs`](#fputs)        
  ---------------------------- ---- --

------------------------------------------------------------------------

[]{#puts}

  -------------------------------------------------------------------------- -------------------------------------------------- --- ------------------------------------------------------------------------------- --------------------------------------------------- -------------------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Unformatted-string-output "Previous section in reading order")\]   \[[\>](#fputs "Next section in reading order")\]       \[[\<\<](#Input-and-output "Beginning of this chapter or previous chapter")\]   \[[Up](#Unformatted-string-output "Up section")\]   \[[\>\>](#Putting-a-program-together "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  -------------------------------------------------------------------------- -------------------------------------------------- --- ------------------------------------------------------------------------------- --------------------------------------------------- -------------------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#puts-1}

#### 16.2.1.1 `puts` {#puts .subsubsection}

[]{#index-puts-function-1}

The most convenient function for printing a simple message on standard
outout is `puts`. It is even simpler than `printf`, since you do not
need to include a newline character --- `puts` does that for you.

Using `puts` couldn't be simpler. Here is an example:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | puts ("Hello, multiverse.");      |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

This code example will print the string 'Hello, multiverse.' to standard
output.

The `puts` function is safe and simple, but not very flexible. See
section [Formatted string output](#Formatted-string-output), if you want
to print fancier output.

------------------------------------------------------------------------

[]{#fputs}

  ----------------------------------------------------- -------------------------------------------------------------------- --- ------------------------------------------------------------------------------- --------------------------------------------------- -------------------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#puts "Previous section in reading order")\]   \[[\>](#Formatted-string-output "Next section in reading order")\]       \[[\<\<](#Input-and-output "Beginning of this chapter or previous chapter")\]   \[[Up](#Unformatted-string-output "Up section")\]   \[[\>\>](#Putting-a-program-together "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ----------------------------------------------------- -------------------------------------------------------------------- --- ------------------------------------------------------------------------------- --------------------------------------------------- -------------------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#fputs-1}

#### 16.2.1.2 `fputs` {#fputs .subsubsection}

[]{#index-fputs-function-1}

The `fputs` ("file put string") function is similar to the `puts`
function in almost every respect, except that it accepts a second
parameter, a stream to which to write the string. It does not add a
newline character, however; it only writes the characters in the string.
It returns `EOF` if an error occurs; otherwise it returns a non-negative
integer value.

Here is a brief code example that creates a text file and uses `fputs`
to write into it the phrase 'If it\'s not too late\... make it a
cheeseburger.', followed by a newline character. This example also
demonstrates the use of the `fflush` function. (See section [Stream
buffering](#Stream-buffering), for more information on this function.)

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | #include <stdio.h>                |
|                                   |                                   |
|                                   | int main()                        |
|                                   | {                                 |
|                                   |   FILE *my_stream;                |
|                                   |   char my_filename[] = "snazzyjaz |
|                                   | z.txt";                           |
|                                   |   int flush_status;               |
|                                   | ```                               |
|                                   |                                   |
|                                   | ``` {.smallexample}               |
|                                   | ```                               |
|                                   |                                   |
|                                   | ``` {.smallexample}               |
|                                   |   my_stream = fopen (my_filename, |
|                                   |  "w");                            |
|                                   |   fputs ("If it's not too late... |
|                                   |  make it a cheeseburger.\n", my_s |
|                                   | tream);                           |
|                                   | ```                               |
|                                   |                                   |
|                                   | ``` {.smallexample}               |
|                                   | ```                               |
|                                   |                                   |
|                                   | ``` {.smallexample}               |
|                                   |   /*                              |
|                                   |      Since the stream is fully-bu |
|                                   | ffered by default, not line-buffe |
|                                   | red,                              |
|                                   |      it needs to be flushed perio |
|                                   | dically.  We'll flush it here for |
|                                   |      demonstration purposes, even |
|                                   |  though we're about to close it.  |
|                                   |                                   |
|                                   |   */                              |
|                                   |   flush_status = fflush (my_strea |
|                                   | m);                               |
|                                   |   if (flush_status != 0)          |
|                                   |     {                             |
|                                   |       puts ("Error flushing strea |
|                                   | m!");                             |
|                                   |     }                             |
|                                   |   else                            |
|                                   |     {                             |
|                                   |       puts ("Stream flushed.");   |
|                                   |     }                             |
|                                   | ```                               |
|                                   |                                   |
|                                   | ``` {.smallexample}               |
|                                   | ```                               |
|                                   |                                   |
|                                   | ``` {.smallexample}               |
|                                   |   /* Close stream; skip error-che |
|                                   | cking for brevity of example */   |
|                                   |   fclose (my_stream);             |
|                                   |                                   |
|                                   |   return 0;                       |
|                                   | }                                 |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

------------------------------------------------------------------------

[]{#Formatted-string-output}

  ------------------------------------------------------ --------------------------------------------------- --- ------------------------------------------------------------------------------- ------------------------------------------------- -------------------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#fputs "Previous section in reading order")\]   \[[\>](#printf "Next section in reading order")\]       \[[\<\<](#Input-and-output "Beginning of this chapter or previous chapter")\]   \[[Up](#String-output-and-input "Up section")\]   \[[\>\>](#Putting-a-program-together "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ------------------------------------------------------ --------------------------------------------------- --- ------------------------------------------------------------------------------- ------------------------------------------------- -------------------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Formatted-string-output-1}

### 16.2.2 Formatted string output {#formatted-string-output .subsection}

[]{#index-Formatted-string-output}
[]{#index-String-output_002c-formatted}
[]{#index-Output_002c-formatted-string}

The functions in this section are for formatted output of strings to
streams. They are generally quite safe to use.

Formatted output is textual output via functions such as `printf` or
`fprintf`. These take as an argument a string containing special
character sequences such as '%d' (which indicates that an integer
argument will follow). After this string, other arguments that
correspond to the special character sequences follow. When the functions
combine these arguments, the result is formatted textual output.

The next several sections discuss four formatted output functions. The
most basic, `printf`, prints to standard output. The `fprintf` function
is a high-level routine that sends its output to a stream, `sprintf`
"prints" to a string, and `asprintf` is a safer way of printing to a
string.

  -------------------------------------------------------------------------------------------- ---- --
  [16.2.2.1 `printf`](#printf)                                                                      
  [16.2.2.2 Formatted output conversion specifiers](#Formatted-output-conversion-specifiers)        
  -------------------------------------------------------------------------------------------- ---- --

------------------------------------------------------------------------

[]{#printf}

  ------------------------------------------------------------------------ ----------------------------------------------------------------------------------- --- ------------------------------------------------------------------------------- ------------------------------------------------- -------------------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Formatted-string-output "Previous section in reading order")\]   \[[\>](#Formatted-output-conversion-specifiers "Next section in reading order")\]       \[[\<\<](#Input-and-output "Beginning of this chapter or previous chapter")\]   \[[Up](#Formatted-string-output "Up section")\]   \[[\>\>](#Putting-a-program-together "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ------------------------------------------------------------------------ ----------------------------------------------------------------------------------- --- ------------------------------------------------------------------------------- ------------------------------------------------- -------------------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#printf-1}

#### 16.2.2.1 `printf` {#printf .subsubsection}

[]{#index-printf-function}

If you have been reading the book closely up to this point, you have
seen the use of the `printf` function many times. To recap, this
function prints a text string to the terminal (or, to be more precise,
the text stream '`stdout`'). For example, the following line of code
prints the string 'Hello there!', followed by a newline character, to
the console:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | printf ("Hello there!\n");        |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

You probably also remember that you can incorporate numeric constants
and variables into your strings. Consider the following code example:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | printf ("I'm free!  I'm free!  (S |
|                                   | o what?  I'm %d.)\n", 4);         |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

The previous example is equivalent to the following one:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | int age = 4;                      |
|                                   | printf ("I'm free!  I'm free!  (S |
|                                   | o what?  I'm %d.)\n", age);       |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

Both of the code examples above produce the following output:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | I'm free!  I'm free!  (So what?   |
|                                   | I'm 4.)                           |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

You may recall that besides using '%d' with `printf` to print integers,
we have also used '%f' on occasion to print floating-point numbers, and
that on occasion we have used more than one argument. Consider this
example:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | printf ("I'm free!  I'm free!  (S |
|                                   | o what?  I'm %d.)  Well, I'm %f.\ |
|                                   | n", 4, 4.5);                      |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

That example produces the following output:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | I'm free!  I'm free!  (So what?   |
|                                   | I'm 4.)  Well, I'm 4.500000.      |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

[]{#index-Format-strings_002c-printf} []{#index-printf-format-strings}

In fact, `printf` is a very flexible function. The general scheme is
that you provide it with a *format string* or *template string* (such as
'\"So what? I\'m %d.\"'), which can contain zero or more *conversion
specifications*, *conversion specifiers*, or sometimes just
*conversions* (in this case '%d'), and zero or more arguments (for
example, '4'). Each conversion specification is said to specify a
*conversion*, that is, how to convert its corresponding argument into a
printable string. After the template string, you supply one argument for
each conversion specifier in the template string. The `printf` function
then prints the template string, including each argument as converted to
a printable sub-string by its conversion specifier, and returns an
integer containing the number of characters printed, or a negative value
if there was an error.

------------------------------------------------------------------------

[]{#Formatted-output-conversion-specifiers}

  ------------------------------------------------------- ---------------------------------------------------- --- ------------------------------------------------------------------------------- ------------------------------------------------- -------------------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#printf "Previous section in reading order")\]   \[[\>](#fprintf "Next section in reading order")\]       \[[\<\<](#Input-and-output "Beginning of this chapter or previous chapter")\]   \[[Up](#Formatted-string-output "Up section")\]   \[[\>\>](#Putting-a-program-together "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ------------------------------------------------------- ---------------------------------------------------- --- ------------------------------------------------------------------------------- ------------------------------------------------- -------------------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Formatted-output-conversion-specifiers-1}

#### 16.2.2.2 Formatted output conversion specifiers {#formatted-output-conversion-specifiers .subsubsection}

[]{#index-Formatted-output-conversion-specifiers}
[]{#index-Output-conversion-specifiers_002c-formatted}
[]{#index-Conversion-specifiers_002c-formatted-output}

There are many different conversion specifiers that can be used for
various data types. Conversion specifiers can become quite complex; for
example, '%-17.7ld' specifies that `printf` should print the number
left-justified ('-'), in a field at least seventeen characters wide
('17'), with a minimum of seven digits ('.7'), and that the number is a
long integer ('l') and should be printed in decimal notation ('%d').

In this section, we will examine the basics of `printf` and its
conversion specifiers. (For even more detail, [(libc)Formatted
Output](libc.html#Formatted-Output) section 'Formatted Output' in The
GNU C Library Reference Manual.)

A conversion specifier begins with a percent sign, and ends with one of
the following *output conversion characters*. The most basic conversion
specifiers simply use a percent sign and one of these characters, such
as '%d' to print an integer. (Note that characters in the template
string that are not part of a conversion specifier are printed as-is.)

[]{#index-Formatted-output-conversion-specifiers_002c-table-of}
[]{#index-Output-conversion-specifiers_002c-formatted_002c-table-of}
[]{#index-Conversion-specifiers_002c-formatted-output_002c-table-of}

[]{#index-c-output-conversion-specifier}

'c'

Print a single character.

[]{#index-d-output-conversion-specifier}

'd'

Print an integer as a signed decimal number.

[]{#index-e-output-conversion-specifier}

'e'

Print a floating-point number in exponential notation, using lower-case
letters. The exponent always contains at least two digits. Example:
'6.02e23'.

[]{#index-E-output-conversion-specifier}

'E'

Same as 'e', but uses upper-case letters. Example: '6.02E23'.

[]{#index-f-output-conversion-specifier}

'f'

Print a floating-point number in normal, fixed-point notation.

[]{#index-i-output-conversion-specifier}

'i'

Same as 'd'.

[]{#index-m-output-conversion-specifier}

'm'

Print the string corresponding to the specified value of the system
`errno` variable. (See section [Usual file name
errors](#Usual-file-name-errors).) GNU systems only.

[]{#index-s-output-conversion-specifier}

's'

Print a string.

[]{#index-u-output-conversion-specifier}

'u'

Print an unsigned integer.

[]{#index-x-output-conversion-specifier}

'x'

Print an integer as an unsigned hexadecimal number, using lower-case
letters.

[]{#index-X-output-conversion-specifier}

'X'

Same as 'x', but uses upper-case letters.

[]{#index-_0025-output-conversion-specifier}

'%'

Print a percent sign ('%').

In between the percent sign ('%') and the output conversion character,
you can place some combination of the following *modifiers*. (Note that
the percent sign conversion ('%%') doesn't use arguments or modifiers.)

[]{#index-Formatted-output-conversion-specifiers_002c-modifiers}
[]{#index-Output-conversion-specifiers_002c-formatted_002c-modifiers}
[]{#index-Conversion-specifiers_002c-formatted-output_002c-modifiers}

-   Zero or more flag characters, from the following table:

    []{#index-_002d-output-conversion-specifier-modifier}

    '-'

    Left-justify the number in the field (right justification is the
    default). Can also be used for string and character conversions
    ('%s' and '%c').

    []{#index-_002b-output-conversion-specifier-modifier}

    '+'

    Always print a plus or minus sign to indicate whether the number is
    positive or negative. Valid for '%d', '%e', '%E', and '%i'.

    []{#index-SPACE-output-conversion-specifier-modifier}

    'Space character'

    If the number does not start with a plus or minus sign, prefix it
    with a space character instead. This flag is ignored if the '+' flag
    is specified.

    []{#index-_0023-output-conversion-specifier-modifier}

    '\#'

    For '%e', '%E', and '%f', forces the number to include a decimal
    point, even if no digits follow. For '%x' and '%X', prefixes '0x' or
    '0X', respectively.

    []{#index-_0027-output-conversion-specifier-modifier}

    '\''

    Separate the digits of the integer part of the number into groups,
    using a locale-specific character. In the United States, for
    example, this will usually be a comma, so that one million will be
    rendered '1,000,000'. GNU systems only.

    []{#index-0-output-conversion-specifier-modifier}

    '0'

    Pad the field with zeroes instead of spaces; any sign or indication
    of base (such as '0x') will be printed before the zeroes. This flag
    is ignored if the '-' flag or a precision is specified.

    In the example given above, '%-17.7ld', the flag given is '-'.

-   An optional non-negative decimal integer specifying the minimum
    field width within which the conversion will be printed. If the
    conversion contains fewer characters, it will be padded with spaces
    (or zeroes, if the '0' flag was specified). If the conversion
    contains more characters, it will not be truncated, and will
    overflow the field. The output will be right-justified within the
    field, unless the '-' flag was specified. In the example given
    above, '%-17.7ld', the field width is '17'.
-   For numeric conversions, an optional precision that specifies the
    number of digits to be written. If it is specified, it consists of a
    dot character ('.'), followed by a non-negative decimal integer
    (which may be omitted, and defaults to zero if it is). In the
    example given above, '%-17.7ld', the precision is '.7'. Leading
    zeroes are produced if necessary. If you don't specify a precision,
    the number is printed with as many digits as necessary (with a
    default of six digits after the decimal point). If you supply an
    argument of zero with and explicit precision of zero, `printf` will
    not print any characters. Specifying a precision for a string
    conversion ('%s') indicates the maximum number of characters to
    write.
-   An optional *type modifier character* from the table below. This
    character specifies the data type of the argument if it is different
    from the default. In the example given above, '%-17.7ld', the type
    modifier character is 'l'; normally, the 'd' output conversion
    character expects a data type of `int`, but the 'l' specifies that a
    `long int` is being used instead.

    The numeric conversions usually expect an argument of either type
    `int`, `unsigned int`, or `double`. (The '%c' conversion converts
    its argument to `unsigned char`.) For the integer conversions ('%d'
    and '%i'), `char` and `short` arguments are automatically converted
    to type `int`, and for the unsigned integer conversions ('%u', '%x',
    and '%X'), they are converted to type `unsigned int`. For the
    floating-point conversions ('%e', '%E', and '%f'), all `float`
    arguments are converted to type `double`. You can use one of the
    type modifiers from the table below to specify another type of
    argument.

    []{#index-Formatted-output-conversion-specifiers_002c-modifiers-1}
    []{#index-Output-conversion-specifiers_002c-formatted_002c-modifiers-1}
    []{#index-Conversion-specifiers_002c-formatted-output_002c-modifiers-1}

    []{#index-l-output-conversion-specifier-modifier}

    'l'

    Specifies that the argument is a `long int` (for '%d' and '%i'), or
    an `unsigned long int` (for '%u', '%x', and '%X').

    []{#index-L-output-conversion-specifier-modifier}

    'L'

    Specifies that the argument is a `long double` for the
    floating-point conversions ('%e', '%E', and '%f'). Same as 'll', for
    integer conversions ('%d' and '%i').

    []{#index-ll-output-conversion-specifier-modifier}

    'll'

    Specifies that the argument is a `long long int` (for '%d' and
    '%i'). On systems that do not have extra-long integers, this has the
    same effect as 'l'.

    []{#index-q-output-conversion-specifier-modifier}

    'q'

    Same as 'll'; comes from calling extra-long integers "quad ints".

    []{#index-z-output-conversion-specifier-modifier}

    'z'

    Same as 'Z', but GNU only, and deprecated.

    []{#index-Z-output-conversion-specifier-modifier}

    'Z'

    Specifies that the argument is of type `size_t`. (The `size_t` type
    is used to specify the sizes of blocks of memory, and many functions
    in this chapter use it.)

Make sure that your conversion specifiers use valid syntax; if they do
not, if you do not supply enough arguments for all conversion
specifiers, or if any arguments are of the wrong type, unpredictable
results may follow. Supplying too many arguments is not a problem,
however; the extra arguments are simply ignored.

Here is a code example that shows various uses of `printf`.

[]{#index-printf-function-1} []{#index-printf_002c-example-of}

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | #include <stdio.h>                |
|                                   | #include <errno.h>                |
|                                   |                                   |
|                                   | int main()                        |
|                                   | {                                 |
|                                   |   int my_integer = -42;           |
|                                   |   unsigned int my_ui = 23;        |
|                                   |   float my_float = 3.56;          |
|                                   |   double my_double = 424242.17171 |
|                                   | 7;                                |
|                                   |   char my_char = 'w';             |
|                                   |   char my_string[] = "Pardon me,  |
|                                   | may I borrow your nose?";         |
|                                   |                                   |
|                                   |   printf ("Integer: %d\n", my_int |
|                                   | eger);                            |
|                                   |   printf ("Unsigned integer: %u\n |
|                                   | ", my_ui);                        |
|                                   |                                   |
|                                   |   printf ("The same, as hexadecim |
|                                   | al: %#x %#x\n", my_integer, my_ui |
|                                   | );                                |
|                                   |                                   |
|                                   |   printf ("Floating-point: %f\n", |
|                                   |  my_float);                       |
|                                   |   printf ("Double, exponential no |
|                                   | tation: %17.11e\n", my_double);   |
|                                   |                                   |
|                                   |   printf ("Single character: %c\n |
|                                   | ", my_char);                      |
|                                   |   printf ("String: %s\n", my_stri |
|                                   | ng);                              |
|                                   |                                   |
|                                   |   errno = EACCES;                 |
|                                   |   printf ("errno string (EACCES): |
|                                   |  %m\n");                          |
|                                   |                                   |
|                                   |   return 0;                       |
|                                   | }                                 |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

The code example above produces the following output on a GNU system:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | Integer: -42                      |
|                                   | Unsigned integer: 23              |
|                                   | The same, as hexadecimal: 0xfffff |
|                                   | fd6 0x17                          |
|                                   | Floating-point: 3.560000          |
|                                   | Double, exponential notation: 4.2 |
|                                   | 4242171717e+05                    |
|                                   | Single character: w               |
|                                   | String: Pardon me, may I borrow y |
|                                   | our nose?                         |
|                                   | errno string (EACCES): Permission |
|                                   |  denied                           |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

------------------------------------------------------------------------

[]{#fprintf}

  --------------------------------------------------------------------------------------- ----------------------------------------------------- --- ------------------------------------------------------------------------------- ------------------------------------------------- -------------------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Formatted-output-conversion-specifiers "Previous section in reading order")\]   \[[\>](#asprintf "Next section in reading order")\]       \[[\<\<](#Input-and-output "Beginning of this chapter or previous chapter")\]   \[[Up](#String-output-and-input "Up section")\]   \[[\>\>](#Putting-a-program-together "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  --------------------------------------------------------------------------------------- ----------------------------------------------------- --- ------------------------------------------------------------------------------- ------------------------------------------------- -------------------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#fprintf-1}

### 16.2.3 `fprintf` {#fprintf .subsection}

[]{#index-fprintf-function}

The `fprintf` ("file print formatted") command is identical to `printf`,
except that its first parameter is a stream to which to send output. The
following code example is the same as the one for `printf`, except that
it sends its output to the text file '`snazzyjazz.txt`'.

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | #include <stdio.h>                |
|                                   | #include <errno.h>                |
|                                   |                                   |
|                                   | int main()                        |
|                                   | {                                 |
|                                   |   int my_integer = -42;           |
|                                   |   unsigned int my_ui = 23;        |
|                                   |   float my_float = 3.56;          |
|                                   |   double my_double = 424242.17171 |
|                                   | 7;                                |
|                                   |   char my_char = 'w';             |
|                                   |   char my_string[] = "Pardon me,  |
|                                   | may I borrow your nose?";         |
|                                   | ```                               |
|                                   |                                   |
|                                   | ``` {.smallexample}               |
|                                   | ```                               |
|                                   |                                   |
|                                   | ``` {.smallexample}               |
|                                   |   FILE *my_stream;                |
|                                   |   char my_filename[] = "snazzyjaz |
|                                   | z.txt";                           |
|                                   |   my_stream = fopen (my_filename, |
|                                   |  "w");                            |
|                                   | ```                               |
|                                   |                                   |
|                                   | ``` {.smallexample}               |
|                                   | ```                               |
|                                   |                                   |
|                                   | ``` {.smallexample}               |
|                                   |   fprintf (my_stream, "Integer: % |
|                                   | d\n", my_integer);                |
|                                   |   fprintf (my_stream, "Unsigned i |
|                                   | nteger: %u\n", my_ui);            |
|                                   |                                   |
|                                   |   fprintf (my_stream, "The same,  |
|                                   | as hexadecimal: %#x %#x\n", my_in |
|                                   | teger, my_ui);                    |
|                                   |                                   |
|                                   |   fprintf (my_stream, "Floating-p |
|                                   | oint: %f\n", my_float);           |
|                                   |   fprintf (my_stream, "Double, ex |
|                                   | ponential notation: %17.11e\n", m |
|                                   | y_double);                        |
|                                   |                                   |
|                                   |   fprintf (my_stream, "Single cha |
|                                   | racter: %c\n", my_char);          |
|                                   |   fprintf (my_stream, "String: %s |
|                                   | \n", my_string);                  |
|                                   | ```                               |
|                                   |                                   |
|                                   | ``` {.smallexample}               |
|                                   | ```                               |
|                                   |                                   |
|                                   | ``` {.smallexample}               |
|                                   |   errno = EACCES;                 |
|                                   |   fprintf (my_stream, "errno stri |
|                                   | ng (EACCES): %m\n");              |
|                                   |                                   |
|                                   |   /* Close stream; skip error-che |
|                                   | cking for brevity of example */   |
|                                   |   fclose (my_stream);             |
|                                   |                                   |
|                                   |   return 0;                       |
|                                   | }                                 |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

------------------------------------------------------------------------

[]{#asprintf}

  -------------------------------------------------------- ----------------------------------------------------------------------------------------- --- ------------------------------------------------------------------------------- ------------------------------------------------- -------------------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#fprintf "Previous section in reading order")\]   \[[\>](#Deprecated-formatted-string-output-functions "Next section in reading order")\]       \[[\<\<](#Input-and-output "Beginning of this chapter or previous chapter")\]   \[[Up](#String-output-and-input "Up section")\]   \[[\>\>](#Putting-a-program-together "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  -------------------------------------------------------- ----------------------------------------------------------------------------------------- --- ------------------------------------------------------------------------------- ------------------------------------------------- -------------------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#asprintf-1}

### 16.2.4 `asprintf` {#asprintf .subsection}

[]{#index-asprintf-function}

The `asprintf` (mnemonic: "allocating string print formatted") command
is identical to `printf`, except that its first parameter is a string to
which to send output. It terminates the string with a null character. It
returns the number of characters stored in the string, not including the
terminating null.

The `asprintf` function is nearly identical to the simpler `sprintf`,
but is much safer, because it dynamically allocates the string to which
it sends output, so that the string will never overflow. The first
parameter is a pointer to a string variable, that is, it is of type
`char **`. The return value is the number of characters allocated to the
buffer, or a negative value if an error occurred.

The following code example prints the string 'Being 4 is cool, but being
free is best of all.' to the string variable `my_string`, then prints
the string on the screen. Notice that `my_string` is not initially
allocated any space at all; `asprintf` allocates the space itself. (See
section [`puts`](#puts), for more information on the `puts` function.)

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | #include <stdio.h>                |
|                                   |                                   |
|                                   | int main()                        |
|                                   | {                                 |
|                                   |   char *my_string;                |
|                                   |                                   |
|                                   |   asprintf (&my_string, "Being %d |
|                                   |  is cool, but being free is best  |
|                                   | of all.", 4);                     |
|                                   |   puts (my_string);               |
|                                   |                                   |
|                                   |   return 0;                       |
|                                   | }                                 |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

------------------------------------------------------------------------

[]{#Deprecated-formatted-string-output-functions}

  --------------------------------------------------------- ---------------------------------------------------- --- ------------------------------------------------------------------------------- ------------------------------------------------- -------------------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#asprintf "Previous section in reading order")\]   \[[\>](#sprintf "Next section in reading order")\]       \[[\<\<](#Input-and-output "Beginning of this chapter or previous chapter")\]   \[[Up](#String-output-and-input "Up section")\]   \[[\>\>](#Putting-a-program-together "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  --------------------------------------------------------- ---------------------------------------------------- --- ------------------------------------------------------------------------------- ------------------------------------------------- -------------------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Deprecated-formatted-string-output-functions-1}

### 16.2.5 Deprecated formatted string output functions {#deprecated-formatted-string-output-functions .subsection}

[]{#index-sprintf-function}
[]{#index-Deprecated-formatted-string-output-functions}
[]{#index-Formatted-string-output-functions_002c-deprecated}
[]{#index-String-output-functions_002c-formatted_002c-deprecated}

This section discusses unsafe functions for formatted string output. It
actually contains only one function, `sprintf`. You should never use the
`sprintf` function; use `asprintf` instead.

  -------------------------------- ---- --
  [16.2.5.1 `sprintf`](#sprintf)        
  -------------------------------- ---- --

------------------------------------------------------------------------

[]{#sprintf}

  --------------------------------------------------------------------------------------------- --------------------------------------------------------- --- ------------------------------------------------------------------------------- ---------------------------------------------------------------------- -------------------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Deprecated-formatted-string-output-functions "Previous section in reading order")\]   \[[\>](#String-input "Next section in reading order")\]       \[[\<\<](#Input-and-output "Beginning of this chapter or previous chapter")\]   \[[Up](#Deprecated-formatted-string-output-functions "Up section")\]   \[[\>\>](#Putting-a-program-together "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  --------------------------------------------------------------------------------------------- --------------------------------------------------------- --- ------------------------------------------------------------------------------- ---------------------------------------------------------------------- -------------------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#sprintf-1}

#### 16.2.5.1 `sprintf` {#sprintf .subsubsection}

[]{#index-sprintf-function-1}

The `sprintf` ("string print formatted") command is similar to
`asprintf`, except that it is much less safe. Its first parameter is a
string to which to send output. It terminates the string with a null
character. It returns the number of characters stored in the string, not
including the terminating null.

This function will behave unpredictably if the string to which it is
printing overlaps any of its arguments. It is dangerous because the
characters output to the string may overflow it. This problem cannot be
solved with the field width modifier to the conversion specifier,
because only the minimum field width can be specified with it. To avoid
this problem, it is better to use `asprintf`, but there is a lot of C
code that still uses `sprintf`, so it is important to know about it.
(See section [`asprintf`](#asprintf).)

The following code example prints the string 'Being 4 is cool, but being
free is best of all.' to the string variable `my_string` then prints the
string on the screen. Notice that `my_string` has been allocated 100
bytes of space, enough to contain the characters output to it. (See
section [`puts`](#puts), for more information on the `puts` function.)

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | #include <stdio.h>                |
|                                   |                                   |
|                                   | int main()                        |
|                                   | {                                 |
|                                   |   char my_string[100];            |
|                                   |                                   |
|                                   |   sprintf (my_string, "Being %d i |
|                                   | s cool, but being free is best of |
|                                   |  all.", 4);                       |
|                                   |   puts (my_string);               |
|                                   |                                   |
|                                   |   return 0;                       |
|                                   | }                                 |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

------------------------------------------------------------------------

[]{#String-input}

  -------------------------------------------------------- ---------------------------------------------------- --- ------------------------------------------------------------------------------- ------------------------------------------------- -------------------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#sprintf "Previous section in reading order")\]   \[[\>](#getline "Next section in reading order")\]       \[[\<\<](#Input-and-output "Beginning of this chapter or previous chapter")\]   \[[Up](#String-output-and-input "Up section")\]   \[[\>\>](#Putting-a-program-together "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  -------------------------------------------------------- ---------------------------------------------------- --- ------------------------------------------------------------------------------- ------------------------------------------------- -------------------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#String-input-1}

### 16.2.6 String input {#string-input .subsection}

[]{#index-String-input-1} []{#index-Input_002c-string-1}

The functions in this section are for input of strings from streams.
They are generally very safe to use.

  ---------------------------------- ---- --
  [16.2.6.1 `getline`](#getline)          
  [16.2.6.2 `getdelim`](#getdelim)        
  ---------------------------------- ---- --

------------------------------------------------------------------------

[]{#getline}

  ------------------------------------------------------------- ----------------------------------------------------- --- ------------------------------------------------------------------------------- -------------------------------------- -------------------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#String-input "Previous section in reading order")\]   \[[\>](#getdelim "Next section in reading order")\]       \[[\<\<](#Input-and-output "Beginning of this chapter or previous chapter")\]   \[[Up](#String-input "Up section")\]   \[[\>\>](#Putting-a-program-together "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ------------------------------------------------------------- ----------------------------------------------------- --- ------------------------------------------------------------------------------- -------------------------------------- -------------------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#getline-1}

#### 16.2.6.1 `getline` {#getline .subsubsection}

[]{#index-getline-function-1}

The `getline` function is the preferred method for reading lines of text
from a stream, including standard input. The other standard functions,
including `gets`, `fgets`, and `scanf`, are too unreliable. (Doubtless,
in some programs you will see code that uses these unreliable functions,
and at times you will come across compilers that cannot handle the safer
`getline` function. As a professional, you should avoid unreliable
functions and any compiler that requires you to be unsafe.)

The `getline` function reads an entire line from a stream, up to and
including the next newline character. It takes three parameters. The
first is a pointer to a block allocated with `malloc` or `calloc`.
(These two functions allocate computer memory for the program when it is
run. See section [Memory allocation](#Memory-allocation), for more
information.) This parameter is of type `char **`; it will contain the
line read by `getline` when it returns. The second parameter is a
pointer to a variable of type `size_t`; this parameter specifies the
size in bytes of the block of memory pointed to by the first parameter.
The third parameter is simply the stream from which to read the line.

The pointer to the block of memory allocated for `getline` is merely a
suggestion. The `getline` function will automatically enlarge the block
of memory as needed, via the `realloc` function, so there is never a
shortage of space --- one reason why `getline` is so safe. Not only
that, but `getline` will also tell you the new size of the block by the
value returned in the second parameter.

If an error occurs, such as end of file being reached without reading
any bytes, `getline` returns -1. Otherwise, the first parameter will
contain a pointer to the string containing the line that was read, and
`getline` returns the number of characters read (up to and including the
newline, but not the final null character). The return value is of type
`ssize_t`.

Although the second parameter is of type pointer to string (`char **`),
you cannot treat it as an ordinary string, since it may contain null
characters before the final null character marking the end of the line.
The return value enables you to distinguish null characters that
`getline` read as part of the line, by specifying the size of the line.
Any characters in the block up to the number of bytes specified by the
return value are part of the line; any characters after that number of
bytes are not.

Here is a short code example that demonstrates how to use `getline` to
read a line of text from the keyboard safely. Try typing more than 100
characters. Notice that `getline` can safely handle your line of input,
no matter how long it is. Also note that the `puts` command used to
display the line of text read will be inadequate if the line contains
any null characters, since it will stop displaying text at the first
null, but that since it is difficult to enter null characters from the
keyboard, this is generally not a consideration.

[]{#index-getline-function-2} []{#index-getline_002c-example-of}

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | #include <stdio.h>                |
|                                   |                                   |
|                                   | int main()                        |
|                                   | {                                 |
|                                   |   int bytes_read;                 |
|                                   |   int nbytes = 100;               |
|                                   |   char *my_string;                |
|                                   |                                   |
|                                   |   puts ("Please enter a line of t |
|                                   | ext.");                           |
|                                   | ```                               |
|                                   |                                   |
|                                   | ``` {.smallexample}               |
|                                   | ```                               |
|                                   |                                   |
|                                   | ``` {.smallexample}               |
|                                   |   /* These 2 lines are the heart  |
|                                   | of the program. */                |
|                                   |   my_string = (char *) malloc (nb |
|                                   | ytes + 1);                        |
|                                   |   bytes_read = getline (&my_strin |
|                                   | g, &nbytes, stdin);               |
|                                   | ```                               |
|                                   |                                   |
|                                   | ``` {.smallexample}               |
|                                   | ```                               |
|                                   |                                   |
|                                   | ``` {.smallexample}               |
|                                   |   if (bytes_read == -1)           |
|                                   |     {                             |
|                                   |       puts ("ERROR!");            |
|                                   |     }                             |
|                                   |   else                            |
|                                   |     {                             |
|                                   |       puts ("You typed:");        |
|                                   |       puts (my_string);           |
|                                   |     }                             |
|                                   |                                   |
|                                   |   return 0;                       |
|                                   | }                                 |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

------------------------------------------------------------------------

[]{#getdelim}

  -------------------------------------------------------- ------------------------------------------------------------------------------ --- ------------------------------------------------------------------------------- -------------------------------------- -------------------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#getline "Previous section in reading order")\]   \[[\>](#Deprecated-string-input-functions "Next section in reading order")\]       \[[\<\<](#Input-and-output "Beginning of this chapter or previous chapter")\]   \[[Up](#String-input "Up section")\]   \[[\>\>](#Putting-a-program-together "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  -------------------------------------------------------- ------------------------------------------------------------------------------ --- ------------------------------------------------------------------------------- -------------------------------------- -------------------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#getdelim-1}

#### 16.2.6.2 `getdelim` {#getdelim .subsubsection}

[]{#index-getdelim-function-1}

The `getdelim` function is a more general form of the `getline`
function; whereas `getline` stops reading input at the first newline
character it encounters, the `getdelim` function enables you to specify
other delimiter characters than newline. In fact, `getline` simply calls
`getdelim` and specifies that the delimiter character is a newline.

The syntax for `getdelim` is nearly the same as that of `getline`,
except that the third parameter specifies the delimiter character, and
the fourth parameter is the stream from which to read. You can exactly
duplicate the `getline` example in the last section with `getdelim`, by
replacing the line

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | bytes_read = getline (&my_string, |
|                                   |  &nbytes, stdin);                 |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

with the line

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | bytes_read = getdelim (&my_string |
|                                   | , &nbytes, '\n', stdin);          |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

------------------------------------------------------------------------

[]{#Deprecated-string-input-functions}

  --------------------------------------------------------- ------------------------------------------------- --- ------------------------------------------------------------------------------- ------------------------------------------------- -------------------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#getdelim "Previous section in reading order")\]   \[[\>](#gets "Next section in reading order")\]       \[[\<\<](#Input-and-output "Beginning of this chapter or previous chapter")\]   \[[Up](#String-output-and-input "Up section")\]   \[[\>\>](#Putting-a-program-together "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  --------------------------------------------------------- ------------------------------------------------- --- ------------------------------------------------------------------------------- ------------------------------------------------- -------------------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Deprecated-string-input-functions-1}

### 16.2.7 Deprecated string input functions {#deprecated-string-input-functions .subsection}

[]{#index-String-input-2} []{#index-Input_002c-string-2}
[]{#index-Deprecated-string-input-functions}
[]{#index-String-input-functions_002c-deprecated}

The functions in this section are for input of strings from streams, but
they are generally dangerous and should only be called when there is no
alternative. They are included here because you may come across code
imported from a non-GNU system that uses these unsafe functions.

  ---------------------------- ---- --
  [16.2.7.1 `gets`](#gets)          
  [16.2.7.2 `fgets`](#fgets)        
  ---------------------------- ---- --

------------------------------------------------------------------------

[]{#gets}

  ---------------------------------------------------------------------------------- -------------------------------------------------- --- ------------------------------------------------------------------------------- ----------------------------------------------------------- -------------------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Deprecated-string-input-functions "Previous section in reading order")\]   \[[\>](#fgets "Next section in reading order")\]       \[[\<\<](#Input-and-output "Beginning of this chapter or previous chapter")\]   \[[Up](#Deprecated-string-input-functions "Up section")\]   \[[\>\>](#Putting-a-program-together "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ---------------------------------------------------------------------------------- -------------------------------------------------- --- ------------------------------------------------------------------------------- ----------------------------------------------------------- -------------------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#gets-1}

#### 16.2.7.1 `gets` {#gets .subsubsection}

[]{#index-gets-function-1}

If you want to read a string from standard input, you can use the `gets`
function, the name of which stands for "get string". However, this
function is *deprecated* --- that means it is obsolete and it is
strongly suggested you do not use it --- because it is dangerous. It is
dangerous because it provides no protection against overflowing the
string into which it is saving data. Programs that use `gets` can
actually be a security problem on your computer. Since it is sometimes
used in older code (which is why the GNU C Library still provides it),
we will examine it briefly; nevertheless, you should *always* use the
function `getline` instead. (See section [`getline`](#getline).)

The `gets` function takes one parameter, the string in which to store
the data read. It reads characters from standard input up to the next
newline character (that is, when the user presses \<RETURN\>), discards
the newline character, and copies the rest into the string passed to it.
If there was no error, it returns the same string (as a return value,
which may be discarded); otherwise, if there was an error, it returns a
null pointer.

Here is a short code example that uses `gets`:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | #include <stdio.h>                |
|                                   |                                   |
|                                   | int main()                        |
|                                   | {                                 |
|                                   |   char my_string[500];            |
|                                   |   printf("Type something.\n");    |
|                                   |   gets(my_string);                |
|                                   |   printf ("You typed: %s\n", my_s |
|                                   | tring);                           |
|                                   |                                   |
|                                   |   return 0;                       |
|                                   | }                                 |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

If you attempt to compile the example above, it will compile and will
run properly, but GCC will warn you against the use of a deprecated
function, as follows:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | /tmp/ccPW3krf.o: In function `mai |
|                                   | n':                               |
|                                   | /tmp/ccPW3krf.o(.text+0x24): the  |
|                                   | `gets' function                   |
|                                   |      is dangerous and should not  |
|                                   | be used.                          |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

**Remember!** Never use this function in your own code. Always use
`getline` instead.

------------------------------------------------------------------------

[]{#fgets}

  ----------------------------------------------------- ------------------------------------------------------------------- --- ------------------------------------------------------------------------------- ----------------------------------------------------------- -------------------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#gets "Previous section in reading order")\]   \[[\>](#Formatted-string-input "Next section in reading order")\]       \[[\<\<](#Input-and-output "Beginning of this chapter or previous chapter")\]   \[[Up](#Deprecated-string-input-functions "Up section")\]   \[[\>\>](#Putting-a-program-together "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ----------------------------------------------------- ------------------------------------------------------------------- --- ------------------------------------------------------------------------------- ----------------------------------------------------------- -------------------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#fgets-1}

#### 16.2.7.2 `fgets` {#fgets .subsubsection}

[]{#index-fgets-function-1}

The `fgets` ("file get string") function is similar to the `gets`
function. This function is *deprecated* --- that means it is obsolete
and it is strongly suggested you do not use it --- because it is
dangerous. It is dangerous because if the input data contains a null
character, you can't tell. Don't use `fgets` unless you know the data
cannot contain a null. Don't use it to read files edited by the user
because, if the user inserts a null character, you should either handle
it properly or print a clear error message. Always use `getline` or
`getdelim` instead of `fgets` if you can.

Rather than reading a string from standard input, as `gets` does,
`fgets` reads it from a specified stream, up to and including a newline
character. It stores the string in the string variable passed to it,
adding a null character to terminate the string. This function takes
three parameters: the first is the string into which to read data, the
second is the maximum number of characters to read. (You must supply at
least this many characters of space in the string, or your program will
probably crash, but at least the `fgets` function protects against
overflowing the string and creating a security hazard, unlike `gets`.)
The third parameter is the stream from which to read. The number of
characters that `fgets` reads is actually one less than than number
specified; it stores the null character in the extra character space.

If there is no error, `fgets` returns the string read as a return value,
which may be discarded. Otherwise, for example if the stream is already
at end of file, it returns a null pointer.

Unfortunately, like the `gets` function, `fgets` is deprecated, in this
case because when `fgets` cannot tell whether a null character is
included in the string it reads. If a null character is read by `fgets`,
it will be stored in the string along with the rest of the characters
read. Since a null character terminates a string in C, C will then
consider your string to end prematurely, right before the first null
character. Only use `fgets` if you are certain the data read cannot
contain a null; otherwise, use `getline`.

Here is a code example that uses `fgets`. It will create a text file
containing the string 'Hidee ho!' plus a newline, read it back with
`fgets`, and print it on standard output. Notice that although 100
characters are allocated for the string `my_string`, and requested to be
read in the `fgets` call, there are not that many characters in the
file. The `fgets` function only reads the string up to the newline
character; the important thing is to allocate enough space in the string
variable to contain the string to be read.

[]{#index-fgets-function-2} []{#index-findex_002c-example-of}

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | #include <stdio.h>                |
|                                   |                                   |
|                                   | int main()                        |
|                                   | {                                 |
|                                   |   int input_character;            |
|                                   |   FILE *my_stream;                |
|                                   |   char my_filename[] = "snazzyjaz |
|                                   | z.txt";                           |
|                                   |   char my_string[100];            |
|                                   | ```                               |
|                                   |                                   |
|                                   | ``` {.smallexample}               |
|                                   | ```                               |
|                                   |                                   |
|                                   | ``` {.smallexample}               |
|                                   |   my_stream = fopen (my_filename, |
|                                   |  "w");                            |
|                                   |   fprintf (my_stream, "Hidee ho!\ |
|                                   | n");                              |
|                                   |                                   |
|                                   |   /* Close stream; skip error-che |
|                                   | cking for brevity of example */   |
|                                   |   fclose (my_stream);             |
|                                   | ```                               |
|                                   |                                   |
|                                   | ``` {.smallexample}               |
|                                   | ```                               |
|                                   |                                   |
|                                   | ``` {.smallexample}               |
|                                   |   my_stream = fopen (my_filename, |
|                                   |  "r");                            |
|                                   |   fgets (my_string, 100, my_strea |
|                                   | m);                               |
|                                   |                                   |
|                                   |   /* Close stream; skip error-che |
|                                   | cking for brevity of example */   |
|                                   |   fclose (my_stream);             |
|                                   |                                   |
|                                   |   printf ("%s", my_string);       |
|                                   |                                   |
|                                   |   return 0;                       |
|                                   | }                                 |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

------------------------------------------------------------------------

[]{#Formatted-string-input}

  ------------------------------------------------------ --------------------------------------------------- --- ------------------------------------------------------------------------------- ------------------------------------------------- -------------------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#fgets "Previous section in reading order")\]   \[[\>](#sscanf "Next section in reading order")\]       \[[\<\<](#Input-and-output "Beginning of this chapter or previous chapter")\]   \[[Up](#String-output-and-input "Up section")\]   \[[\>\>](#Putting-a-program-together "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ------------------------------------------------------ --------------------------------------------------- --- ------------------------------------------------------------------------------- ------------------------------------------------- -------------------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Formatted-string-input-1}

### 16.2.8 Formatted string input {#formatted-string-input .subsection}

[]{#index-Formatted-string-input} []{#index-String-input_002c-formatted}
[]{#index-Input_002c-string-formatted}

The formatted string input functions are the opposite of the formatted
string output functions. Unlike `printf` and similar functions, which
generate formatted output, `scanf` and its friends parse formatted
input. Like the opposite functions, each accepts, as a parameter, a
template string that contains conversion specifiers. In the case of
`scanf` and related functions, however, the conversion specifiers are
meant to match patterns in an input string, such as integers, floating
point numbers, and character sequences, and store the values read in
variables.

  ------------------------------------------------------------------------------------------ ---- --
  [16.2.8.1 `sscanf`](#sscanf)                                                                    
  [16.2.8.2 Formatted input conversion specifiers](#Formatted-input-conversion-specifiers)        
  ------------------------------------------------------------------------------------------ ---- --

------------------------------------------------------------------------

[]{#sscanf}

  ----------------------------------------------------------------------- ---------------------------------------------------------------------------------- --- ------------------------------------------------------------------------------- ------------------------------------------------ -------------------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Formatted-string-input "Previous section in reading order")\]   \[[\>](#Formatted-input-conversion-specifiers "Next section in reading order")\]       \[[\<\<](#Input-and-output "Beginning of this chapter or previous chapter")\]   \[[Up](#Formatted-string-input "Up section")\]   \[[\>\>](#Putting-a-program-together "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ----------------------------------------------------------------------- ---------------------------------------------------------------------------------- --- ------------------------------------------------------------------------------- ------------------------------------------------ -------------------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#sscanf-1}

#### 16.2.8.1 `sscanf` {#sscanf .subsubsection}

[]{#index-sscanf-function}

The `sscanf` function accepts a string from which to read input, then,
in a manner similar to `printf` and related functions, it accepts a
template string and a series of related arguments. It tries to match the
template string to the string from which it is reading input, using
conversion specifier like those of `printf`.

The `sscanf` function is just like the deprecated parent `scanf`
function, except that the first argument of `sscanf` specifies a string
from which to read, whereas `scanf` can only read from standard input.
Reaching the end of the string is treated as an end-of-file condition.

Here is an example of `sscanf` in action:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | sscanf (input_string, "%as %as %a |
|                                   | s", &str_arg1, &str_arg2, &str_ar |
|                                   | g3);                              |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

If the string `sscanf` is scanning overlaps with any of the arguments,
unexpected results will follow, as in the following example. Don't do
this!

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | sscanf (input_string, "%as", &inp |
|                                   | ut_string);                       |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

Here is a good code example that parses input from the user with
`sscanf`. It prompts the user to enter three integers separated by
whitespace, then reads an arbitrarily long line of text from the user
with `getline`. It then checks whether exactly three arguments were
assigned by `sscanf`. If the line read does not contain the data
requested (for example, if it contains a floating-point number or any
alphabetic characters), the program prints an error message and prompts
the user for three integers again. When the program finally receives
exactly the data it was looking for from the user, it prints out a
message acknowledging the input, and then prints the three integers.

It is this flexibility of input and great ease of recovery from errors
that makes the `getline`/`sscanf` combination so vastly superior to
`scanf` alone. Simply put, you should never use `scanf` where you can
use this combination instead.

[]{#index-sscanf-function-1} []{#index-sscanf-example}

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | #include <stdio.h>                |
|                                   |                                   |
|                                   | int main()                        |
|                                   | {                                 |
|                                   |   int nbytes = 100;               |
|                                   |   char *my_string;                |
|                                   |   int int1, int2, int3;           |
|                                   |   int args_assigned;              |
|                                   | ```                               |
|                                   |                                   |
|                                   | ``` {.smallexample}               |
|                                   | ```                               |
|                                   |                                   |
|                                   | ``` {.smallexample}               |
|                                   |   args_assigned = 0;              |
|                                   |                                   |
|                                   |   while (args_assigned != 3)      |
|                                   |     {                             |
|                                   |       puts ("Please enter three i |
|                                   | ntegers separated by whitespace." |
|                                   | );                                |
|                                   |       my_string = (char *) malloc |
|                                   |  (nbytes + 1);                    |
|                                   |       getline (&my_string, &nbyte |
|                                   | s, stdin);                        |
|                                   |       args_assigned = sscanf (my_ |
|                                   | string, "%d %d %d", &int1, &int2, |
|                                   |  &int3);                          |
|                                   |       if (args_assigned != 3)     |
|                                   |     puts ("\nInput invalid!");    |
|                                   |     }                             |
|                                   | ```                               |
|                                   |                                   |
|                                   | ``` {.smallexample}               |
|                                   | ```                               |
|                                   |                                   |
|                                   | ``` {.smallexample}               |
|                                   |   printf ("\nThanks!\n%d\n%d\n%d\ |
|                                   | n", int1, int2, int3);            |
|                                   |                                   |
|                                   |   return 0;                       |
|                                   | }                                 |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

Template strings for `sscanf` and related functions are somewhat more
free-form than those for `printf`. For example, most conversion
specifiers ignore any preceding whitespace. Further, you cannot specify
a precision for `sscanf` conversion specifiers, as you can for those of
`printf`.

[]{#index-sscanf_002c-common-errors-with}

Another important difference between `sscanf` and `printf` is that the
arguments to `sscanf` must be pointers; this allows `sscanf` to return
values in the variables they point to. If you forget to pass pointers to
`sscanf`, you may receive some strange errors, and it is easy to forget
to do so; therefore, this is one of the first things you should check if
code containing a call to `sscanf` begins to go awry.

[]{#index-Template-string_002c-}
[]{#index-Formatted-input-conversion-specifiers}
[]{#index-Input-conversion-specifiers_002c-formatted}
[]{#index-Conversion-specifiers_002c-formatted-input}

A `sscanf` template string can contain any number of any number of
whitespace characters, any number of ordinary, non-whitespace
characters, and any number of conversion specifiers starting with '%'. A
whitespace character in the template string matches zero or more
whitespace characters in the input string. Ordinary, non-whitespace
characters must correspond exactly in the template string and the input
stream; otherwise, a matching error occurs. Thus, the template string
'\" foo \"' matches '\"foo\"' and '\" foo \"', but not '\" food \"'.

If you create an input conversion specifier with invalid syntax, or if
you don't supply enough arguments for all the conversion specifiers in
the template string, your code may do unexpected things, so be careful.
Extra arguments, however, are simply ignored.

Conversion specifiers start with a percent sign ('%') and terminate with
a character from the following table:

------------------------------------------------------------------------

[]{#Formatted-input-conversion-specifiers}

  ------------------------------------------------------- ---------------------------------------------------------------------------------------- --- ------------------------------------------------------------------------------- ------------------------------------------------ -------------------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#sscanf "Previous section in reading order")\]   \[[\>](#Deprecated-formatted-string-input-functions "Next section in reading order")\]       \[[\<\<](#Input-and-output "Beginning of this chapter or previous chapter")\]   \[[Up](#Formatted-string-input "Up section")\]   \[[\>\>](#Putting-a-program-together "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ------------------------------------------------------- ---------------------------------------------------------------------------------------- --- ------------------------------------------------------------------------------- ------------------------------------------------ -------------------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Formatted-input-conversion-specifiers-1}

#### 16.2.8.2 Formatted input conversion specifiers {#formatted-input-conversion-specifiers .subsubsection}

[]{#index-Formatted-input-conversion-specifiers-1}
[]{#index-Input-conversion-specifiers_002c-formatted-1}
[]{#index-Conversion-specifiers_002c-formatted-input-1}

[]{#index-c-input-conversion-specifier}

'c'

Matches a fixed number of characters. If you specify a maximum field
width (see below), that is how many characters will be matched;
otherwise, '%c' matches one character. This conversion does not append a
null character to the end of the text it reads, as does the '%s'
conversion. It also does not skip whitespace characters, but reads
precisely the number of characters it was told to, or generates a
matching error if it cannot.

[]{#index-d-input-conversion-specifier}

'd'

Matches an optionally signed decimal integer, containing the following
sequence:

1.  An optional plus or minus sign ('+' or '-').
2.  One or more decimal digits.

Note that '%d' and '%i' are not synonymous for `scanf`, as they are for
`printf`.

[]{#index-input-conversion-specifier}

'e'

Matches an optionally signed floating-point number, containing the
following sequence:

1.  An optional plus or minus sign ('+' or '-').
2.  A floating-point number in decimal or hexadecimal format.
    -   The decimal format is a sequence of one or more decimal digits,
        optionally containing a decimal point character (usually '.'),
        followed by an optional exponent part, consisting of a character
        'e' or 'E', an optional plus or minus sign, and a sequence of
        decimal digits.
    -   The hexadecimal format is a '0x' or '0X', followed by a sequence
        of one or more hexadecimal digits, optionally containing a
        decimal point character, followed by an optional binary-exponent
        part, consisting of a character 'p' or 'P', an optional plus or
        minus sign, and a sequence of digits.

[]{#index-E-input-conversion-specifier}

'E'

Same as 'e'.

[]{#index-f-input-conversion-specifier}

'f'

Same as 'e'.

[]{#index-g-input-conversion-specifier}

'g'

Same as 'e'.

[]{#index-G-input-conversion-specifier}

'G'

Same as 'e'.

[]{#index-i-input-conversion-specifier}

'i'

Matches an optionally signed integer, containing the following sequence:

1.  An optional plus or minus sign ('+' or '-').
2.  A string of characters representing an unsigned integer.
    -   If the string begins with '0x' or '0X', the number is assumed to
        be in hexadecimal format, and the rest of the string must
        contain hexadecimal digits.
    -   Otherwise, if the string begins with '0', the number is assumed
        to be in octal format (base eight), and the rest of the string
        must contain octal digits.
    -   Otherwise, the number is assumed to be in decimal format, and
        the rest of the string must contain decimal digits.

Note that '%d' and '%i' are not synonymous for `scanf`, as they are for
`printf`. You can print integers in this syntax with `printf` by using
the '\#' flag character with the '%x' or '%d' output conversions. (See
section [`printf`](#printf).)

[]{#index-s-input-conversion-specifier}

's'

Matches a string of non-whitespace characters. It skips initial
whitespace, but stops when it meets more whitespace after it has read
something. It stores a null character at the end of the text that it
reads, to mark the end of the string. (See section [String overflows
with scanf](#String-overflows-with-scanf), for a warning about using
this conversion.)

[]{#index-x-input-conversion-specifier}

'x'

Matches an unsigned integer in hexadecimal format. The string matched
must begin with '0x' or '0X', and the rest of the string must contain
hexadecimal digits.

[]{#index-X-input-conversion-specifier}

'X'

Same as 'x'.

[]{#index-_005b-input-conversion-specifier}

'\['

Matches a string containing an arbitrary set of characters. For example,
'%12\[0123456789\]' means to read a string with a maximum field width of
12, containing characters from the set '0123456789' --- in other words,
twelve decimal digits. An embedded '-' character means a range of
characters; thus '%12\[0-9\]' means the same thing as the last example.
Preceding the characters in the square brackets with a caret ('\^')
means to read a string *not* containing the characters listed. Thus,
'%12\[\^0-9\]' means to read a twelve-character string not containing
any decimal digit. (See section [String overflows with
scanf](#String-overflows-with-scanf), for a warning about using this
conversion.)

[]{#index-_0025-input-conversion-specifier}

'%'

Matches a percent sign. Does not correspond to an argument, and does not
permit flags, field width, or type modifier to be specified (see below).

In between the percent sign ('%') and the input conversion character,
you can place some combination of the following modifiers, in sequence.
(Note that the percent sign conversion ('%%') doesn't use arguments or
modifiers.)

-   []{#index-_002a-input-conversion-specifier-modifier}
-   An optional '\*' flag. This flag specifies that a match should be
    made between the conversion specifier and an item in the input
    stream, but that the value should *not* then be assigned to an
    argument. []{#index-a-input-conversion-specifier-modifier}
-   An optional 'a' flag, valid with string conversions only. This is a
    GNU extension to `scanf` that requests allocation of a buffer long
    enough to safely store the string that was read. (See section
    [String overflows with scanf](#String-overflows-with-scanf), for
    information on how to use this flag.)
    []{#index-_0027-input-conversion-specifier-modifier}
-   An optional '\'' flag. This flag specifies that the number read will
    be grouped according to the rules currently specified on your
    system. For example, in the United States, this usually means that
    '1,000' will be read as one thousand.
-   An optional decimal integer that specifies the maximum field width.
    The `scanf` function will stop reading characters from the input
    stream either when this maximum is reached, or when a non-matching
    character is read, whichever comes first. Discarded initial
    whitespace does not count toward this width; neither does the null
    character stored by string input conversions to mark the end of the
    string.
-   An optional type modifier character from the following table. (The
    default type of the corresponding argument is `int *` for the '%d'
    and '%i' conversions, `unsigned int *` for '%x' and '%X', and
    `float *` for '%e' and its synonyms. You can use these type
    modifiers to specify otherwise.)

    []{#index-h-input-conversion-specifier-modifier}

    'h'

    Specifies that the argument to which the value read should be
    assigned is of type `short int *` or `unsigned short int *`. Valid
    for the '%d' and '%i' conversions.

    []{#index-l-input-conversion-specifier-modifier}

    'l'

    For the '%d' and '%i' conversions, specifies that the argument to
    which the value read should be assigned is of type `long int *` or
    `unsigned long int *`. For the '%e' conversion and its synonyms,
    specifies that the argument is of type `double *`.

    []{#index-L-input-conversion-specifier-modifier}

    'L'

    For the '%d' and '%i' conversions, specifies that the argument to
    which the value read should be assigned is of type `long long int *`
    or `unsigned long long int *`. On systems that do not have
    extra-long integers, this has the same effect as 'l'.

    For the '%e' conversion and its synonyms, specifies that the
    argument is of type `long double *`.

    []{#index-ll-input-conversion-specifier-modifier}

    'll'

    Same as 'L', for the '%d' and '%i' conversions.

    []{#index-q-input-conversion-specifier-modifier}

    'q'

    Same as 'L', for the '%d' and '%i' conversions.

    []{#index-z-input-conversion-specifier-modifier}

    'z'

    Specifies that the argument to which the value read should be
    assigned is of type `size_t`. (The `size_t` type is used to specify
    the sizes of blocks of memory, and many functions in this chapter
    use it.) Valid for the '%d' and '%i' conversions.

------------------------------------------------------------------------

[]{#Deprecated-formatted-string-input-functions}

  -------------------------------------------------------------------------------------- -------------------------------------------------- --- ------------------------------------------------------------------------------- ------------------------------------------------- -------------------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Formatted-input-conversion-specifiers "Previous section in reading order")\]   \[[\>](#scanf "Next section in reading order")\]       \[[\<\<](#Input-and-output "Beginning of this chapter or previous chapter")\]   \[[Up](#String-output-and-input "Up section")\]   \[[\>\>](#Putting-a-program-together "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  -------------------------------------------------------------------------------------- -------------------------------------------------- --- ------------------------------------------------------------------------------- ------------------------------------------------- -------------------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Deprecated-formatted-string-input-functions-1}

### 16.2.9 Deprecated formatted string input functions {#deprecated-formatted-string-input-functions .subsection}

[]{#index-Deprecated-formatted-string-input-functions}
[]{#index-Formatted-string-input-functions_002c-deprecated}
[]{#index-String-input-functions_002c-deprecated-formatted}
[]{#index-Input-functions_002c-string_002c-deprecated-formatted}

These formatted string input functions are generally dangerous and
should only be used when there is no alternative. However, because you
may encounter them when importing older code or code from non-GNU
systems, and because the `scanf` function is in a sense the parent of
the safe `sscanf` function, it is important that you know about them.

  ---------------------------------------------------------------------- ---- --
  [16.2.9.1 `scanf`](#scanf)                                                  
  [16.2.9.2 String overflows with scanf](#String-overflows-with-scanf)        
  ---------------------------------------------------------------------- ---- --

------------------------------------------------------------------------

[]{#scanf}

  -------------------------------------------------------------------------------------------- ------------------------------------------------------------------------ --- ------------------------------------------------------------------------------- --------------------------------------------------------------------- -------------------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Deprecated-formatted-string-input-functions "Previous section in reading order")\]   \[[\>](#String-overflows-with-scanf "Next section in reading order")\]       \[[\<\<](#Input-and-output "Beginning of this chapter or previous chapter")\]   \[[Up](#Deprecated-formatted-string-input-functions "Up section")\]   \[[\>\>](#Putting-a-program-together "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  -------------------------------------------------------------------------------------------- ------------------------------------------------------------------------ --- ------------------------------------------------------------------------------- --------------------------------------------------------------------- -------------------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#scanf-1}

#### 16.2.9.1 `scanf` {#scanf .subsubsection}

[]{#index-scanf-function-1}

The first of the functions we will examine is `scanf` ("scan
formatted"). The `scanf` function is considered dangerous for a number
of reasons. First, if used improperly, it can cause your program to
crash by reading character strings that overflow the string variables
meant to contain them, just like `gets`. (See section [`gets`](#gets).)
Second, `scanf` can hang if it encounters unexpected non-numeric input
while reading a line from standard input. Finally, it is difficult to
recover from errors when the `scanf` template string does not match the
input exactly.

If you are going to read input from the keyboard, it is far better to
read it with `getline` and parse the resulting string with `sscanf`
("string scan formatted") than to use `scanf` directly. However, since
`sscanf` uses nearly the same syntax as `sscanf`, as does the related
`fscanf`, and since `scanf` is a standard C function, it is important to
learn about it.

If `scanf` cannot match the template string to the input string, it will
return immediately --- and it will leave the first non-matching
character as the next character to read from the stream. This is called
a *matching error*, and is the main reason `scanf` tends to hang when
reading input from the keyboard; a second call to `scanf` will almost
certainly choke, since the file position indicator of the stream is not
pointing where `scanf` will expect it to. Normally, `scanf` returns the
number of assignments made to the arguments it was passed, so check the
return value to see if `scanf` found all the items you expected.

  ---------------------------------------------------------------------- ---- --
  [16.2.9.2 String overflows with scanf](#String-overflows-with-scanf)        
  ---------------------------------------------------------------------- ---- --

------------------------------------------------------------------------

[]{#String-overflows-with-scanf}

  ------------------------------------------------------ --------------------------------------------------- --- ------------------------------------------------------------------------------- --------------------------------------------------------------------- -------------------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#scanf "Previous section in reading order")\]   \[[\>](#fscanf "Next section in reading order")\]       \[[\<\<](#Input-and-output "Beginning of this chapter or previous chapter")\]   \[[Up](#Deprecated-formatted-string-input-functions "Up section")\]   \[[\>\>](#Putting-a-program-together "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ------------------------------------------------------ --------------------------------------------------- --- ------------------------------------------------------------------------------- --------------------------------------------------------------------- -------------------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#String-overflows-with-scanf-1}

#### 16.2.9.2 String overflows with scanf {#string-overflows-with-scanf .subsubsection}

[]{#index-scanf-function-2} []{#index-scanf_002c-string-overflows-with}
[]{#index-String-overflows-with-scanf}

If you use the '%s' and '%\[' conversions improperly, then the number of
characters read is limited only by where the next whitespace character
appears. This almost cetainly means that invalid input could make your
program crash, because input too long would overflow whatever buffer you
have provided for it. No matter how long your buffer is, a user could
always supply input that is longer. A well-written program reports
invalid input with a comprehensible error message, not with a crash.

Fortunately, it is possible to avoid `scanf` buffer overflow by either
specifying a field width or using the 'a' flag.

When you specify a field width, you need to provide a buffer (using
`malloc` or a similar function) of type `char *`. (See section [Memory
allocation](#Memory-allocation), for more information on `malloc`.) You
need to make sure that the field width you specify does not exceed the
number of bytes allocated to your buffer.

On the other hand, you do not need to allocate a buffer if you specify
the 'a' flag character --- `scanf` will do it for you. Simply pass
`scanf` an pointer to an unallocated variable of type `char *`, and
`scanf` will allocate however large a buffer the string requires, and
return the result in your argument. This is a GNU-only extension to
`scanf` functionality.

Here is a code example that shows first how to safely read a string of
fixed maximum length by allocating a buffer and specifying a field
width, then how to safely read a string of any length by using the 'a'
flag.

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | #include <stdio.h>                |
|                                   |                                   |
|                                   | int main()                        |
|                                   | {                                 |
|                                   |   int bytes_read;                 |
|                                   |   int nbytes = 100;               |
|                                   |   char *string1, *string2;        |
|                                   |                                   |
|                                   |   string1 = (char *) malloc (25); |
|                                   |                                   |
|                                   |   puts ("Please enter a string of |
|                                   |  20 characters or fewer.");       |
|                                   |   scanf ("%20s", string1);        |
|                                   |   printf ("\nYou typed the follow |
|                                   | ing string:\n%s\n\n", string1);   |
|                                   |                                   |
|                                   |   puts ("Now enter a string of an |
|                                   | y length.");                      |
|                                   |   scanf ("%as", &string2);        |
|                                   |   printf ("\nYou typed the follow |
|                                   | ing string:\n%s\n", string2);     |
|                                   |                                   |
|                                   |   return 0;                       |
|                                   | }                                 |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

There are a couple of things to notice about this example program.
First, notice that the second argument passed to the first `scanf` call
is `string1`, not `&string1`. The `scanf` function requires pointers as
the arguments corresponding to its conversions, but a string variable is
already a pointer (of type `char *`), so you do not need the extra layer
of indirection here. However, you do need it for the second call to
`scanf`. We passed it an argument of `&string2` rather than `string2`,
because we are using the 'a' flag, which allocates a string variable big
enough to contain the characters it read, then returns a pointer to it.

The second thing to notice is what happens if you type a string of more
than 20 characters at the first prompt. The first `scanf` call will only
read the first 20 characters, then the second `scanf` call will gobble
up all the remaining characters without even waiting for a response to
the second prompt. This is because `scanf` does not read a line at a
time, the way the `getline` function does. Instead, it immediately
matches attempts to match its template string to whatever characters are
in the `stdin` stream. The second `scanf` call matches all remaining
characters from the overly-long string, stopping at the first whitespace
character. Thus, if you type '12345678901234567890xxxxx' in response to
the first prompt, the program will immediately print the following text
without pausing:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | You typed the following string:   |
|                                   | 12345678901234567890              |
|                                   |                                   |
|                                   | Now enter a string of any length. |
|                                   |                                   |
|                                   | You typed the following string:   |
|                                   | xxxxx                             |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

(See section [`sscanf`](#sscanf), for a better example of how to parse
input from the user.)

------------------------------------------------------------------------

[]{#fscanf}

  ---------------------------------------------------------------------------- ---------------------------------------------------------------------------------- --- ------------------------------------------------------------------------------- ------------------------------------------------- -------------------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#String-overflows-with-scanf "Previous section in reading order")\]   \[[\>](#Single_002dcharacter-input-and-output "Next section in reading order")\]       \[[\<\<](#Input-and-output "Beginning of this chapter or previous chapter")\]   \[[Up](#String-output-and-input "Up section")\]   \[[\>\>](#Putting-a-program-together "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ---------------------------------------------------------------------------- ---------------------------------------------------------------------------------- --- ------------------------------------------------------------------------------- ------------------------------------------------- -------------------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#fscanf-1}

### 16.2.10 `fscanf` {#fscanf .subsection}

[]{#index-fscanf-function}

The `fscanf` function is just like the `scanf` function, except that the
first argument of `fscanf` specifies a stream from which to read,
whereas `scanf` can only read from standard input.

Here is a code example that generates a text file containing five
numbers with `fprintf`, then reads them back in with `fscanf`. Note the
use of the '\#' flags in the '%\#d' conversions in the `fprintf` call;
this is a good way to generate data in a format that `scanf` and related
functions can easily read with the '%i' input conversion.

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | #include <stdio.h>                |
|                                   | #include <errno.h>                |
|                                   |                                   |
|                                   | int main()                        |
|                                   | {                                 |
|                                   |   float f1, f2;                   |
|                                   |   int i1, i2;                     |
|                                   |   FILE *my_stream;                |
|                                   |   char my_filename[] = "snazzyjaz |
|                                   | z.txt";                           |
|                                   | ```                               |
|                                   |                                   |
|                                   | ``` {.smallexample}               |
|                                   | ```                               |
|                                   |                                   |
|                                   | ``` {.smallexample}               |
|                                   |   my_stream = fopen (my_filename, |
|                                   |  "w");                            |
|                                   |   fprintf (my_stream, "%f %f %#d  |
|                                   | %#d", 23.5, -12e6, 100, 5);       |
|                                   |                                   |
|                                   |   /* Close stream; skip error-che |
|                                   | cking for brevity of example */   |
|                                   |   fclose (my_stream);             |
|                                   | ```                               |
|                                   |                                   |
|                                   | ``` {.smallexample}               |
|                                   | ```                               |
|                                   |                                   |
|                                   | ``` {.smallexample}               |
|                                   |   my_stream = fopen (my_filename, |
|                                   |  "r");                            |
|                                   |   fscanf (my_stream, "%f %f %i %i |
|                                   | ", &f1, &f2, &i1, &i2);           |
|                                   |                                   |
|                                   |   /* Close stream; skip error-che |
|                                   | cking for brevity of example */   |
|                                   |   fclose (my_stream);             |
|                                   | ```                               |
|                                   |                                   |
|                                   | ``` {.smallexample}               |
|                                   | ```                               |
|                                   |                                   |
|                                   | ``` {.smallexample}               |
|                                   |   printf ("Float 1 = %f\n", f1);  |
|                                   |   printf ("Float 2 = %f\n", f2);  |
|                                   |   printf ("Integer 1 = %d\n", i1) |
|                                   | ;                                 |
|                                   |   printf ("Integer 2 = %d\n", i2) |
|                                   | ;                                 |
|                                   |                                   |
|                                   |   return 0;                       |
|                                   | }                                 |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

This code example prints the following output on the screen:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | Float 1 = 23.500000               |
|                                   | Float 2 = -12000000.000000        |
|                                   | Integer 1 = 100                   |
|                                   | Integer 2 = 5                     |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

If you examine the text file '`snazzyjazz.txt`', you will see it
contains the following text:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | 23.500000 -12000000.000000 100 5  |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

------------------------------------------------------------------------

[]{#Single_002dcharacter-input-and-output}

  ------------------------------------------------------- ---------------------------------------------------- --- ------------------------------------------------------------------------------- ------------------------------------------ -------------------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#fscanf "Previous section in reading order")\]   \[[\>](#getchar "Next section in reading order")\]       \[[\<\<](#Input-and-output "Beginning of this chapter or previous chapter")\]   \[[Up](#Input-and-output "Up section")\]   \[[\>\>](#Putting-a-program-together "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ------------------------------------------------------- ---------------------------------------------------- --- ------------------------------------------------------------------------------- ------------------------------------------ -------------------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Single_002dcharacter-input-and-output-1}

16.3 Single-character input and output {#single-character-input-and-output .section}
--------------------------------------

[]{#index-Single_002dcharacter-input}
[]{#index-Single_002dcharacter-output}
[]{#index-Input_002c-single_002dcharacter}
[]{#index-Output_002c-single_002dcharacter}

This section covers the use of several functions for the input and
output of single characters from standard input and output or files.

  ---------------------------------------------- ---- --
  [16.3.1 `getchar`](#getchar)                        
  [16.3.2 `putchar`](#putchar)                        
  [16.3.3 `getc` and `fgetc`](#getc-and-fgetc)        
  [16.3.4 `putc` and `fputc`](#putc-and-fputc)        
  [16.3.5 `ungetc()`](#ungetc)                        
  ---------------------------------------------- ---- --

------------------------------------------------------------------------

[]{#getchar}

  -------------------------------------------------------------------------------------- ---------------------------------------------------- --- ------------------------------------------------------------------------------- --------------------------------------------------------------- -------------------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Single_002dcharacter-input-and-output "Previous section in reading order")\]   \[[\>](#putchar "Next section in reading order")\]       \[[\<\<](#Input-and-output "Beginning of this chapter or previous chapter")\]   \[[Up](#Single_002dcharacter-input-and-output "Up section")\]   \[[\>\>](#Putting-a-program-together "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  -------------------------------------------------------------------------------------- ---------------------------------------------------- --- ------------------------------------------------------------------------------- --------------------------------------------------------------- -------------------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#getchar-1}

### 16.3.1 `getchar` {#getchar .subsection}

[]{#index-getchar-function}

If you want to read a single character from standard input, you can use
the `getchar` function. This function takes no parameters, but reads the
next character from '`stdin`' as an `unsigned char`, and returns its
value, converted to an integer. Here is a short program that uses
`getchar`:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | #include <stdio.h>                |
|                                   |                                   |
|                                   | int main()                        |
|                                   | {                                 |
|                                   |   int input_character;            |
|                                   |                                   |
|                                   |   printf("Hit any key, then hit R |
|                                   | ETURN.\n");                       |
|                                   |   input_character = getchar();    |
|                                   |   printf ("The key you hit was '% |
|                                   | c'.\n", input_character);         |
|                                   |   printf ("Bye!\n");              |
|                                   |                                   |
|                                   |   return 0;                       |
|                                   | }                                 |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

Note that because `stdin` is line-buffered, `getchar` will not return a
value until you hit the \<RETURN\> key. However, `getchar` still only
reads one character from `stdin`, so if you type 'hellohellohello' at
the prompt, the program above will still only get once character. It
will print the following line, and then terminate:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | The key you hit was 'h'.          |
|                                   | Bye!                              |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

------------------------------------------------------------------------

[]{#putchar}

  -------------------------------------------------------- ----------------------------------------------------------- --- ------------------------------------------------------------------------------- --------------------------------------------------------------- -------------------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#getchar "Previous section in reading order")\]   \[[\>](#getc-and-fgetc "Next section in reading order")\]       \[[\<\<](#Input-and-output "Beginning of this chapter or previous chapter")\]   \[[Up](#Single_002dcharacter-input-and-output "Up section")\]   \[[\>\>](#Putting-a-program-together "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  -------------------------------------------------------- ----------------------------------------------------------- --- ------------------------------------------------------------------------------- --------------------------------------------------------------- -------------------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#putchar-1}

### 16.3.2 `putchar` {#putchar .subsection}

[]{#index-putchar-function}

If you want to print a single character on standard output, you can use
the `putchar` function. It takes a single integer parameter containing a
character (the argument can be a single-quoted text character, as in the
example below), and sends the character to `stdout`. If a write error
occurs, `putchar` returns `EOF`; otherwise, it returns the integer it
was passed. This can simply be disregarded, as in the example below.

Here is a short code example that makes use of `putchar`. It prints an
'X', a space, and then a line of ten exclamation marks ('!!!!!!!!!!') on
the screen, then outputs a newline so that the next shell prompt will
not occur on the same line. Notice the use of the `for` loop; by this
means, `putchar` can be used not just for one character, but multiple
times.

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | #include <stdio.h>                |
|                                   |                                   |
|                                   | int main()                        |
|                                   | {                                 |
|                                   |   int i;                          |
|                                   | ```                               |
|                                   |                                   |
|                                   | ``` {.smallexample}               |
|                                   | ```                               |
|                                   |                                   |
|                                   | ``` {.smallexample}               |
|                                   |   putchar ('X');                  |
|                                   |   putchar (' ');                  |
|                                   |   for (i=1; i<=10; i++)           |
|                                   |     {                             |
|                                   |       putchar ('!');              |
|                                   |     }                             |
|                                   |   putchar ('\n');                 |
|                                   | ```                               |
|                                   |                                   |
|                                   | ``` {.smallexample}               |
|                                   | ```                               |
|                                   |                                   |
|                                   | ``` {.smallexample}               |
|                                   |   return 0;                       |
|                                   | }                                 |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

------------------------------------------------------------------------

[]{#getc-and-fgetc}

  -------------------------------------------------------- ----------------------------------------------------------- --- ------------------------------------------------------------------------------- --------------------------------------------------------------- -------------------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#putchar "Previous section in reading order")\]   \[[\>](#putc-and-fputc "Next section in reading order")\]       \[[\<\<](#Input-and-output "Beginning of this chapter or previous chapter")\]   \[[Up](#Single_002dcharacter-input-and-output "Up section")\]   \[[\>\>](#Putting-a-program-together "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  -------------------------------------------------------- ----------------------------------------------------------- --- ------------------------------------------------------------------------------- --------------------------------------------------------------- -------------------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#getc-and-fgetc-1}

### 16.3.3 `getc` and `fgetc` {#getc-and-fgetc .subsection}

[]{#index-getc-function} []{#index-fgetc-function}

If you want to read a single character from a stream other than `stdin`,
you can use the `getc` function. This function is very similar to
`getchar`, but accepts an argument that specifies the stream from which
to read. It reads the next character from the specified stream as an
`unsigned char`, and returns its value, converted to an integer. If a
read error occurs or the end of the file is reached, `getc` returns
`EOF` instead.

Here is a code example that makes use of `getc`. This code example
creates a text file called '`snazzyjazz.txt`' with `fopen`, writes the
alphabet in upper-case letters plus a newline to it with `fprintf`,
reads the file position with `ftell`, and gets the character there with
`getc`. It then seeks position 25 with `fseek` and repeats the process,
attempts to read past the end of the file and reports end-of-file status
with `feof`, and generates an error by attempting to write to a
read-only stream. It then reports the error status with `ferror`,
returns to the start of the file with `rewind` and prints the first
character, and finally attempts to close the file and prints a status
message indicating whether it could do so.

See section [File position](#File-position), for information on `ftell`,
`fseek`, and `rewind`. See section [End-of-file and error
functions](#End_002dof_002dfile-and-error-functions), for more
information on `feof` and `ferror`.

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | #include <stdio.h>                |
|                                   |                                   |
|                                   | int main()                        |
|                                   | {                                 |
|                                   |   int input_char;                 |
|                                   |   FILE *my_stream;                |
|                                   |   char my_filename[] = "snazzyjaz |
|                                   | z.txt";                           |
|                                   |   long position;                  |
|                                   |   int eof_status, error_status, c |
|                                   | lose_error;                       |
|                                   | ```                               |
|                                   |                                   |
|                                   | ``` {.smallexample}               |
|                                   | ```                               |
|                                   |                                   |
|                                   | ``` {.smallexample}               |
|                                   |   my_stream = fopen (my_filename, |
|                                   |  "w");                            |
|                                   |   fprintf (my_stream, "ABCDEFGHIJ |
|                                   | KLMNOPQRSTUVWXYZ");               |
|                                   |                                   |
|                                   |   /* Close stream; skip error-che |
|                                   | cking for brevity of example */   |
|                                   |   fclose (my_stream);             |
|                                   | ```                               |
|                                   |                                   |
|                                   | ``` {.smallexample}               |
|                                   | ```                               |
|                                   |                                   |
|                                   | ``` {.smallexample}               |
|                                   |   printf ("Opening file...\n");   |
|                                   |   my_stream = fopen (my_filename, |
|                                   |  "r");                            |
|                                   |   position = ftell (my_stream);   |
|                                   |   input_char = getc (my_stream);  |
|                                   |   printf ("Character at position  |
|                                   | %d = '%c'.\n\n", position, input_ |
|                                   | char);                            |
|                                   | ```                               |
|                                   |                                   |
|                                   | ``` {.smallexample}               |
|                                   | ```                               |
|                                   |                                   |
|                                   | ``` {.smallexample}               |
|                                   |   printf ("Seeking position 25... |
|                                   | \n");                             |
|                                   |   fseek (my_stream, 25, SEEK_SET) |
|                                   | ;                                 |
|                                   |   position = ftell (my_stream);   |
|                                   |   input_char = getc (my_stream);  |
|                                   |   printf ("Character at position  |
|                                   | %d = '%c'.\n\n", position, input_ |
|                                   | char);                            |
|                                   | ```                               |
|                                   |                                   |
|                                   | ``` {.smallexample}               |
|                                   | ```                               |
|                                   |                                   |
|                                   | ``` {.smallexample}               |
|                                   |   printf ("Attempting to read aga |
|                                   | in...\n");                        |
|                                   |   input_char = getc (my_stream);  |
|                                   |   eof_status = feof (my_stream);  |
|                                   |   printf ("feof returns %d.\n\n", |
|                                   |  eof_status);                     |
|                                   | ```                               |
|                                   |                                   |
|                                   | ``` {.smallexample}               |
|                                   | ```                               |
|                                   |                                   |
|                                   | ``` {.smallexample}               |
|                                   |   error_status = ferror (my_strea |
|                                   | m);                               |
|                                   |   printf ("ferror returns %d.\n", |
|                                   |  error_status);                   |
|                                   |   printf ("Attempting to write to |
|                                   |  this read-only stream...\n");    |
|                                   |   putc ('!', my_stream);          |
|                                   |   error_status = ferror (my_strea |
|                                   | m);                               |
|                                   |   printf ("ferror returns %d.\n\n |
|                                   | ", error_status);                 |
|                                   | ```                               |
|                                   |                                   |
|                                   | ``` {.smallexample}               |
|                                   | ```                               |
|                                   |                                   |
|                                   | ``` {.smallexample}               |
|                                   |   printf ("Rewinding...\n");      |
|                                   |   rewind (my_stream);             |
|                                   |   position = ftell (my_stream);   |
|                                   |   input_char = getc (my_stream);  |
|                                   |   printf ("Character at position  |
|                                   | %d = '%c'.\n", position, input_ch |
|                                   | ar);                              |
|                                   | ```                               |
|                                   |                                   |
|                                   | ``` {.smallexample}               |
|                                   | ```                               |
|                                   |                                   |
|                                   | ``` {.smallexample}               |
|                                   |   close_error = fclose (my_stream |
|                                   | );                                |
|                                   |                                   |
|                                   |   /* Handle fclose errors */      |
|                                   |   if (close_error != 0)           |
|                                   |     {                             |
|                                   |       printf ("File could not be  |
|                                   | closed.\n");                      |
|                                   |     }                             |
|                                   |   else                            |
|                                   |     {                             |
|                                   |       printf ("File closed.\n");  |
|                                   |     }                             |
|                                   |                                   |
|                                   |   return 0;                       |
|                                   | }                                 |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

There is another function in the GNU C Library called `fgetc`. It is
identical to `getc` in most respects, except that `getc` is usually
implemented as a macro function and is highly optimised, so is
preferable in most situations. (In situations where you are reading from
standard input, `getc` is about as fast as `fgetc`, since humans type
slowly compared to how fast computers can read their input, but when you
are reading from a stream that is not interactively produced by a human,
`fgetc` is probably better.)

------------------------------------------------------------------------

[]{#putc-and-fputc}

  --------------------------------------------------------------- --------------------------------------------------- --- ------------------------------------------------------------------------------- --------------------------------------------------------------- -------------------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#getc-and-fgetc "Previous section in reading order")\]   \[[\>](#ungetc "Next section in reading order")\]       \[[\<\<](#Input-and-output "Beginning of this chapter or previous chapter")\]   \[[Up](#Single_002dcharacter-input-and-output "Up section")\]   \[[\>\>](#Putting-a-program-together "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  --------------------------------------------------------------- --------------------------------------------------- --- ------------------------------------------------------------------------------- --------------------------------------------------------------- -------------------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#putc-and-fputc-1}

### 16.3.4 `putc` and `fputc` {#putc-and-fputc .subsection}

[]{#index-putc-function} []{#index-fputc-function}

If you want to write a single character to a stream other than `stdout`,
you can use the `putc` function. This function is very similar to
`putchar`, but accepts an argument that specifies the stream to which to
write. It takes a single integer parameter containing a character (the
argument can be a single-quoted text character, as in the example
below), and sends the character to the specified stream. If a write
error occurs, `putc` returns `EOF`; otherwise, it returns the integer it
was passed. This can simply be disregarded, as in the example below.

The following code example creates a text file called
'`snazzyjazz.txt`'. It then writes an 'X', a space, and then a line of
ten exclamation marks ('!!!!!!!!!!') to the file, and a newline
character to it using the `putc` function. Notice the use of the `for`
loop; by this means, `putchar` can be used not just for one character,
but multiple times. , then writes ten exclamation mark characters
('!!!!!!!!!!')

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | #include <stdio.h>                |
|                                   |                                   |
|                                   | int main()                        |
|                                   | {                                 |
|                                   |   int i;                          |
|                                   |   FILE *my_stream;                |
|                                   |   char my_filename[] = "snazzyjaz |
|                                   | z.txt";                           |
|                                   |                                   |
|                                   |   my_stream = fopen (my_filename, |
|                                   |  "w");                            |
|                                   | ```                               |
|                                   |                                   |
|                                   | ``` {.smallexample}               |
|                                   | ```                               |
|                                   |                                   |
|                                   | ``` {.smallexample}               |
|                                   |   putc ('X', my_stream);          |
|                                   |   putc (' ', my_stream);          |
|                                   |   for (i=1; i<=10; i++)           |
|                                   |     {                             |
|                                   |       putc ('!', my_stream);      |
|                                   |     }                             |
|                                   |   putc ('\n', my_stream);         |
|                                   | ```                               |
|                                   |                                   |
|                                   | ``` {.smallexample}               |
|                                   | ```                               |
|                                   |                                   |
|                                   | ``` {.smallexample}               |
|                                   |   /* Close stream; skip error-che |
|                                   | cking for brevity of example */   |
|                                   |   fclose (my_stream);             |
|                                   |                                   |
|                                   |   return 0;                       |
|                                   | }                                 |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

There is another function in the GNU C Library called `fputc`. It is
identical to `putc` in most respects, except that `putc` is usually
implemented as a macro function and is highly optimised, so is
preferable in most situations.

------------------------------------------------------------------------

[]{#ungetc}

  --------------------------------------------------------------- ------------------------------------------------------------------- --- ------------------------------------------------------------------------------- --------------------------------------------------------------- -------------------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#putc-and-fputc "Previous section in reading order")\]   \[[\>](#Programming-with-pipes "Next section in reading order")\]       \[[\<\<](#Input-and-output "Beginning of this chapter or previous chapter")\]   \[[Up](#Single_002dcharacter-input-and-output "Up section")\]   \[[\>\>](#Putting-a-program-together "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  --------------------------------------------------------------- ------------------------------------------------------------------- --- ------------------------------------------------------------------------------- --------------------------------------------------------------- -------------------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#ungetc_0028_0029}

### 16.3.5 `ungetc()` {#ungetc .subsection}

[]{#index-ungetc-function} []{#index-File-position-indicator}
[]{#index-Unreading-characters} []{#index-Pushing-back-characters}

Every time a character is read from a stream by a function like `getc`,
the file position indicator advances by 1. It is possible to reverse the
motion of the file position indicator with the function `ungetc`, which
steps the file position indicator back by one byte within the file and
reverses the effect of the last character read operation. (This is
called *unreading* the character or *pushing it back* onto the stream.)

The intended purpose is to leave the indicator in the correct file
position when other functions have moved too far ahead in the stream.
Programs can therefore *peek ahead*, or get a glimpse of the input they
will read next, then reset the file position with `ungetc`.

[]{#index-Pushback}

On GNU systems, you cannot call `ungetc` twice in a row without reading
at least one character in between; in other words, GNU only supports one
character of *pushback*.

[]{#index-fseek-function-1} []{#index-rewind-function}

Pushing back characters does not change the file being accessed at all;
`ungetc` only affects the stream buffer, not the file. If `fseek`,
`rewind`, or some other file positioning function is called, any
character due to be pushed back by `ungetc` is discarded.

[]{#index-EOF-character}

Unreading a character on a stream that is at end-of-file resets the
end-of-file indicator for the stream, because there is once again a
character available to be read. However, if the character pushed back
onto the stream is `EOF`, `ungetc` does nothing and just returns `EOF`.

Here is a code example that reads all the whitespace at the beginning of
a file with `getc`, then backs up one byte to the first non-whitespace
character, and reads all following characters up to a newline character
with the `getline` function. (See section [`getline`](#getline), for
more information on that function.)

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | #include <stdio.h>                |
|                                   |                                   |
|                                   | int main()                        |
|                                   | {                                 |
|                                   |   int in_char;                    |
|                                   |   FILE *my_stream;                |
|                                   |   char *my_string = NULL;         |
|                                   |   size_t nchars = 0;              |
|                                   | ```                               |
|                                   |                                   |
|                                   | ``` {.smallexample}               |
|                                   | ```                               |
|                                   |                                   |
|                                   | ``` {.smallexample}               |
|                                   |   my_stream = fopen ("snazzyjazz. |
|                                   | txt", "w");                       |
|                                   |   fprintf (my_stream, "           |
|                                   | Here's some non-whitespace.\n");  |
|                                   |                                   |
|                                   |   /* Close stream; skip error-che |
|                                   | cking for brevity of example */   |
|                                   |   fclose (my_stream);             |
|                                   | ```                               |
|                                   |                                   |
|                                   | ``` {.smallexample}               |
|                                   | ```                               |
|                                   |                                   |
|                                   | ``` {.smallexample}               |
|                                   |   my_stream = fopen ("snazzyjazz. |
|                                   | txt", "r");                       |
|                                   |                                   |
|                                   |   /* Skip all whitespace in strea |
|                                   | m */                              |
|                                   |   do                              |
|                                   |     in_char = getc (my_stream);   |
|                                   |   while (isspace (in_char));      |
|                                   | ```                               |
|                                   |                                   |
|                                   | ``` {.smallexample}               |
|                                   | ```                               |
|                                   |                                   |
|                                   | ``` {.smallexample}               |
|                                   |   /* Back up to first non-whitesp |
|                                   | ace character */                  |
|                                   |   ungetc (in_char, my_stream);    |
|                                   |                                   |
|                                   |   getline (&my_string, &nchars, m |
|                                   | y_stream);                        |
|                                   |                                   |
|                                   |   /* Close stream; skip error-che |
|                                   | cking for brevity of example */   |
|                                   |   fclose (my_stream);             |
|                                   |                                   |
|                                   |   printf ("String read:\n");      |
|                                   |   printf ("%s", my_string);       |
|                                   |                                   |
|                                   |   return 0;                       |
|                                   | }                                 |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

The code example will skip all initial whitespace in the file
'`snazzyjazz.txt`', and display the following text on standard output:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | String read:                      |
|                                   | Here's some non-whitespace.       |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

------------------------------------------------------------------------

[]{#Programming-with-pipes}

  ------------------------------------------------------- ------------------------------------------------------------------------ --- ------------------------------------------------------------------------------- ------------------------------------------ -------------------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#ungetc "Previous section in reading order")\]   \[[\>](#Low_002dlevel-file-routines "Next section in reading order")\]       \[[\<\<](#Input-and-output "Beginning of this chapter or previous chapter")\]   \[[Up](#Input-and-output "Up section")\]   \[[\>\>](#Putting-a-program-together "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ------------------------------------------------------- ------------------------------------------------------------------------ --- ------------------------------------------------------------------------------- ------------------------------------------ -------------------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Programming-with-pipes-1}

16.4 Programming with pipes {#programming-with-pipes .section}
---------------------------

[]{#index-Pipes_002c-programming-with}

There may be times when you will wish to manipulate other programs on a
GNU system from within your C program. One good way to do so is the
facility called a *pipe*. Using pipes, you can read from or write to any
program on a GNU system that writes to standard output and reads from
standard input. (In the ancestors of modern GNU systems, pipes were
frequently files on disk; now they are usually streams or something
similar. They are called "pipes" because people usually visualise data
going in at one end and coming out at the other.)

For example, you might wish to send output from your program to a
printer. As mentioned in the introduction to this chapter, each printer
on your system is assigned a device name such as '`/dev/lp0`'. Pipes
provide a better way to send output to the printer than writing directly
to the device, however.

Pipes are useful for many things, not just sending output to the
printer. Suppose you wish to list all programs and processes running on
your computer that contain the string 'init' in their names. To do so at
the GNU/Linux command line, you would type something like the following
command:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | ps -A | grep init                 |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

[]{#index-Pipe-symbol-_0028_007c_0029}
[]{#index-_007c-_0028pipe-symbol_0029} []{#index-ps-command}
[]{#index-grep-command}

This command line takes the output of the `ps -A` command, which lists
all running processes, and pipes it with the pipe symbol ('\|') to the
`grep init` command, which returns all lines that were passed to it that
contain the string 'init'. The output of this whole process will
probably look something like this on your system:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   |     1 ?        00:00:11 init      |
|                                   |  4884 tty6     00:00:00 xinit     |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

[]{#index-popen-function} []{#index-pclose-function}

The pipe symbol '\|' is very handy for command-line pipes and pipes
within shell scripts, but it is also possible to set up and use pipes
within C programs. The two main C functions to remember in this regard
are `popen` and `pclose`.

The `popen` function accepts as its first argument a string containing a
shell command, such as `lpr`. Its second argument is a string containing
either the mode argument 'r' or 'w'. If you specify 'r', the pipe will
be open for reading; if you specify 'w', it will be open for writing.
The return value is a stream open for reading or writing, as the case
may be; if there is an error, `popen` returns a null pointer.

The `pclose` function closes a pipe opened by `popen`. It accepts a
single argument, the stream to close. It waits for the stream to close,
and returns the status code returned by the program that was called by
`popen`.

If you open the pipe for reading or writing, in between the `popen` and
`pclose` calls, it is possible to read from or write to the pipe in the
same way that you might read from or write to any other stream, with
high-level input/output calls such as `getdelim`, `fprintf` and so on.

The following program example shows how to pipe the output of the
`ps -A` command to the `grep init` command, exactly as in the GNU/Linux
command line example above. The output of this program should be almost
exactly the same as sample output shown above.

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | #include <stdio.h>                |
|                                   | #include <stdlib.h>               |
|                                   |                                   |
|                                   | int                               |
|                                   | main ()                           |
|                                   | {                                 |
|                                   |   FILE *ps_pipe;                  |
|                                   |   FILE *grep_pipe;                |
|                                   |                                   |
|                                   |   int bytes_read;                 |
|                                   |   int nbytes = 100;               |
|                                   |   char *my_string;                |
|                                   | ```                               |
|                                   |                                   |
|                                   | ``` {.smallexample}               |
|                                   | ```                               |
|                                   |                                   |
|                                   | ``` {.smallexample}               |
|                                   |   /* Open our two pipes */        |
|                                   |   ps_pipe = popen ("ps -A", "r"); |
|                                   |   grep_pipe = popen ("grep init", |
|                                   |  "w");                            |
|                                   | ```                               |
|                                   |                                   |
|                                   | ``` {.smallexample}               |
|                                   | ```                               |
|                                   |                                   |
|                                   | ``` {.smallexample}               |
|                                   |   /* Check that pipes are non-nul |
|                                   | l, therefore open */              |
|                                   |   if ((!ps_pipe) || (!grep_pipe)) |
|                                   |     {                             |
|                                   |       fprintf (stderr,            |
|                                   |                "One or both pipes |
|                                   |  failed.\n");                     |
|                                   |       return EXIT_FAILURE;        |
|                                   |     }                             |
|                                   | ```                               |
|                                   |                                   |
|                                   | ``` {.smallexample}               |
|                                   | ```                               |
|                                   |                                   |
|                                   | ``` {.smallexample}               |
|                                   |   /* Read from ps_pipe until two  |
|                                   | newlines */                       |
|                                   |   my_string = (char *) malloc (nb |
|                                   | ytes + 1);                        |
|                                   |   bytes_read = getdelim (&my_stri |
|                                   | ng, &nbytes, "\n\n", ps_pipe);    |
|                                   | ```                               |
|                                   |                                   |
|                                   | ``` {.smallexample}               |
|                                   | ```                               |
|                                   |                                   |
|                                   | ``` {.smallexample}               |
|                                   |   /* Close ps_pipe, checking for  |
|                                   | errors */                         |
|                                   |   if (pclose (ps_pipe) != 0)      |
|                                   |     {                             |
|                                   |       fprintf (stderr,            |
|                                   |                "Could not run 'ps |
|                                   | ', or other error.\n");           |
|                                   |     }                             |
|                                   | ```                               |
|                                   |                                   |
|                                   | ``` {.smallexample}               |
|                                   | ```                               |
|                                   |                                   |
|                                   | ``` {.smallexample}               |
|                                   |   /* Send output of 'ps -A' to 'g |
|                                   | rep init', with two newlines */   |
|                                   |   fprintf (grep_pipe, "%s\n\n", m |
|                                   | y_string);                        |
|                                   | ```                               |
|                                   |                                   |
|                                   | ``` {.smallexample}               |
|                                   | ```                               |
|                                   |                                   |
|                                   | ``` {.smallexample}               |
|                                   |   /* Close grep_pipe, cehcking fo |
|                                   | r errors */                       |
|                                   |   if (pclose (grep_pipe) != 0)    |
|                                   |     {                             |
|                                   |       fprintf (stderr,            |
|                                   |                "Could not run 'gr |
|                                   | ep', or other error.\n");         |
|                                   |     }                             |
|                                   | ```                               |
|                                   |                                   |
|                                   | ``` {.smallexample}               |
|                                   | ```                               |
|                                   |                                   |
|                                   | ``` {.smallexample}               |
|                                   |   /* Exit! */                     |
|                                   |   return 0;                       |
|                                   | }                                 |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

------------------------------------------------------------------------

[]{#Low_002dlevel-file-routines}

  ----------------------------------------------------------------------- ------------------------------------------------------------------- --- ------------------------------------------------------------------------------- ------------------------------------------ -------------------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Programming-with-pipes "Previous section in reading order")\]   \[[\>](#Usual-file-name-errors "Next section in reading order")\]       \[[\<\<](#Input-and-output "Beginning of this chapter or previous chapter")\]   \[[Up](#Input-and-output "Up section")\]   \[[\>\>](#Putting-a-program-together "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ----------------------------------------------------------------------- ------------------------------------------------------------------- --- ------------------------------------------------------------------------------- ------------------------------------------ -------------------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Low_002dlevel-file-routines-1}

16.5 Low-level file routines {#low-level-file-routines .section}
----------------------------

[]{#index-Low_002dlevel-file-functions}
[]{#index-File-functions_002c-low_002dlevel}

High-level file routines such as those already described are usually
convenient and easy to use. However, low-level file routines such as the
ones in this section have some advantages. For example, they do not
treat all file input/output as text streams, as the high-level routines
do; for that reason, working with binary files may be easier using
low-level routines. For another thing, low-level routines do not buffer
their input and output, so you will never need to remember to flush your
streams with `fflush` or similar functions, as you sometimes must with
high-level routines.

Unfortunately, because low-level routines work at a lower level of
abstraction, they can be tricky, even dangerous to use --- that is to
say, if used incorrectly, they may corrupt your data or cause your
program to terminate unexpectedly; never fear, they will not explode
your monitor or cause your computer to become sapient and attempt world
domination.

[]{#index-File-descriptors-2}

As mentioned, low-level file routines do not use text streams; instead,
the connection they open to your file is an integer called a *file
descriptor*. You pass the file descriptor that designates your file to
most low-level file routines, just as you pass the stream that
designates your file to most high-level file routines. For example,
while the low-level `open` function takes a filename string to open a
file, the matched `close` function takes the file descriptor returned by
`open`:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | my_file_descriptor = open ("foo_f |
|                                   | ile", O_RDONLY);                  |
|                                   | close_err = close (my_file_descri |
|                                   | ptor);                            |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

  ---------------------------------------------------------------------------------------- ---- --
  [16.5.1 Usual file name errors](#Usual-file-name-errors)                                      
  [16.5.2 Opening files at a low level](#Opening-files-at-a-low-level)                          
  [16.5.3 Closing files at a low level](#Closing-files-at-a-low-level)                          
  [16.5.4 Reading files at a low level](#Reading-files-at-a-low-level)                          
  [16.5.5 Writing files at a low level](#Writing-files-at-a-low-level)                          
  [16.5.6 Finding file positions at a low level](#Finding-file-positions-at-a-low-level)        
  [16.5.7 Deleting files at a low level](#Deleting-files-at-a-low-level)                        
  [16.5.8 Renaming files at a low level](#Renaming-files-at-a-low-level)                        
  ---------------------------------------------------------------------------------------- ---- --

------------------------------------------------------------------------

[]{#Usual-file-name-errors}

  ---------------------------------------------------------------------------- ------------------------------------------------------------------------- --- ------------------------------------------------------------------------------- ----------------------------------------------------- -------------------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Low_002dlevel-file-routines "Previous section in reading order")\]   \[[\>](#Opening-files-at-a-low-level "Next section in reading order")\]       \[[\<\<](#Input-and-output "Beginning of this chapter or previous chapter")\]   \[[Up](#Low_002dlevel-file-routines "Up section")\]   \[[\>\>](#Putting-a-program-together "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ---------------------------------------------------------------------------- ------------------------------------------------------------------------- --- ------------------------------------------------------------------------------- ----------------------------------------------------- -------------------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Usual-file-name-errors-1}

### 16.5.1 Usual file name errors {#usual-file-name-errors .subsection}

[]{#index-Usual-file-name-errors} []{#index-File-name-errors_002c-usual}

Most low-level file functions return some kind of error flag if they
cannot perform the action you request, for example, if they cannot parse
the file name or find the file. However, to discover *which* error or
*what kind of* error has occurred, you must frequently refer to the
system variable `errno`. This is an integer specifying the most recent
error that has occurred. Macros for values of `errno` are listed below.
They are all defined in the GNU C Library.

The word *component* below refers to part of a full file name. For
example, in the file name '`/home/fred/snozzberry.txt`', '`fred`' is a
component that designates a subdirectory of the directory '`/home`', and
'`snozzberry.txt`' is the name of the file proper.

Most functions that accept file name arguments can detect the following
error conditions. These are known as the *usual file name errors*. The
names of the errors, such as `EACCES`, are compounded of 'E' for "error"
and a term indicating the type of error, such as 'ACCES' for "access".

[]{#index-EACCES-file-name-error}

`EACCES`

The program is not permitted to search within one of the directories in
the file name.

[]{#index-ENAMETOOLONG-file-name-error}

`ENAMETOOLONG`

Either the full file name is too long, or some component is too long.
GNU does not limit the overall length of file names, but depending on
which file system you are using, the length of component names may be
limited. (For example, you may be running GNU/Linux but accessing a
Macintosh HFS disk; the names of Macintosh files cannot be longer than
31 characters.)

[]{#index-ENOENT-file-name-error}

`ENOENT`

Either some component of the file name does not exist, or some component
is a symbolic link whose target file does not exist.

[]{#index-ENOTDIR-file-name-error}

`ENOTDIR`

One of the file name components that is supposed to be a directory is
not a directory.

[]{#index-ELOOP-file-name-error}

`ELOOP`

Too many symbolic links had to be followed to find the file. (GNU has a
limit on how many symbolic links can be followed at once, as a basic way
to detect recursive (looping) links.)

[]{#index-m-output-conversion-specifier-1}

You can display English text for each of these errors with the 'm'
conversion specifier of the `printf` function, as in the following short
example.

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | errno = EACCES;                   |
|                                   | printf ("errno string (EACCES): % |
|                                   | m\n");                            |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

This example prints the following string:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | errno string (EACCES): Permission |
|                                   |  denied                           |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

See section [Formatted output conversion
specifiers](#Formatted-output-conversion-specifiers), for more
information on the 'm' conversion specifier.

------------------------------------------------------------------------

[]{#Opening-files-at-a-low-level}

  ----------------------------------------------------------------------- ---------------------------------------------------------- --- ------------------------------------------------------------------------------- ----------------------------------------------------- -------------------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Usual-file-name-errors "Previous section in reading order")\]   \[[\>](#File-creation "Next section in reading order")\]       \[[\<\<](#Input-and-output "Beginning of this chapter or previous chapter")\]   \[[Up](#Low_002dlevel-file-routines "Up section")\]   \[[\>\>](#Putting-a-program-together "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ----------------------------------------------------------------------- ---------------------------------------------------------- --- ------------------------------------------------------------------------------- ----------------------------------------------------- -------------------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Opening-files-at-a-low-level-1}

### 16.5.2 Opening files at a low level {#opening-files-at-a-low-level .subsection}

[]{#index-Opening-files-at-a-low-level}
[]{#index-Low-level_002c-opening-files-at}

You can open a file, or create one if it does not already exist, with
the `open` command, which creates and returns a new file descriptor for
the file name passed to it. If the file is successfully opened, the file
position indicator is initially set to zero (the beginning of the file).
(Note that the `open` function is actually called at an underlying level
by `fopen`.)

The first parameter of `open` is a string containing the filename of the
file you wish to open. The second parameter is an integer argument
created by the *bitwise OR* of the following file status flags. (Bitwise
OR is a mathematical operator that we have not yet covered in this book.
To perform bitwise OR on two variables `a` and `b`, you simply insert a
pipe character between them, thus: `a | b`. Bitwise OR is similar to the
way the expression "and/or" is used in English. See the code example
below for the use of bitwise OR with file status flags. See section
[Advanced operators](#Advanced-operators), for a detailed explanation of
bitwise OR and other bitwise operators.)

The following flags are the more important ones for a beginning C
programmer to know. There are a number of file status flags which are
relevant only to more advanced programmers; for more details, see
[(libc)File Status Flags](libc.html#File-Status-Flags) section 'File
Status Flags' in The GNU C Library Reference Manual.)

Note that these flags are defined in macros in the GNU C Library header
file '`fcntl.h`', so remember to insert the line `#include <fcntl.h>` at
the beginning of any source code file that uses them.

[]{#index-O_005fRDONLY-file-status-flag}

`O_RDONLY`

Open the file for read access.

[]{#index-O_005fWRONLY-file-status-flag}

`O_WRONLY`

Open the file for write access.

[]{#index-O_005fRDWR-file-status-flag}

`O_RDWR`

Open the file for both read and write access. Same as
`O_RDONLY | O_WRONLY`.

[]{#index-file-status-flag}

`O_READ`

Same as `O_RDWR`. GNU systems only.

[]{#index-O_005fWRITE-file-status-flag}

`O_WRITE`

Same as `O_WRONLY`. GNU systems only.

[]{#index-O_005fEXEC-file-status-flag}

`O_EXEC`

Open the file for executing. GNU systems only.

[]{#index-O_005fCREAT-file-status-flag}

`O_CREAT`

The file will be created if it doesn't already exist.

[]{#index-O_005fEXCL-file-status-flag}

`O_EXCL`

If `O_CREAT` is set as well, then `open` fails if the specified file
exists already. Set this flag if you want to ensure you will not clobber
an existing file.

[]{#index-O_005fTRUNC-file-status-flag}

`O_TRUNC`

Truncate the file to a length of zero bytes. This option is not useful
for directories or other such special files. You must have write
permission for the file, but you do not need to open it for write access
to truncate it (under GNU).

[]{#index-O_005fAPPEND-file-status-flag}

`O_APPEND`

Open the file for appending. All `write` operations then write the data
at the end of the file. This is the only way to ensure that the data you
write will always go to the end of the file, even if there are other
`write` operations happening at the same time.

[]{#index-open-function} []{#index-errno-system-variable}

The `open` function normally returns a non-negative integer file
descriptor connected to the specified file. If there is an error, `open`
will return -1 instead. In that case, you can check the `errno` variable
to see which error occurred. In addition to the usual file name errors,
`open` can set `errno` to the following values. (It can also specify a
few other errors of interest only to advanced C programmers. See
[(libc)Opening and Closing File](libc.html#Opening-and-Closing-File)
section 'Opening and Closing Files' in The GNU C Library Reference
Manual, for a full list of error values. See section [Usual file name
errors](#Usual-file-name-errors), for a list of the usual file name
errors.).

[]{#index-EACCES-file-name-error-1}

`EACCES`

The file exists but is cannot be does not have read or write access (as
requested), or the file does not exist but cannot be created because the
directory does not have write access.

[]{#index-EEXIST-file-name-error}

`EEXIST`

Both `O_CREAT` and `O_EXCL` are set, and the named file already exists.
To open it would clobber it, so it will not be opened.

[]{#index-EISDIR-file-name-error}

`EISDIR`

Write access to the file was requested, but the file is actually a
directory.

[]{#index-EMFILE-file-name-error}

`EMFILE`

Your program has too many files open.

[]{#index-ENOENT-file-name-error-1}

`ENOENT`

The file named does not exist, and `O_CREAT` was not specified, so the
file will not be created.

[]{#index-ENOSPC-file-name-error}

`ENOSPC`

The file cannot be created, because the disk is out of space.

[]{#index-EROFS-file-name-error}

`EROFS`

The file is on a read-only file system, but either one of `O_WRONLY`,
`O_RDWR`, or `O_TRUNC` was specified, or `O_CREAT` was set and the file
does not exist.

See section [Closing files at a low
level](#Closing-files-at-a-low-level), for a code example using both the
low-level file functions `open` and `close`.

  ------------------------------------------ ---- --
  [16.5.2.1 File creation](#File-creation)        
  ------------------------------------------ ---- --

------------------------------------------------------------------------

[]{#File-creation}

  ----------------------------------------------------------------------------- ------------------------------------------------------------------------- --- ------------------------------------------------------------------------------- ------------------------------------------------------ -------------------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Opening-files-at-a-low-level "Previous section in reading order")\]   \[[\>](#Closing-files-at-a-low-level "Next section in reading order")\]       \[[\<\<](#Input-and-output "Beginning of this chapter or previous chapter")\]   \[[Up](#Opening-files-at-a-low-level "Up section")\]   \[[\>\>](#Putting-a-program-together "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ----------------------------------------------------------------------------- ------------------------------------------------------------------------- --- ------------------------------------------------------------------------------- ------------------------------------------------------ -------------------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#File-creation-1}

#### 16.5.2.1 File creation {#file-creation .subsubsection}

[]{#index-File-creation} []{#index-Creation-of-files}
[]{#index-creat-function}

In older C code using low-level file routines, there was a function
called `creat` that was used for creating files. This function is still
included in GNU for compatibility with older C code, but is considered
obsolete. In order to create a file, instead of writing

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | creat (filename)                  |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

it is now considered better coding to practice to write the following
code:

[]{#index-open-function-1}

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | open (filename, O_WRONLY | O_CREA |
|                                   | T | O_TRUNC)                      |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

------------------------------------------------------------------------

[]{#Closing-files-at-a-low-level}

  -------------------------------------------------------------- ------------------------------------------------------------------------- --- ------------------------------------------------------------------------------- ----------------------------------------------------- -------------------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#File-creation "Previous section in reading order")\]   \[[\>](#Reading-files-at-a-low-level "Next section in reading order")\]       \[[\<\<](#Input-and-output "Beginning of this chapter or previous chapter")\]   \[[Up](#Low_002dlevel-file-routines "Up section")\]   \[[\>\>](#Putting-a-program-together "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  -------------------------------------------------------------- ------------------------------------------------------------------------- --- ------------------------------------------------------------------------------- ----------------------------------------------------- -------------------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Closing-files-at-a-low-level-1}

### 16.5.3 Closing files at a low level {#closing-files-at-a-low-level .subsection}

[]{#index-Closing-files-at-a-low-level}
[]{#index-Low-level_002c-closing-files-at}

To close a file descriptor, use the low-level file function `close`. The
sole argument to `close` is the file descriptor you wish to close.

[]{#index-close-function} []{#index-errno-system-variable-1}

The `close` function returns 0 if the call was successful, and -1 if
there was an error. In addition to the usual file name error codes, it
can set the system variable `errno` to one of the following values. It
can also set `errno` to several other values, mostly of interest to
advanced C programmers. See [(libc)Opening and Closing
Files](libc.html#Opening-and-Closing-Files) section 'Opening and Closing
Files' in The GNU C Library Reference Manual, for more information.

[]{#index-EBADF-file-name-error}

`EBADF`

The file descriptor passed to `close` is not valid.

[]{#index-fclose-function}

Remember, close a stream by using `fclose` instead. This allows the
necessary system bookkeeping to take place before the file is closed.

Here is a code example using both the low-level file functions `open`
and `close`.

[]{#index-open-function-2} []{#index-close-function-1}
[]{#index-open_002c-example-of} []{#index-close_002c-example-of}

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | #include <stdio.h>                |
|                                   | #include <fcntl.h>                |
|                                   |                                   |
|                                   | int main()                        |
|                                   | {                                 |
|                                   |                                   |
|                                   |   char my_filename[] = "snazzyjaz |
|                                   | z17.txt";                         |
|                                   |   int my_file_descriptor, close_e |
|                                   | rr;                               |
|                                   | ```                               |
|                                   |                                   |
|                                   | ``` {.smallexample}               |
|                                   | ```                               |
|                                   |                                   |
|                                   | ``` {.smallexample}               |
|                                   |   /*                              |
|                                   |     Open my_filename for writing. |
|                                   |   Create it if it does not exist. |
|                                   |     Do not clobber it if it does. |
|                                   |   */                              |
|                                   |                                   |
|                                   |   my_file_descriptor = open (my_f |
|                                   | ilename, O_WRONLY | O_CREAT | O_E |
|                                   | XCL);                             |
|                                   |   if (my_file_descriptor == -1)   |
|                                   |     {                             |
|                                   |       printf ("Open failed.\n");  |
|                                   |     }                             |
|                                   | ```                               |
|                                   |                                   |
|                                   | ``` {.smallexample}               |
|                                   | ```                               |
|                                   |                                   |
|                                   | ``` {.smallexample}               |
|                                   |   close_err = close (my_file_desc |
|                                   | riptor);                          |
|                                   |   if (close_err == -1)            |
|                                   |     {                             |
|                                   |       printf ("Close failed.\n"); |
|                                   |     }                             |
|                                   |                                   |
|                                   |   return 0;                       |
|                                   | }                                 |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

Running the above code example for the first time should produce no
errors, and should create an empty text file called
'`snazzyjazz17.txt`'. Running it a second time should display the
following errors on your monitor, since the file '`snazzyjazz17.txt`'
already exists, and should not be clobbered according to the flags
passed to `open`.

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | Open failed.                      |
|                                   | Close failed.                     |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

------------------------------------------------------------------------

[]{#Reading-files-at-a-low-level}

  ----------------------------------------------------------------------------- ------------------------------------------------------------------------- --- ------------------------------------------------------------------------------- ----------------------------------------------------- -------------------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Closing-files-at-a-low-level "Previous section in reading order")\]   \[[\>](#Writing-files-at-a-low-level "Next section in reading order")\]       \[[\<\<](#Input-and-output "Beginning of this chapter or previous chapter")\]   \[[Up](#Low_002dlevel-file-routines "Up section")\]   \[[\>\>](#Putting-a-program-together "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ----------------------------------------------------------------------------- ------------------------------------------------------------------------- --- ------------------------------------------------------------------------------- ----------------------------------------------------- -------------------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Reading-files-at-a-low-level-1}

### 16.5.4 Reading files at a low level {#reading-files-at-a-low-level .subsection}

[]{#index-Reading-files-at-a-low-level}
[]{#index-Low-level_002c-reading-files-at} []{#index-read-function}

You can read a block of information from a file with the `read`
function. The data read is loaded directly into a buffer in memory. The
data can be binary as well as a text, but if the latter, no terminating
newline is added. The bytes read start at the current file position;
after reading them, `read` advances the file position to immediately
after the bytes read.

The `read` function takes three parameters. The first one is the file
descriptor from which data is to be read. The second is the buffer in
memory where the data read will be stored. The buffer is of type
`void *`, and can be an array or a chunk of space reserved with
`malloc`. The final parameter is of type `size_t`, and specifies the
number of bytes to read.

The return value of this function is of type `ssize_t`, and represents
the number of bytes actually read. This might be less than the number of
bytes requested if there are not enough bytes left in the file or
immediately available. Reading less than the number of bytes requested
does not generate an error.

If the number of bytes requested is not zero, a return value of zero
indicates the end of the file. This is also not an error. If you keep
calling `read` at the end of the file, it will simply keep returning
zero. If `read` returns at least one character, you cannot tell whether
the end of the file was reached from that information, but `read` will
return zero on the next read operation if it was.

[]{#index-errno-system-variable-2}

If there was an error, `read` returns -1. You can then check the system
variable `errno` for one of the following error conditions, as well as
the usual file name errors. (See section [Usual file name
errors](#Usual-file-name-errors).) The `read` function can also return
some other error conditions in `errno` that are mostly of interest to
advanced C programmers. (See [(libc)I/O
Primitives](libc.html#I_002fO-Primitives) section 'Input and Output
Primitives' in The GNU C Library Reference Manual, for more
information.)

[]{#index-EBADF-file-name-error-1}

`EBADF`

The file descriptor passed to `read` is not valid, or is not open for
reading.

[]{#index-EIO-file-name-error}

`EIO`

There was a hardware error. (This error code also applies to more
abstruse conditions detailed in the GNU C Library manual.)

See section [Writing files at a low
level](#Writing-files-at-a-low-level), for a code example that uses the
`read` function.

------------------------------------------------------------------------

[]{#Writing-files-at-a-low-level}

  ----------------------------------------------------------------------------- ---------------------------------------------------------------------------------- --- ------------------------------------------------------------------------------- ----------------------------------------------------- -------------------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Reading-files-at-a-low-level "Previous section in reading order")\]   \[[\>](#Finding-file-positions-at-a-low-level "Next section in reading order")\]       \[[\<\<](#Input-and-output "Beginning of this chapter or previous chapter")\]   \[[Up](#Low_002dlevel-file-routines "Up section")\]   \[[\>\>](#Putting-a-program-together "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ----------------------------------------------------------------------------- ---------------------------------------------------------------------------------- --- ------------------------------------------------------------------------------- ----------------------------------------------------- -------------------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Writing-files-at-a-low-level-1}

### 16.5.5 Writing files at a low level {#writing-files-at-a-low-level .subsection}

[]{#index-Writing-files-at-a-low-level}
[]{#index-Low-level_002c-writing-files-at} []{#index-write-function}

You can write a block of information to a file with the `write`
function, which is called by all high-level file writing routines, such
as `fwrite`. It takes three parameters. The first is the file descriptor
of the file you wish to write to. The second is a buffer, of type
`void *`, that contains the data you wish to write. (It can be an array
of bytes, but need not be a text string. Null characters in the data are
treated in the same way as other characters.) The third parameter is of
type `size_t`, and specifies the number of bytes that are to be written.

The return value of this function is of type `ssize_t`, and indicates
the number of bytes actually written. This may be the same as the third
parameter (the number of bytes to be written), but may be less; you
should always call `write` in a loop, and iterate the loop until all
data has been written. If there is an error, `write` returns -1. The
`write` function will return the following error codes in the system
variable `errno`, as well as the usual file name errors. (See section
[Usual file name errors](#Usual-file-name-errors).)

[]{#index-EBADF-file-name-error-2}

`EBADF`

The file descriptor specified is invalid, or is not open for writing.

[]{#index-EFBIG-file-name-error}

`EFBIG`

If the data were written, the file written to would become too large.

[]{#index-EIO-file-name-error-1}

`EIO`

There has been a hardware error.

[]{#index-EINTR-file-name-error}

`EINTR`

The write operation was temporarily interrupted.

[]{#index-ENOSPC-file-name-error-1}

`ENOSPC`

The device containing the file is full.

In addition to the error codes above, `write` can return some error
codes that are mainly of interest to advanced C programmers. If `write`
fails, you should check `errno` to see if the error was `EINTR`; if it
was, you should repeat the `write` call each time.

[]{#index-fsync-function}

Even though low-level file routines do not use buffering, and once you
call `write`, your data can be read from the file immediately, it may
take up to a minute before your data is physically written to disk. You
can call the `fsync` routine (see below) to ensure that all data is
written to the file; this usage is roughly analogous to the high-level
file routine `fflush`.

[]{#index-errno-system-variable-3}

The `fsync` routine takes a single parameter, the file descriptor to
synchronise. It does not return a value until all data has been written.
If no error occurred, it returns a 0; otherwise, it returns -1 and sets
the system variable `errno` to one of the following values:

[]{#index-EBADF-file-name-error-3}

`EBADF`

The file descriptor specified is invalid.

[]{#index-EINVAL-file-name-error}

`EINVAL`

No synchronization is possible because the system does not implement it.

Here is a code example that demonstrates the use of the `write`, `read`,
and `fsync` functions. (See section [Reading files at a low
level](#Reading-files-at-a-low-level), for more information on `read`.)

[]{#index-write-function-1} []{#index-read-function-1}
[]{#index-fsync-function-1} []{#index-write_002c-example-of}
[]{#index-read_002c-example-of} []{#index-fsync_002c-example-of}

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | #include <stdio.h>                |
|                                   | #include <fcntl.h>                |
|                                   |                                   |
|                                   | int main()                        |
|                                   | {                                 |
|                                   |   char my_write_str[] = "12345678 |
|                                   | 90";                              |
|                                   |   char my_read_str[100];          |
|                                   |   char my_filename[] = "snazzyjaz |
|                                   | z.txt";                           |
|                                   |   int my_file_descriptor, close_e |
|                                   | rr;                               |
|                                   | ```                               |
|                                   |                                   |
|                                   | ``` {.smallexample}               |
|                                   | ```                               |
|                                   |                                   |
|                                   | ``` {.smallexample}               |
|                                   |   /* Open the file.  Clobber it i |
|                                   | f it exists. */                   |
|                                   |   my_file_descriptor = open (my_f |
|                                   | ilename, O_RDWR | O_CREAT | O_TRU |
|                                   | NC);                              |
|                                   |                                   |
|                                   |   /* Write 10 bytes of data and m |
|                                   | ake sure it's written */          |
|                                   |   write (my_file_descriptor, (voi |
|                                   | d *) my_write_str, 10);           |
|                                   |   fsync (my_file_descriptor);     |
|                                   | ```                               |
|                                   |                                   |
|                                   | ``` {.smallexample}               |
|                                   | ```                               |
|                                   |                                   |
|                                   | ``` {.smallexample}               |
|                                   |   /* Seek the beginning of the fi |
|                                   | le */                             |
|                                   |   lseek (my_file_descriptor, 0, S |
|                                   | EEK_SET);                         |
|                                   |                                   |
|                                   |   /* Read 10 bytes of data */     |
|                                   |   read (my_file_descriptor, (void |
|                                   |  *) my_read_str, 10);             |
|                                   | ```                               |
|                                   |                                   |
|                                   | ``` {.smallexample}               |
|                                   | ```                               |
|                                   |                                   |
|                                   | ``` {.smallexample}               |
|                                   |   /* Terminate the data we've rea |
|                                   | d with a null character */        |
|                                   |   my_read_str[10] = '\0';         |
|                                   |                                   |
|                                   |   printf ("String read = %s.\n",  |
|                                   | my_read_str);                     |
|                                   |                                   |
|                                   |   close (my_file_descriptor);     |
|                                   |                                   |
|                                   |   return 0;                       |
|                                   | }                                 |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

------------------------------------------------------------------------

[]{#Finding-file-positions-at-a-low-level}

  ----------------------------------------------------------------------------- -------------------------------------------------------------------------- --- ------------------------------------------------------------------------------- ----------------------------------------------------- -------------------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Writing-files-at-a-low-level "Previous section in reading order")\]   \[[\>](#Deleting-files-at-a-low-level "Next section in reading order")\]       \[[\<\<](#Input-and-output "Beginning of this chapter or previous chapter")\]   \[[Up](#Low_002dlevel-file-routines "Up section")\]   \[[\>\>](#Putting-a-program-together "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ----------------------------------------------------------------------------- -------------------------------------------------------------------------- --- ------------------------------------------------------------------------------- ----------------------------------------------------- -------------------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Finding-file-positions-at-a-low-level-1}

### 16.5.6 Finding file positions at a low level {#finding-file-positions-at-a-low-level .subsection}

[]{#index-Finding-file-positions-at-a-low-level}
[]{#index-Low-level_002c-finding-file-positions-at}
[]{#index-lseek-function}

If you want to find a particular file position within a file, using a
low-level file routine, you can call the `lseek` function. This is very
similar to the high-level file routine `fseek`, except that it accepts a
file descriptor rather than a stream as an argument.

The `lseek` function specifies the file position for the next `read` or
`write` operation. (See section [File position](#File-position), for
more information on file positions.)

[]{#index-SEEK_005fSET-constant} []{#index-SEEK_005fCUR-constant}
[]{#index-SEEK_005fEND-constant}

The `lseek` function takes three parameters. The first parameter is the
file descriptor. The second is of type `off_t` and specifies the number
of bytes to move the file position indicator. The third argument and the
third parameter is a constant that specifies whether the offset is
relative to the beginning of the file (`SEEK_SET`), to the current file
position (`SEEK_CUR`), or to the end of the file (`SEEK_END`). If
`SEEK_CUR` or `SEEK_END` is used, the offset specified can be positive
or negative. If you specify `SEEK_END`, set the position past the
current end of the file, and actually write data, you will extend the
file with zeroes up to the position you specify. However, the blocks of
zeroes are not actually written to disk, so the file takes up less space
on disk than it seems to; this is called a *sparse file*.

[]{#index-off_005ft-type}

The return value of `lseek` is of type `off_t` and normally contains the
resulting file position, as measured in bytes from the beginning of the
file. If you wish to read the current file position, therefore, you can
specify an offset of 0 and a third parameter of `SEEK_CUR`, as follows:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | file_position = lseek (file_descr |
|                                   | iptor, 0, SEEK_CUR);              |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

If there was an error, `lseek` returns a -1 and sets the system variable
`errno` to one of the following values:

[]{#index-EBADF-file-name-error-4}

`EBADF`

The file descriptor specified is invalid.

[]{#index-EINVAL-file-name-error-1}

`EINVAL`

Either the third parameter of `lseek` is invalid, or the file offset is
invalid.

[]{#index-ESPIPE-file-name-error}

`ESPIPE`

The file descriptor corresponds to an object that cannot be positioned,
such as a terminal device.

The `lseek` function is called by many high-level file position
functions, including `fseek`, `rewind`, and `ftell`.

------------------------------------------------------------------------

[]{#Deleting-files-at-a-low-level}

  -------------------------------------------------------------------------------------- -------------------------------------------------------------------------- --- ------------------------------------------------------------------------------- ----------------------------------------------------- -------------------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Finding-file-positions-at-a-low-level "Previous section in reading order")\]   \[[\>](#Renaming-files-at-a-low-level "Next section in reading order")\]       \[[\<\<](#Input-and-output "Beginning of this chapter or previous chapter")\]   \[[Up](#Low_002dlevel-file-routines "Up section")\]   \[[\>\>](#Putting-a-program-together "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  -------------------------------------------------------------------------------------- -------------------------------------------------------------------------- --- ------------------------------------------------------------------------------- ----------------------------------------------------- -------------------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Deleting-files-at-a-low-level-1}

### 16.5.7 Deleting files at a low level {#deleting-files-at-a-low-level .subsection}

[]{#index-Deleting-files-at-a-low-level}
[]{#index-Low-level_002c-deleting-files-at} []{#index-unlink-function}

If you want to delete a file, you can use the low-level file routine
`unlink`, as declared in the file '`unistd.h`'. Simply pass this routine
the name of the file you wish to delete. If this is the only name the
file has (that is, if no one has created a hard link to the file with
the `link` function, the GNU command `ln`, or something similar), then
the file itself will be deleted; otherwise, only that name will be
deleted. (See the section \"Hard Links\" in the GNU C Library manual for
more information on hard links.) If the file is open when `unlink` is
called, `unlink` will wait for the file to be closed before it deletes
it.

The `unlink` function returns 0 if the file or file name was
successfully deleted. If there was an error, `unlink` returns -1. In
addition to the usual file name errors, `unlink` can set `errno` to the
following values. (See section [Usual file name
errors](#Usual-file-name-errors), for a list of the usual file name
errors.)

[]{#index-EACCES-file-name-error-2}

`EACCES`

Your program does not have permission to delete the file from the
directory that contains it.

[]{#index-EBUSY-file-name-error}

`EBUSY`

The file is currently being used by the system and cannot be deleted.

[]{#index-ENOENT-file-name-error-2}

`ENOENT`

The file name to be deleted does not exist.

[]{#index-EPERM-file-name-error}

`EPERM`

Your program tried to delete a directory with `unlink`; this is not
permitted under GNU. (See `remove` below.)

[]{#index-EROFS-file-name-error-1}

`EROFS`

The file name is on a read-only file system and cannot be deleted.

[]{#index-errno-system-variable-4} []{#index-rmdir-function}

If you wish to delete a directory rather than an ordinary file, use the
`rmdir` function. Simply pass it the name of an empty directory you wish
to delete. It acts like `unlink` in most respects, except that it can
return an extra error code in the system variable `errno`:

[]{#index-ENOTEMPTY-file-name-error}

`ENOTEMPTY`

The directory was not empty, so cannot be deleted. This code is
synonymous with `EEXIST`, but GNU always returns `ENOTEMPTY`.

------------------------------------------------------------------------

[]{#Renaming-files-at-a-low-level}

  ------------------------------------------------------------------------------ --------------------------------------------------------- --- ------------------------------------------------------------------------------- ----------------------------------------------------- -------------------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Deleting-files-at-a-low-level "Previous section in reading order")\]   \[[\>](#Questions-16 "Next section in reading order")\]       \[[\<\<](#Input-and-output "Beginning of this chapter or previous chapter")\]   \[[Up](#Low_002dlevel-file-routines "Up section")\]   \[[\>\>](#Putting-a-program-together "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ------------------------------------------------------------------------------ --------------------------------------------------------- --- ------------------------------------------------------------------------------- ----------------------------------------------------- -------------------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Renaming-files-at-a-low-level-1}

### 16.5.8 Renaming files at a low level {#renaming-files-at-a-low-level .subsection}

[]{#index-Renaming-files-at-a-low-level}
[]{#index-Low-level_002c-renaming-files-at} []{#index-rename-function}

If you want to rename a file, you can use the `rename` function, which
takes two parameters. The first parameter is a string containing the old
name of the file, and the second is a string containing the new name.
(As with `unlink`, this function only operates on one of the names of a
file, if the file has hard links. See section [Deleting files at a low
level](#Deleting-files-at-a-low-level), for caveats and information on
hard links.)

Both the new name and the old name must be on the same file system. Any
file in the same directory that has the same name as the new file name
will be deleted in the process of renaming the file.

[]{#index-errno-system-variable-5}

If `rename` fails, it will return -1. In addition to the usual file name
errors, `unlink` can set `errno` to the following values. (See section
[Usual file name errors](#Usual-file-name-errors), for a list of the
usual file name errors.)

[]{#index-EACCES-file-name-error-3}

`EACCES`

Either one of the directories in question (either the one containing the
old name or the one containing the new name) refuses write permission,
or the new name and the old name are directories, and write permission
is refused for at least one of them.

[]{#index-EBUSY-file-name-error-1}

`EBUSY`

One of the directories used by the old name or the new name is being
used by the system and cannot be changed.

[]{#index-ENOTEMPTY-file-name-error-1}

`ENOTEMPTY`

The directory was not empty, so cannot be deleted. This code is
synonymous with `EEXIST`, but GNU always returns `ENOTEMPTY`.

[]{#index-EINVAL-file-name-error-2}

`EINVAL`

The old name is a directory that contains the new name.

[]{#index-EISDIR-file-name-error-1}

`EISDIR`

The new name is a directory, but the old name is not.

[]{#index-EMLINK-file-name-error}

`EMLINK`

The parent directory of the new name would contain too many entries if
the new name were created.

[]{#index-ENOENT-file-name-error-3}

`ENOENT`

The old name does not exist.

[]{#index-ENOSPC-file-name-error-2}

`ENOSPC`

The directory that would contain the new name has no room for another
entry, and cannot be expanded.

[]{#index-EROFS-file-name-error-2}

`EROFS`

The rename operation would involve writing on a read-only file system.

[]{#index-EXDEV-file-name-error}

`EXDEV`

The new name and the old name are on different file systems.

------------------------------------------------------------------------

[]{#Questions-16}

  ------------------------------------------------------------------------------ ----------------------------------------------------------------------- --- ------------------------------------------------------------------------------- ------------------------------------------ -------------------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Renaming-files-at-a-low-level "Previous section in reading order")\]   \[[\>](#Putting-a-program-together "Next section in reading order")\]       \[[\<\<](#Input-and-output "Beginning of this chapter or previous chapter")\]   \[[Up](#Input-and-output "Up section")\]   \[[\>\>](#Putting-a-program-together "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ------------------------------------------------------------------------------ ----------------------------------------------------------------------- --- ------------------------------------------------------------------------------- ------------------------------------------ -------------------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Questions-1}

16.6 Questions {#questions-1 .section}
--------------

1.  What are the following?
    1.  File name
    2.  File descriptor
    3.  Stream
2.  What is a pseudo-device name?
3.  Where does '`stdin`' usually get its input?
4.  Where does '`stdout`' usually send its output?
5.  Write a program that simply prints out the following string to the
    screen: '6.23e+00'.
6.  Investigate what happens when you type the wrong conversion
    specifier in a program. e.g. try printing an integer with '%f' or a
    floating point number with '%c'. This is bound to go wrong -- but
    how will it go wrong?
7.  What is wrong with the following statements?

    1.  `printf (x);`
    2.  `printf ("%d");`
    3.  `printf ();`
    4.  `printf ("Number = %d");`

    Hint: if you don't know, try them in a program!

8.  What is a whitespace character?
9.  Write a program that aceepts two integers from the user, multiplies
    them together, and prints the answer on your printer. Try to make
    the input as safe as possible.
10. Write a program that simply echoes all the input to the output.
11. Write a program that strips all space characters out of the input
    and replaces each string of them with a single newline character.
12. The `scanf` function always takes pointer arguments. True or false?
13. What is the basic difference between high-level and low-level file
    routines?
14. Write a statement that opens a high level file for reading.
15. Write a statement that opens a low level file for writing.
16. Write a program that checks for illegal characters in text files.
    The only valid characters are ASCII codes 10, 13, and 32..126.
17. What statement performs formatted writing to text files?
18. Poke around in the header files on your system so you can see what
    is defined where.

------------------------------------------------------------------------

[]{#Putting-a-program-together}

  ------------------------------------------------------------- ---------------------------------------------------------- --- ------------------------------------------------------------------------------- ----------------------------- ------------------------------------------------ --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Questions-16 "Previous section in reading order")\]   \[[\>](#argc-and-argv "Next section in reading order")\]       \[[\<\<](#Input-and-output "Beginning of this chapter or previous chapter")\]   \[[Up](#Top "Up section")\]   \[[\>\>](#Advanced-operators "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ------------------------------------------------------------- ---------------------------------------------------------- --- ------------------------------------------------------------------------------- ----------------------------- ------------------------------------------------ --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Putting-a-program-together-1}

17. Putting a program together {#putting-a-program-together .chapter}
==============================

This chapter explains, step by step, how to create a "real" program that
meets GNU standards for a command-line interface. It also discusses how
to create a program whose source is split into multiple files, and how
to compile it, with or without the GNU utility `make`. Finally, it
discusses how to create a code library, in case you write some useful
functions that you want to share with other programmers.

*Putting it all together.*

  ------------------------------------------------------------------------------ ---- --
  [17.1 `argc` and `argv`](#argc-and-argv)                                            
  [17.2 Processing command-line options](#Processing-command_002dline-options)        
  [17.3 Environment variables](#Environment-variables)                                
  [17.4 Compiling multiple files](#Compiling-multiple-files)                          
  [17.5 Writing a makefile](#Writing-a-makefile)                                      
  [17.6 Building a library](#Building-a-library)                                      
  [17.7 Questions](#Questions-17)                                                     
  ------------------------------------------------------------------------------ ---- --

------------------------------------------------------------------------

[]{#argc-and-argv}

  --------------------------------------------------------------------------- -------------------------------------------------------------------------------- --- ----------------------------------------------------------------------------------------- ---------------------------------------------------- ------------------------------------------------ --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Putting-a-program-together "Previous section in reading order")\]   \[[\>](#Processing-command_002dline-options "Next section in reading order")\]       \[[\<\<](#Putting-a-program-together "Beginning of this chapter or previous chapter")\]   \[[Up](#Putting-a-program-together "Up section")\]   \[[\>\>](#Advanced-operators "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  --------------------------------------------------------------------------- -------------------------------------------------------------------------------- --- ----------------------------------------------------------------------------------------- ---------------------------------------------------- ------------------------------------------------ --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#argc-and-argv-1}

17.1 `argc` and `argv` {#argc-and-argv .section}
----------------------

[]{#index-Argument-vector} []{#index-argc-variable}
[]{#index-argv-variable}

So far, all the programs we have written can be run with a single
command. For example, if we compile an executable called '`myprog`', we
can run it from within the same directory with the following command at
the GNU/Linux command line:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | ./myprog                          |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

[]{#index-Passing-information-to-program} []{#index-gcc-1}

However, what if you want to pass information from the command line to
the program you are running? Consider a more complex program like GCC.
To compile the hypothetical '`myprog`' executable, we type something
like the following at the command line:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | gcc -o myprog myprog.c            |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

The character strings '-o', 'myprog', and 'myprog.c' are all *arguments*
to the `gcc` command. (Technically 'gcc' is an argument as well, as we
shall see.)

Command-line arguments are very useful. After all, C functions wouldn't
be very useful if you couldn't ever pass arguments to them --- adding
the ability to pass arguments to programs makes them that much more
useful. In fact, all the arguments you pass on the command line end up
as arguments to the `main` function in your program.

Up until now, the skeletons we have used for our C programs have looked
something like this:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | #include <stdio.h>                |
|                                   |                                   |
|                                   | int main()                        |
|                                   | {                                 |
|                                   |                                   |
|                                   |   return 0;                       |
|                                   | }                                 |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

From now on, our examples may look a bit more like this:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | #include <stdio.h>                |
|                                   |                                   |
|                                   | int main (int argc, char *argv[]) |
|                                   | {                                 |
|                                   |                                   |
|                                   |   return 0;                       |
|                                   | }                                 |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

[]{#index-Argument-count-variable} []{#index-Argument-vector-1}

As you can see, `main` now has arguments. The name of the variable
`argc` stands for "argument count"; `argc` contains the number of
arguments passed to the program. The name of the variable `argv` stands
for "argument vector". A vector is a one-dimensional array, and `argv`
is a one-dimensional array of strings. Each string is one of the
arguments that was passed to the program.

For example, the command line

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | gcc -o myprog myprog.c            |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

would result in the following values internal to GCC:

 `argc`

:   4

 `argv[0]`

:   'gcc'

 `argv[1]`

:   '-o'

 `argv[2]`

:   'myprog'

 `argv[3]`

:   'myprog.c'

As you can see, the first argument (`argv[0]`) is the name by which the
program was called, in this case 'gcc'. Thus, there will always be at
least one argument to a program, and `argc` will always be at least 1.

The following program accepts any number of command-line arguments and
prints them out:

[]{#index-argc-variable-1} []{#index-argv-variable-1}
[]{#index-argc_002c-example-of} []{#index-argv_002c-example-of}

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | #include <stdio.h>                |
|                                   |                                   |
|                                   | int main (int argc, char *argv[]) |
|                                   | {                                 |
|                                   |   int count;                      |
|                                   |                                   |
|                                   |   printf ("This program was calle |
|                                   | d with \"%s\".\n",argv[0]);       |
|                                   | ```                               |
|                                   |                                   |
|                                   | ``` {.smallexample}               |
|                                   | ```                               |
|                                   |                                   |
|                                   | ``` {.smallexample}               |
|                                   |   if (argc > 1)                   |
|                                   |     {                             |
|                                   |       for (count = 1; count < arg |
|                                   | c; count++)                       |
|                                   |     {                             |
|                                   |       printf("argv[%d] = %s\n", c |
|                                   | ount, argv[count]);               |
|                                   |     }                             |
|                                   |     }                             |
|                                   |   else                            |
|                                   |     {                             |
|                                   |       printf("The command had no  |
|                                   | other arguments.\n");             |
|                                   |     }                             |
|                                   |                                   |
|                                   |   return 0;                       |
|                                   | }                                 |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

If you name your executable '`fubar`', and call it with the command
'./fubar a b c', it will print out the following text:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | This program was called with "./f |
|                                   | ubar".                            |
|                                   | argv[1] = a                       |
|                                   | argv[2] = b                       |
|                                   | argv[3] = c                       |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

------------------------------------------------------------------------

[]{#Processing-command_002dline-options}

  -------------------------------------------------------------- ------------------------------------------------------------- --- ----------------------------------------------------------------------------------------- ---------------------------------------------------- ------------------------------------------------ --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#argc-and-argv "Previous section in reading order")\]   \[[\>](#argp-description "Next section in reading order")\]       \[[\<\<](#Putting-a-program-together "Beginning of this chapter or previous chapter")\]   \[[Up](#Putting-a-program-together "Up section")\]   \[[\>\>](#Advanced-operators "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  -------------------------------------------------------------- ------------------------------------------------------------- --- ----------------------------------------------------------------------------------------- ---------------------------------------------------- ------------------------------------------------ --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Processing-command_002dline-options-1}

17.2 Processing command-line options {#processing-command-line-options .section}
------------------------------------

[]{#index-getopt-function} []{#index-argp-function}

It is easy, though tedious to pull options directly out of the `argv`
vector with your own routines. It is slightly less tedious to use the
standard C option-processing function `getopt`, or the enhanced GNU
version of the same function, `getopt_long`, which permits GNU-style
*long options* (for example, '\--quiet' as opposed to '-q').

The best option of all is to use the `argp` interface for processing
options. Professionally written programs provide the user with standard
and useful options. The `argp` function provides for these. For the
modest price of setting up your command line arguments in a structured
way, and with surprisingly few lines of code, you can obtain all the
perks of a "real" GNU program, such as "automagically"-generated output
to the '\--help', '\--usage', and '\--version' options, as defined by
the GNU coding standards. Using `argp` results in a more consistent
look-and-feel for programs that use it, and makes it less likely that
the built-in documentation for a program will be wrong or out of date.

[]{#index-POSIX-standard_002c-command_002dline-conventions}
[]{#index-Command_002dline-options}
[]{#index-Options_002c-command_002dline}

POSIX, the Portable Operating System Interface standard, recommends the
following conventions for command-line arguments. The `argp` interface
makes implementing them easy.

-   Command-line arguments are *options* if they begin with a hyphen
    ('-').
-   Multiple options may follow a hyphen in a cluster if they do not
    take arguments. Thus, '-abc' and '-a -b -c' are the same.
-   Option names are single alphanumeric characters.
-   Options may require an argument. For example, the '-o' option of the
    `ld` command requires an output file name.
-   The whitespace separating an option and its argument is optional.
    Thus, '-o foo' and '-ofoo' are the same.
-   Options usually precede non-option arguments. (In fact, `argp` is
    more flexible than this; if you want to suppress this flexibility,
    define the `_POSIX_OPTION_ORDER` environment variable.)
-   The argument '\--' terminates all options; all following
    command-line arguments are considered non-option arguments, even if
    they begin with a hyphen.
-   A single hyphen as an argument is considered a non-option argument;
    by convention, it is used to specify input from standard input or
    output to standard output.
-   Options may appear in any order, even multiple times. The meaning of
    this is left to the application.

[]{#index-Long-options_002c-GNU} []{#index-GNU-long-options}

In addition, GNU adds *long options*, like the '\--help', '\--usage',
and '\--version' options mentioned above. A long option starts with
'\--', which is then followed by a string of alphanumeric characters and
hyphens. Option names are usually one to three words long, with hyphens
to separate words. Users can abbreviate the option names as long as the
abbreviations are unique. A long option (such as '\--verbose') often has
a short-option synonym (such as '-v').

Long options can accept optional (that is, non-necessary) arguments. You
can specify an argument for a long option as follows:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | ‘--’option-name‘=’value           |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

You may not type whitespace between the option name and the equals sign,
or between the equals sign and the option value.

  ------------------------------------------------ ---- --
  [17.2.1 `argp` description](#argp-description)        
  [17.2.2 `argp` example](#argp-example)                
  ------------------------------------------------ ---- --

------------------------------------------------------------------------

[]{#argp-description}

  ------------------------------------------------------------------------------------ --------------------------------------------------------- --- ----------------------------------------------------------------------------------------- ------------------------------------------------------------- ------------------------------------------------ --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Processing-command_002dline-options "Previous section in reading order")\]   \[[\>](#argp-example "Next section in reading order")\]       \[[\<\<](#Putting-a-program-together "Beginning of this chapter or previous chapter")\]   \[[Up](#Processing-command_002dline-options "Up section")\]   \[[\>\>](#Advanced-operators "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ------------------------------------------------------------------------------------ --------------------------------------------------------- --- ----------------------------------------------------------------------------------------- ------------------------------------------------------------- ------------------------------------------------ --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#argp-description-1}

### 17.2.1 `argp` description {#argp-description .subsection}

[]{#index-argp-function-1}

This section will describe how to write a simple program that implements
most of the standards mentioned above. It assumes some knowledge of
advanced C data structures that we have not yet covered in this book; if
you are confused, you might want to consult the chapter that discusses
this material. (See section [More data types](#More-data-types).) Note
that we are only discussing the basics of `argp` in this chapter; to
read more about this complicated and flexible facility of the GNU C
Library, consult [(libc)Argp](libc.html#Argp) section 'Parsing Program
Options with Argp' in The GNU C Library Reference Manual. Nevertheless,
what you learn in this chapter may be all you need to develop a program
that is compliant with GNU coding standards, with respect to
command-line options.

[]{#index-ARGP-structure} []{#index-argp_005fparse-function}
[]{#index-arguments-structure}

The main interface to `argp` is the `argp_parse` function. Usually, the
only argument-parsing code you will need in `main` is a call to this
function. The first parameter it takes is of type
`const struct argp *argp`, and specifies an `ARGP` structure (see
below). (A value of zero is the same as a structure containing all
zeros.) The second parameter is simply `argc`, the third simply `argv`.
The fourth parameter is a set of flags that modify the parsing
behaviour; setting this to zero usually doesn't hurt unless you're doing
something fancy, and the same goes for the fifth parameter. The sixth
parameter can be useful; in the example below, we use it to pass
information from `main` to our function `parse_opt`, which does most of
the work of initalizing internal variables (fields in the `arguments`
structure) based on command-line options and arguments.

[]{#index-error_005ft-function} []{#index-ENOMEM-error-code}
[]{#index-EINVAL-error-code}

The `argp_parse` returns a value of type `error_t`: usually either 0 for
success, `ENOMEM` if a memory allocation error occurred, or `EINVAL` if
an unknown option or argument was met with.

[]{#index-ARGP-structure-1}

For this example, we are using only the first four fields in `ARGP`,
which are usually all that is needed. The rest of the fields will
default to zero. The four fields are, in order:

1.  []{#index-OPTIONS-field} []{#index-argp_005foption-structure}
2.  `OPTIONS`: A pointer to a vector the elements of which are of type
    `struct argp_option`, which contains four fields. The vector
    elements specify which options this parser understands. If you
    assign your option structure by initializing the array as we do in
    this section's main example, unspecified fields will default to
    zero, and need not be specified. The whole vector may contain zero
    if there are no options at all. It should in any case be terminated
    by an entry with a zero in all fields (as we do by specifying the
    last item in the `options` vector to be `{0}` in the main example
    below.

    The four main `argp_option` structure fields are as follows. (We
    will ignore the fifth one, which is relatively unimportant and will
    simply default to zero if you do not specify it.)

    []{#index-argp_005foption-structure-fields}

    1.  []{#index-NAME-field}
    2.  `NAME`: The name of this option's long option (may be zero). To
        specify multiple names for an option, follow it with additional
        entries, with the `OPTION_ALIAS` flag set. []{#index-KEY-field}
    3.  `KEY`: The integer key to pass to the `PARSER` function when
        parsing the current option; this is the same as the name of the
        current option's short option, if it is a printable ASCII
        character. []{#index-ARG-field}
    4.  `ARG`: The name of this option's argument, if any.
        []{#index-FLAGS-field}
    5.  `FLAGS`: Flags describing this option. You can specify multiple
        flags with logical OR (for example,
        `OPTION_ARG_OPTIONAL | OPTION_ALIAS`).

        Some of the available options are:

        -   []{#index-OPTION_005fARG_005fOPTIONAL-option-flag}
        -   `OPTION_ARG_OPTIONAL`: The argument to the current option is
            optional. []{#index-OPTION_005fALIAS-option-flag}
        -   `OPTION_ALIAS`: The current option is an alias for the
            previous option. []{#index-OPTION_005fHIDDEN-option-flag}
        -   `OPTION_HIDDEN`: Don't show the current option in `--help`
            output.

        []{#index-DOC-field}

    6.  `DOC`: A documentation string for the current option; will be
        shown in `--help` output.

    []{#index-PARSER-field}

3.  `PARSER`: A pointer to a function to be called by `argp` for each
    option parsed. It should return one of the following values:

    -   []{#index-0-return-code}
    -   `0`: Success. []{#index-ARGP_005fERR_005fUNKNOWN-return-code}
    -   `ARGP_ERR_UNKNOWN`: The given key was not recognized.
        []{#index-errno-system-variable-6}
    -   An `errno` value indicating some other error. (See section
        [Usual file name errors](#Usual-file-name-errors).)

    The parser function takes the following arguments:

    1.  []{#index-KEY-parser-function-argument}
    2.  `KEY`: An integer specifying which argument this is, taken from
        the `KEY` field in each `argp_option` structure, or else a key
        with a special meaning, such as one of the following:
        -   []{#index-ARGP_005fKEY_005fARG-key}
        -   `ARGP_KEY_ARG`: The current command-line argument is not an
            option. []{#index-ARGP_005fKEY_005fEND-key}
        -   `ARGP_KEY_END`: All command-line arguments have been parsed.

        []{#index-ARG-parser-function-argument}
    3.  `ARG`: The string value of the current command-line argument, or
        NULL if it has none. []{#index-STATE-parser-function-argument}
    4.  `STATE`: A pointer to an `argp_state` structure, containing
        information about the parsing state, such as the following
        fields:
        1.  []{#index-input-field}
        2.  `input`: The same as the last parameter to `argp_parse`. We
            use this in the main code example below to pass information
            between the `main` and `parse_opt` functions.
            []{#index-arg_005fnum-field}
        3.  `arg_num`: The number of the current non-option argument
            being parsed.

    []{#index-ARGS_005fDOC-field}

4.  `ARGS_DOC`: If non-zero, a string describing how the non-option
    arguments should look. It is only used to print the 'Usage:'
    message. If it contains newlines, the strings separated by them are
    considered alternative usage patterns, and printed on separate lines
    (subsequent lines are preceded by 'or:' rather than 'Usage:'.
    []{#index-DOC-field-1}
5.  `DOC`: If non-zero, a descriptive string about this program. It will
    normally be printed before the options in a help message, but if you
    include a vertical tab character ('\\v'), the part after the
    vertical tab will be printed following the options in the output to
    the `--help` option. Conventionally, the part before the options is
    just a short string that says what the program does, while the part
    afterwards is longer and describes the program in more detail.

[]{#index-argp_005fusage-function}

There are also some utility functions associated with `argp`, such as
`argp_usage`, which prints out the standard usage message. We use this
function in the `parse_opt` function in the following example. See
[(libc)Argp Helper Functions](libc.html#Argp-Helper-Functions) section
'Functions For Use in Argp Parsers' in The GNU C Library Reference
Manual, for more of these utility functions.

[]{#index-argp-function-2} []{#index-argp_002c-example-of}

------------------------------------------------------------------------

[]{#argp-example}

  ----------------------------------------------------------------- ------------------------------------------------------------------ --- ----------------------------------------------------------------------------------------- ------------------------------------------------------------- ------------------------------------------------ --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#argp-description "Previous section in reading order")\]   \[[\>](#Environment-variables "Next section in reading order")\]       \[[\<\<](#Putting-a-program-together "Beginning of this chapter or previous chapter")\]   \[[Up](#Processing-command_002dline-options "Up section")\]   \[[\>\>](#Advanced-operators "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ----------------------------------------------------------------- ------------------------------------------------------------------ --- ----------------------------------------------------------------------------------------- ------------------------------------------------------------- ------------------------------------------------ --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#argp-example-1}

### 17.2.2 `argp` example {#argp-example .subsection}

Here is a code example that uses `argp` to parse command-line options.
Remember, to compile this example, copy it to a file called something
like '`argex.c`', then compile it with the command
`gcc -o argex argex.c` and run the resulting binary with the command
`./argex`.

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | #include <stdio.h>                |
|                                   | #include <argp.h>                 |
|                                   |                                   |
|                                   | const char *argp_program_version  |
|                                   | =                                 |
|                                   | "argex 1.0";                      |
|                                   |                                   |
|                                   | const char *argp_program_bug_addr |
|                                   | ess =                             |
|                                   | "<bug-gnu-utils@gnu.org>";        |
|                                   | ```                               |
|                                   |                                   |
|                                   | ``` {.smallexample}               |
|                                   | ```                               |
|                                   |                                   |
|                                   | ``` {.smallexample}               |
|                                   | /* This structure is used by main |
|                                   |  to communicate with parse_opt. * |
|                                   | /                                 |
|                                   | struct arguments                  |
|                                   | {                                 |
|                                   |   char *args[2];            /* AR |
|                                   | G1 and ARG2 */                    |
|                                   |   int verbose;              /* Th |
|                                   | e -v flag */                      |
|                                   |   char *outfile;            /* Ar |
|                                   | gument for -o */                  |
|                                   |   char *string1, *string2;  /* Ar |
|                                   | guments for -a and -b */          |
|                                   | };                                |
|                                   | ```                               |
|                                   |                                   |
|                                   | ``` {.smallexample}               |
|                                   | ```                               |
|                                   |                                   |
|                                   | ``` {.smallexample}               |
|                                   | /*                                |
|                                   |    OPTIONS.  Field 1 in ARGP.     |
|                                   |    Order of fields: {NAME, KEY, A |
|                                   | RG, FLAGS, DOC}.                  |
|                                   | */                                |
|                                   | static struct argp_option options |
|                                   | [] =                              |
|                                   | {                                 |
|                                   |   {"verbose", 'v', 0, 0, "Produce |
|                                   |  verbose output"},                |
|                                   |   {"alpha",   'a', "STRING1", 0,  |
|                                   |    "Do something with STRING1 rel |
|                                   | ated to the letter A"},           |
|                                   |   {"bravo",   'b', "STRING2", 0,  |
|                                   |    "Do something with STRING2 rel |
|                                   | ated to the letter B"},           |
|                                   |   {"output",  'o', "OUTFILE", 0,  |
|                                   |    "Output to OUTFILE instead of  |
|                                   | to standard output"},             |
|                                   |   {0}                             |
|                                   | };                                |
|                                   | ```                               |
|                                   |                                   |
|                                   | ``` {.smallexample}               |
|                                   | ```                               |
|                                   |                                   |
|                                   | ``` {.smallexample}               |
|                                   | /*                                |
|                                   |    PARSER. Field 2 in ARGP.       |
|                                   |    Order of parameters: KEY, ARG, |
|                                   |  STATE.                           |
|                                   | */                                |
|                                   | static error_t                    |
|                                   | parse_opt (int key, char *arg, st |
|                                   | ruct argp_state *state)           |
|                                   | {                                 |
|                                   |   struct arguments *arguments = s |
|                                   | tate->input;                      |
|                                   | ```                               |
|                                   |                                   |
|                                   | ``` {.smallexample}               |
|                                   | ```                               |
|                                   |                                   |
|                                   | ``` {.smallexample}               |
|                                   |   switch (key)                    |
|                                   |     {                             |
|                                   |     case 'v':                     |
|                                   |       arguments->verbose = 1;     |
|                                   |       break;                      |
|                                   |     case 'a':                     |
|                                   |       arguments->string1 = arg;   |
|                                   |       break;                      |
|                                   |     case 'b':                     |
|                                   |       arguments->string2 = arg;   |
|                                   |       break;                      |
|                                   |     case 'o':                     |
|                                   |       arguments->outfile = arg;   |
|                                   |       break;                      |
|                                   | ```                               |
|                                   |                                   |
|                                   | ``` {.smallexample}               |
|                                   |     case ARGP_KEY_ARG:            |
|                                   |       if (state->arg_num >= 2)    |
|                                   |     {                             |
|                                   |       argp_usage(state);          |
|                                   |     }                             |
|                                   |       arguments->args[state->arg_ |
|                                   | num] = arg;                       |
|                                   |       break;                      |
|                                   |     case ARGP_KEY_END:            |
|                                   |       if (state->arg_num < 2)     |
|                                   |     {                             |
|                                   |       argp_usage (state);         |
|                                   |     }                             |
|                                   |       break;                      |
|                                   |     default:                      |
|                                   |       return ARGP_ERR_UNKNOWN;    |
|                                   |     }                             |
|                                   |   return 0;                       |
|                                   | }                                 |
|                                   | ```                               |
|                                   |                                   |
|                                   | ``` {.smallexample}               |
|                                   | ```                               |
|                                   |                                   |
|                                   | ``` {.smallexample}               |
|                                   | /*                                |
|                                   |    ARGS_DOC. Field 3 in ARGP.     |
|                                   |    A description of the non-optio |
|                                   | n command-line arguments          |
|                                   |      that we accept.              |
|                                   | */                                |
|                                   | static char args_doc[] = "ARG1 AR |
|                                   | G2";                              |
|                                   | ```                               |
|                                   |                                   |
|                                   | ``` {.smallexample}               |
|                                   | ```                               |
|                                   |                                   |
|                                   | ``` {.smallexample}               |
|                                   | /*                                |
|                                   |   DOC.  Field 4 in ARGP.          |
|                                   |   Program documentation.          |
|                                   | */                                |
|                                   | static char doc[] =               |
|                                   | "argex -- A program to demonstrat |
|                                   | e how to code command-line option |
|                                   | s                                 |
|                                   | and arguments.\vFrom the GNU C Tu |
|                                   | torial.";                         |
|                                   | ```                               |
|                                   |                                   |
|                                   | ``` {.smallexample}               |
|                                   | ```                               |
|                                   |                                   |
|                                   | ``` {.smallexample}               |
|                                   | /*                                |
|                                   |    The ARGP structure itself.     |
|                                   | */                                |
|                                   | static struct argp argp = {option |
|                                   | s, parse_opt, args_doc, doc};     |
|                                   | ```                               |
|                                   |                                   |
|                                   | ``` {.smallexample}               |
|                                   | ```                               |
|                                   |                                   |
|                                   | ``` {.smallexample}               |
|                                   | /*                                |
|                                   |    The main function.             |
|                                   |    Notice how now the only functi |
|                                   | on call needed to process         |
|                                   |    all command-line options and a |
|                                   | rguments nicely                   |
|                                   |    is argp_parse.                 |
|                                   | */                                |
|                                   | int main (int argc, char **argv)  |
|                                   | {                                 |
|                                   |   struct arguments arguments;     |
|                                   |   FILE *outstream;                |
|                                   | ```                               |
|                                   |                                   |
|                                   | ``` {.smallexample}               |
|                                   | ```                               |
|                                   |                                   |
|                                   | ``` {.smallexample}               |
|                                   |   char waters[] =                 |
|                                   | "a place to stay                  |
|                                   | enough to eat                     |
|                                   | somewhere old heroes shuffle safe |
|                                   | ly down the street                |
|                                   | where you can speak out loud      |
|                                   | about your doubts and fears       |
|                                   | and what's more no-one ever disap |
|                                   | pears                             |
|                                   | you never hear their standard iss |
|                                   | ue kicking in your door           |
|                                   | you can relax on both sides of th |
|                                   | e tracks                          |
|                                   | and maniacs don't blow holes in b |
|                                   | andsmen by remote control         |
|                                   | and everyone has recourse to the  |
|                                   | law                               |
|                                   | and no-one kills the children any |
|                                   | more                              |
|                                   | and no-one kills the children any |
|                                   | more                              |
|                                   |   --\"the gunners dream\", Roger  |
|                                   | Waters, 1983\n";                  |
|                                   | ```                               |
|                                   |                                   |
|                                   | ``` {.smallexample}               |
|                                   | ```                               |
|                                   |                                   |
|                                   | ``` {.smallexample}               |
|                                   |   /* Set argument defaults */     |
|                                   |   arguments.outfile = NULL;       |
|                                   |   arguments.string1 = "";         |
|                                   |   arguments.string2 = "";         |
|                                   |   arguments.verbose = 0;          |
|                                   | ```                               |
|                                   |                                   |
|                                   | ``` {.smallexample}               |
|                                   | ```                               |
|                                   |                                   |
|                                   | ``` {.smallexample}               |
|                                   |   /* Where the magic happens */   |
|                                   |   argp_parse (&argp, argc, argv,  |
|                                   | 0, 0, &arguments);                |
|                                   |                                   |
|                                   |   /* Where do we send output? */  |
|                                   |   if (arguments.outfile)          |
|                                   |     outstream = fopen (arguments. |
|                                   | outfile, "w");                    |
|                                   |   else                            |
|                                   |     outstream = stdout;           |
|                                   | ```                               |
|                                   |                                   |
|                                   | ``` {.smallexample}               |
|                                   | ```                               |
|                                   |                                   |
|                                   | ``` {.smallexample}               |
|                                   |   /* Print argument values */     |
|                                   |   fprintf (outstream, "alpha = %s |
|                                   | \nbravo = %s\n\n",                |
|                                   |        arguments.string1, argumen |
|                                   | ts.string2);                      |
|                                   |   fprintf (outstream, "ARG1 = %s\ |
|                                   | nARG2 = %s\n\n",                  |
|                                   |        arguments.args[0],         |
|                                   |        arguments.args[1]);        |
|                                   |                                   |
|                                   |   /* If in verbose mode, print so |
|                                   | ng stanza */                      |
|                                   |   if (arguments.verbose)          |
|                                   |     fprintf (outstream, waters);  |
|                                   |                                   |
|                                   |   return 0;                       |
|                                   | }                                 |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

Compile the code, then experiment! For example, here is the program
output if you simply type `argex`:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | Usage: argex [OPTION...] ARG1 ARG |
|                                   | 2                                 |
|                                   | Try `argex --help' or `argex --us |
|                                   | age' for more information.        |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

Here is the output from `argex --usage`:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | Usage: argex [-v?V] [-a STRING1]  |
|                                   | [-b STRING2] [-o OUTFILE] [--alph |
|                                   | a=STRING1]                        |
|                                   |             [--bravo=STRING2] [-- |
|                                   | output=OUTFILE] [--verbose] [--he |
|                                   | lp] [--usage]                     |
|                                   |             [--version] ARG1 ARG2 |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

Here is the output from `argex --help`:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | Usage: argex [OPTION...] ARG1 ARG |
|                                   | 2                                 |
|                                   | argex -- A program to demonstrate |
|                                   |  how to code command-line options |
|                                   | and arguments.                    |
|                                   |                                   |
|                                   |   -a, --alpha=STRING1        Do s |
|                                   | omething with STRING1 related to  |
|                                   | the letter A                      |
|                                   |   -b, --bravo=STRING2        Do s |
|                                   | omething with STRING2 related to  |
|                                   | the letter B                      |
|                                   |   -o, --output=OUTFILE       Outp |
|                                   | ut to OUTFILE instead of to stand |
|                                   | ard output                        |
|                                   |   -v, --verbose              Prod |
|                                   | uce verbose output                |
|                                   |   -?, --help                 Give |
|                                   |  this help list                   |
|                                   |       --usage                Give |
|                                   |  a short usage message            |
|                                   |   -V, --version              Prin |
|                                   | t program version                 |
|                                   |                                   |
|                                   | Mandatory or optional arguments t |
|                                   | o long options are also mandatory |
|                                   |  or optional                      |
|                                   | for any corresponding short optio |
|                                   | ns.                               |
|                                   |                                   |
|                                   | From the GNU C Tutorial.          |
|                                   |                                   |
|                                   | Report bugs to <bug-gnu-utils@gnu |
|                                   | .org>.                            |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

Here is the output from `argex Foo Bar`:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | alpha =                           |
|                                   | bravo =                           |
|                                   |                                   |
|                                   | ARG1 = Foo                        |
|                                   | ARG2 = Bar                        |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

And finally, here is the output from
`argex --verbose -a 123 --bravo=456 Foo Bar`:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | alpha = 123                       |
|                                   | bravo = 456                       |
|                                   |                                   |
|                                   | ARG1 = Foo                        |
|                                   | ARG2 = Bar                        |
|                                   |                                   |
|                                   | a place to stay                   |
|                                   | enough to eat                     |
|                                   | somewhere old heroes shuffle safe |
|                                   | ly down the street                |
|                                   | where you can speak out loud      |
|                                   | about your doubts and fears       |
|                                   | and what's more no-one ever disap |
|                                   | pears                             |
|                                   | you never hear their standard iss |
|                                   | ue kicking in your door           |
|                                   | you can relax on both sides of th |
|                                   | e tracks                          |
|                                   | and maniacs don't blow holes in b |
|                                   | andsmen by remote control         |
|                                   | and everyone has recourse to the  |
|                                   | law                               |
|                                   | and no-one kills the children any |
|                                   | more                              |
|                                   | and no-one kills the children any |
|                                   | more                              |
|                                   |   --"the gunners dream", Roger Wa |
|                                   | ters, 1983                        |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

You can of course also send the output to a text file with the '-o' or
'\--output' option.

------------------------------------------------------------------------

[]{#Environment-variables}

  ------------------------------------------------------------- --------------------------------------------------------------------- --- ----------------------------------------------------------------------------------------- ---------------------------------------------------- ------------------------------------------------ --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#argp-example "Previous section in reading order")\]   \[[\>](#Compiling-multiple-files "Next section in reading order")\]       \[[\<\<](#Putting-a-program-together "Beginning of this chapter or previous chapter")\]   \[[Up](#Putting-a-program-together "Up section")\]   \[[\>\>](#Advanced-operators "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ------------------------------------------------------------- --------------------------------------------------------------------- --- ----------------------------------------------------------------------------------------- ---------------------------------------------------- ------------------------------------------------ --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Environment-variables-1}

17.3 Environment variables {#environment-variables .section}
--------------------------

[]{#index-Environment-variables} []{#index-Variables_002c-environment}

Sometimes it is useful to communicate with a program in a semi-permanent
way, so that you do not need to specify a command-line option every time
you type the command to execute the program. One way to do this is to
generate a configuration file, in which you can store data that will be
used by the program every time it is run. This approach is typically
useful if you have a large amount of data that you want to pass to a
program every time it runs, or if you want the program itself to be able
to change the data.

However, *environment variables* provide a more lightweight approach.
Environment variables, sometimes called *shell variables*, are usually
set with the `export` command in the shell. (This section assumes you
are using the GNU Bash shell.) Standard environment variables are used
for information about your home directory, terminal type, and so on; you
can define additional variables for other purposes. The set of all
environment variables that have values is collectively known as the
*environment*.

Names of environment variables are case-sensitive, and it is good form
to use all upper-case letters when defining a new variable; certainly
this is the case for all system-defined environment variables.

The value of an environment variable can be any string that does not
contain a null character (since the null character is used to terminate
the string value).

[]{#index-envp-array}

Environment variables are stored in a special array that can be read by
your `main` function. Here is the skeleton for a `main` function that
can read environment variables; notice we have added a third parameter
to `main`, called `envp`, which comes after `argc` and `argv`.

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | #include <stdio.h>                |
|                                   |                                   |
|                                   | /* To shorten example, not using  |
|                                   | argp */                           |
|                                   | int main (int argc, char *argv[], |
|                                   |  char *envp[])                    |
|                                   | {                                 |
|                                   |                                   |
|                                   |   return 0;                       |
|                                   | }                                 |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

Notice that `envp` is an array of strings, just as `argv` is. It
consists of a list of the environment variables of your shell, in the
following format:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | NAME=value                        |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

[]{#index-getenv-function} []{#index-argv-array} []{#index-envp-array-1}

Just as you can manually process command-line options from `argv`, so
can you manually process environment variables from `envp`. However, the
simplest way to access the value of an environment variable is with the
`getenv` function, defined in the system header '`stdlib.h`'. It takes a
single argument, a string containing the name of the variable whose
value you wish to discover. It returns that value, or a null pointer if
the variable is not defined.

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | #include <stdio.h>                |
|                                   | #include <stdlib.h>               |
|                                   |                                   |
|                                   | /* To shorten example, not using  |
|                                   | argp */                           |
|                                   | int main (int argc, char *argv[], |
|                                   |  char *envp[])                    |
|                                   | {                                 |
|                                   |   char *home, *host;              |
|                                   |                                   |
|                                   |   home = getenv("HOME");          |
|                                   |   host = getenv("HOSTNAME");      |
|                                   |                                   |
|                                   |   printf ("Your home directory is |
|                                   |  %s on %s.\n", home, host);       |
|                                   |                                   |
|                                   |   return 0;                       |
|                                   | }                                 |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

When you run this code, it will print out a line like the following one.

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | Your home directory is /home/rwhe |
|                                   |  on linnaeus.                     |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

**Note:** Do not modify strings returned from `getenv`; they are
pointers to data that belongs to the system. If you want to process a
value returned from `getenv`, copy it to another string first with
`strcpy`. (See section [Strings](#Strings).) If you want to change an
environment variable from within your program (not usually advisable),
use the `putenv`, `setenv`, and `unsetenv` functions. See
[(libc)Environment Access](libc.html#Environment-Access) section
'Environment Access' in The GNU C Library Reference Manual, for more
information on these functions.

------------------------------------------------------------------------

[]{#Compiling-multiple-files}

  ---------------------------------------------------------------------- --------------------------------------------------------------- --- ----------------------------------------------------------------------------------------- ---------------------------------------------------- ------------------------------------------------ --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Environment-variables "Previous section in reading order")\]   \[[\>](#Writing-a-makefile "Next section in reading order")\]       \[[\<\<](#Putting-a-program-together "Beginning of this chapter or previous chapter")\]   \[[Up](#Putting-a-program-together "Up section")\]   \[[\>\>](#Advanced-operators "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ---------------------------------------------------------------------- --------------------------------------------------------------- --- ----------------------------------------------------------------------------------------- ---------------------------------------------------- ------------------------------------------------ --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Compiling-multiple-files-1}

17.4 Compiling multiple files {#compiling-multiple-files .section}
-----------------------------

[]{#index-Compiling-multiple-files}
[]{#index-Multiple-files_002c-compiling}

It is usually very simple to compile a program that has been divided
across multiple source files. Instead of typing

[]{#index-gcc-2}

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | gcc -o executable sourcefile.c    |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

you would type

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | gcc -o executable sourcefile_1.c  |
|                                   | sourcefile_2.c … sourcefile_n.c   |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

For example, if you were building a simple database program called
'`mydb`', the command line might look something like this:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | gcc -o mydb main.c keyboard_io.c  |
|                                   | db_access.c sorting.c             |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

Of course, if (say) '`db_access.c`' were lengthy, it might take a long
time to compile your program every time you executed this command, even
if you only made a small change in one of the other files. To avoid
this, you might want to compile each of the source files into its own
object file, then link them together to make your program. If you did,
each time you made a small change in one file, you need only recompile
that single file and then link the object files together again,
potentially a great savings in time and patience. Here is how to
generate a permanent object file for '`db_access.c`'.

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | gcc -c db_access.c                |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

This would generate a permanent object code file called '`db_access.o`',
indicated by the suffix '.o'. You would perform this step when needed
for each of the source code files, then link them together with the
following command line:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | gcc -o mydb main.o keyboard_io.o  |
|                                   | db_access.o sorting.o             |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

You might even put the various commands into a shell file, so that you
wouldn't need to type them repeatedly. For example, you could put the
last command line into a shell file called '`build`', so that all you
would need to do to build your executable from object code files is type
the following line.

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | ./build                           |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

For programs on a very small scale, this approach works quite well. If
your project grows even slightly complex, however, you will have a hard
time keeping track of which object files are "fresh" and which need to
be recreated because the corresponding source files have been changed
since their last compilation. That's where the GNU utility `make` comes
in. (See section [Writing a makefile](#Writing-a-makefile).)

------------------------------------------------------------------------

[]{#Writing-a-makefile}

  ------------------------------------------------------------------------- -------------------------------------------------------------- --- ----------------------------------------------------------------------------------------- ---------------------------------------------------- ------------------------------------------------ --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Compiling-multiple-files "Previous section in reading order")\]   \[[\>](#Rule-Introduction "Next section in reading order")\]       \[[\<\<](#Putting-a-program-together "Beginning of this chapter or previous chapter")\]   \[[Up](#Putting-a-program-together "Up section")\]   \[[\>\>](#Advanced-operators "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ------------------------------------------------------------------------- -------------------------------------------------------------- --- ----------------------------------------------------------------------------------------- ---------------------------------------------------- ------------------------------------------------ --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Writing-a-makefile-1}

17.5 Writing a makefile {#writing-a-makefile .section}
-----------------------

[]{#index-Writing-makefiles} []{#index-Makefiles_002c-writing}
[]{#index-make-program}

The GNU `make` program automatically determines which pieces of a large
program need to be recompiled, and issues the commands to compile them.
You need a file called a *makefile* to tell `make` what to do. Most
often, the makefile tells `make` how to compile and link a program.
[]{#index-makefile}

In this section, we will discuss a simple makefile that describes how to
compile and link a text editor which consists of eight C source files
and three header files. The makefile can also tell `make` how to run
miscellaneous commands when explicitly asked (for example, to remove
certain files as a clean-up operation).

Although the examples in this section show C programs, you can use
`make` with any programming language whose compiler can be run with a
shell command. Indeed, `make` is not limited to programs. You can use it
to describe any task where some files must be updated automatically from
others whenever the others change.

Your makefile describes the relationships among files in your program
and provides commands for updating each file. In a program, typically,
the executable file is updated from object files, which are in turn made
by compiling source files.

Once a suitable makefile exists, each time you change some source files,
this simple shell command:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | make                              |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

suffices to perform all necessary recompilations. The `make` program
uses the makefile database and the last-modification times of the files
to decide which of the files need to be updated. For each of those
files, it issues the commands recorded in the database.

You can provide command line arguments to `make` to control which files
should be recompiled, or how.

When `make` recompiles the editor, each changed C source file must be
recompiled. If a header file has changed, each C source file that
includes the header file must be recompiled to be safe. Each compilation
produces an object file corresponding to the source file. Finally, if
any source file has been recompiled, all the object files, whether newly
made or saved from previous compilations, must be linked together to
produce the new executable editor. []{#index-recompilation}
[]{#index-editor}

  ------------------------------------------------------------------------------ ---- --
  [17.5.1 What a Rule Looks Like](#Rule-Introduction)                                 
  [17.5.2 A simple makefile](#A-simple-makefile)                                      
  [17.5.3 make in action](#make-in-action)                                            
  [17.5.4 Variables simplify makefiles](#Variables-simplify-makefiles)                
  [17.5.5 Letting make deduce commands](#Letting-make-deduce-commands)                
  [17.5.6 Combining rules by prerequisite](#Combining-rules-by-prerequisite)          
  [17.5.7 Rules for cleaning the directory](#Rules-for-cleaning-the-directory)        
  ------------------------------------------------------------------------------ ---- --

------------------------------------------------------------------------

[]{#Rule-Introduction}

  ------------------------------------------------------------------- -------------------------------------------------------------- --- ----------------------------------------------------------------------------------------- -------------------------------------------- ------------------------------------------------ --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Writing-a-makefile "Previous section in reading order")\]   \[[\>](#A-simple-makefile "Next section in reading order")\]       \[[\<\<](#Putting-a-program-together "Beginning of this chapter or previous chapter")\]   \[[Up](#Writing-a-makefile "Up section")\]   \[[\>\>](#Advanced-operators "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ------------------------------------------------------------------- -------------------------------------------------------------- --- ----------------------------------------------------------------------------------------- -------------------------------------------- ------------------------------------------------ --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#What-a-Rule-Looks-Like}

### 17.5.1 What a Rule Looks Like {#what-a-rule-looks-like .subsection}

[]{#index-Makefile-rule_002c-introduction-to}
[]{#index-Makefile-rule-parts} []{#index-Parts-of-makefile-rules}

A simple makefile consists of "rules" with the following shape:

[]{#index-Makefile-targets_002c-introduction-to}
[]{#index-Makefile-prerequisites_002c-introduction-to}
[]{#index-Makefile-commands_002c-introduction-to}

+-----------------------------------+-----------------------------------+
|                                   | ``` {.example}                    |
|                                   | target … : prerequisites …        |
|                                   |         command                   |
|                                   |         …                         |
|                                   |         …                         |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

A *target* is usually the name of a file that is generated by a program;
examples of targets are executable or object files. A target can also be
the name of an action to carry out, such as 'clean'.

A *prerequisite* is a file that is used as input to create the target. A
target often depends on several files.

[]{#index-Tab-characters-in-makefile-rules}
[]{#index-Makefile-rules_002c-tab-characters-in}

A *command* is an action that `make` carries out. A rule may have more
than one command, each on its own line. **Please note:** you need to put
a tab character at the beginning of every command line! This is a common
mistake that even experienced makefile writers can make.

Usually a command is defined by a rule with prerequisites and serves to
create a target file if any of the prerequisites change. However, the
rule that specifies commands for the target need not have prerequisites.
For example, the rule containing the delete command associated with the
target 'clean' does not have prerequisites.

A *rule*, then, explains how and when to remake certain files which are
the targets of the particular rule. `make` carries out the commands on
the prerequisites to create or update the target. A rule can also
explain how and when to carry out an action.

A makefile may contain other text besides rules, but a simple makefile
need only contain rules. Rules may look somewhat more complicated than
shown in this template, but all fit the pattern more or less.

------------------------------------------------------------------------

[]{#A-simple-makefile}

  ------------------------------------------------------------------ ----------------------------------------------------------- --- ----------------------------------------------------------------------------------------- -------------------------------------------- ------------------------------------------------ --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Rule-Introduction "Previous section in reading order")\]   \[[\>](#make-in-action "Next section in reading order")\]       \[[\<\<](#Putting-a-program-together "Beginning of this chapter or previous chapter")\]   \[[Up](#Writing-a-makefile "Up section")\]   \[[\>\>](#Advanced-operators "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ------------------------------------------------------------------ ----------------------------------------------------------- --- ----------------------------------------------------------------------------------------- -------------------------------------------- ------------------------------------------------ --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#A-simple-makefile-1}

### 17.5.2 A simple makefile {#a-simple-makefile .subsection}

[]{#index-Simple-makefile} []{#index-Makefile_002c-simple}

Here is a straightforward makefile that describes the way an executable
file called '`edit`' depends on eight object files which, in turn,
depend on eight C source files and three header files.

In this example, all the C files include '`defs.h`', but only files that
define editing commands include '`command.h`', and only low-level files
that change the editor buffer include '`buffer.h`'.

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | edit : main.o kbd.o command.o dis |
|                                   | play.o \                          |
|                                   |        insert.o search.o files.o  |
|                                   | utils.o                           |
|                                   |         cc -o edit main.o kbd.o c |
|                                   | ommand.o display.o \              |
|                                   |                    insert.o searc |
|                                   | h.o files.o utils.o               |
|                                   |                                   |
|                                   | main.o : main.c defs.h            |
|                                   |         cc -c main.c              |
|                                   | kbd.o : kbd.c defs.h command.h    |
|                                   |         cc -c kbd.c               |
|                                   | command.o : command.c defs.h comm |
|                                   | and.h                             |
|                                   |         cc -c command.c           |
|                                   | display.o : display.c defs.h buff |
|                                   | er.h                              |
|                                   |         cc -c display.c           |
|                                   | insert.o : insert.c defs.h buffer |
|                                   | .h                                |
|                                   |         cc -c insert.c            |
|                                   | search.o : search.c defs.h buffer |
|                                   | .h                                |
|                                   |         cc -c search.c            |
|                                   | files.o : files.c defs.h buffer.h |
|                                   |  command.h                        |
|                                   |         cc -c files.c             |
|                                   | utils.o : utils.c defs.h          |
|                                   |         cc -c utils.c             |
|                                   | clean :                           |
|                                   |         rm edit main.o kbd.o comm |
|                                   | and.o display.o \                 |
|                                   |            insert.o search.o file |
|                                   | s.o utils.o                       |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

We split each long line into two lines using a backslash; this is like
using one long line, but easier to read.

[]{#index-Continuation-lines-in-makefiles}
[]{#index-_005c-_0028backslash_0029_002c-for-makefile-continuation-lines}
[]{#index-backslash-_0028_005c_0029_002c-for-makefile-continuation-lines}
[]{#index-Quoting-newline-character-in-makefile}
[]{#index-Newline-character_002c-quoting-in-makefile}

To use this makefile to create the executable file called '`edit`',
type:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | make                              |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

To use this makefile to delete the executable file and all the object
files from the directory, type:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | make clean                        |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

In the example makefile, the targets include the executable file
'`edit`', and the object files '`main.o`' and '`kbd.o`'. The
prerequisites are files such as '`main.c`' and '`defs.h`'. In fact, each
'.o' file is both a target and a prerequisite. Commands include
`cc -c main.c` and `cc -c kbd.c`.

When a target is a file, it needs to be recompiled or relinked if any of
its prerequisites change. In addition, any prerequisites that are
themselves automatically generated should be updated first. In this
example, '`edit`' depends on each of the eight object files; the object
file '`main.o`' depends on the source file '`main.c`' and on the header
file '`defs.h`'.

A shell command follows each line that contains a target and
prerequisites. These shell commands tell `make` how to update the target
file. A tab character must come at the beginning of every command line
to distinguish command lines from other lines in the makefile. (Bear in
mind that `make` does not know anything about how the commands work. It
is up to you to supply commands that will update the target file
properly.) []{#index-shell-command}

[]{#index-clean-makefile-target} []{#index-rm-program}

The target `clean` is not a file, but merely the name of an action.
Since this action is not carried out as part of the other targets,
`clean` is not a prerequisite of any other rule. Consequently, `make`
never does anything with it unless you explicitly type `make clean`. Not
only is this rule *not* a prerequisite, it does not have any
prerequisites itself, so the only purpose of the rule is to run the
specified commands. Targets like `clean` that do not refer to files but
are just actions are called *phony targets*.

------------------------------------------------------------------------

[]{#make-in-action}

  ------------------------------------------------------------------ ------------------------------------------------------------------------- --- ----------------------------------------------------------------------------------------- -------------------------------------------- ------------------------------------------------ --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#A-simple-makefile "Previous section in reading order")\]   \[[\>](#Variables-simplify-makefiles "Next section in reading order")\]       \[[\<\<](#Putting-a-program-together "Beginning of this chapter or previous chapter")\]   \[[Up](#Writing-a-makefile "Up section")\]   \[[\>\>](#Advanced-operators "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ------------------------------------------------------------------ ------------------------------------------------------------------------- --- ----------------------------------------------------------------------------------------- -------------------------------------------- ------------------------------------------------ --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#make-in-action-1}

### 17.5.3 make in action {#make-in-action .subsection}

[]{#index-processing-a-makefile} []{#index-makefile_002c-processing}
[]{#index-default-makefile-goal}
[]{#index-goal_002c-makefile_002c-default} []{#index-goal}

By default, `make` starts with the first target whose name does not
start with '.'. This is called the *default goal*. (*Goals* are the
targets that `make` tries to update.)

In the simple example of the previous section, the default goal is to
update the executable program '`edit`'; therefore, we put that rule
first.

Thus, when you give the command:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | make                              |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

`make` reads the makefile in the current directory and begins by
processing the first rule. In the example, this rule is for relinking
'`edit`'; but before `make` can fully process this rule, it must process
the rules for the files that '`edit`' depends on, which in this case are
the object files. Each of these files is processed according to its own
rule. These rules say to update each '.o' file by compiling its source
file. The recompilation must be done if the source file, or any of the
header files named as prerequisites, is more recent than the object
file, or if the object file does not exist.

The other rules are processed because their targets appear as
prerequisites of the goal. If some other rule is not depended on by the
goal (or anything that the goal depends on, and so forth), then that
rule is not processed, unless you tell `make` to do so (with a command
such as `make clean`.

Before recompiling an object file, `make` considers updating its
prerequisites (the source file and header files). This makefile does not
specify anything to be done for them---the '.c' and '.h' files are not
the targets of any rules---so `make` does nothing for these files. But
`make` can update automatically generated C programs, such as those made
by Bison or Yacc, by defining the '.c' and '.h' files as targets and
specifying how to create them with Bison, Yacc, or whatever other
program generated them.

After recompiling the appropriate object files, `make` decides whether
to link '`edit`'. This must be done if the file '`edit`' does not exist,
or if any of the object files are newer than it is. If an object file
was just recompiled, it is now newer than '`edit`', so '`edit`' is
relinked. []{#index-relinking}

Thus, if we change the file '`insert.c`' and run `make`, then `make`
will recompile that file, update '`insert.o`', and then link '`edit`'.
If we change the file '`command.h`' and run `make`, `make` will
recompile the object files '`kbd.o`', '`command.o`' and '`files.o`', and
then link the file '`edit`'.

------------------------------------------------------------------------

[]{#Variables-simplify-makefiles}

  --------------------------------------------------------------- ------------------------------------------------------------------------- --- ----------------------------------------------------------------------------------------- -------------------------------------------- ------------------------------------------------ --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#make-in-action "Previous section in reading order")\]   \[[\>](#Letting-make-deduce-commands "Next section in reading order")\]       \[[\<\<](#Putting-a-program-together "Beginning of this chapter or previous chapter")\]   \[[Up](#Writing-a-makefile "Up section")\]   \[[\>\>](#Advanced-operators "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  --------------------------------------------------------------- ------------------------------------------------------------------------- --- ----------------------------------------------------------------------------------------- -------------------------------------------- ------------------------------------------------ --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Variables-simplify-makefiles-1}

### 17.5.4 Variables simplify makefiles {#variables-simplify-makefiles .subsection}

[]{#index-Variables_002c-simplifying-makefiles-with}
[]{#index-Simplifying-makefiles-with-variables}

In our example, we had to list all the object files twice in the rule
for '`edit`' (repeated here):

+-----------------------------------+-----------------------------------+
|                                   | ``` {.example}                    |
|                                   | edit : main.o kbd.o command.o dis |
|                                   | play.o \                          |
|                                   |               insert.o search.o f |
|                                   | iles.o utils.o                    |
|                                   |         cc -o edit main.o kbd.o c |
|                                   | ommand.o display.o \              |
|                                   |                    insert.o searc |
|                                   | h.o files.o utils.o               |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

[]{#index-objects}

Such duplication is error-prone; if a new object file is added to the
system, we might add it to one list and forget the other. We can
eliminate the risk and simplify the makefile by using a variable.
*Variables* in `make` enable a text string to be defined once and
substituted in multiple places later. They are similar to C macros. (See
section [Macros](#Macros).)

[]{#index-OBJECTS-makefile-variable} []{#index-objs-makefile-variable}
[]{#index-OBJS-makefile-variable} []{#index-obj-makefile-variable}
[]{#index-OBJ-makefile-variable}

It is standard practice for every makefile to have a variable named
`objects`, `OBJECTS`, `objs`, `OBJS`, `obj`, or `OBJ` that is a list of
all object file names. We would define such a variable `objects` with a
line like this in the makefile:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | objects = main.o kbd.o command.o  |
|                                   | display.o \                       |
|                                   |           insert.o search.o files |
|                                   | .o utils.o                        |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

Then, in every place we want to put a list of the object file names, we
can substitute the variable's value by writing `$(objects)`

Here is how the complete simple makefile looks when you use a variable
for the object files:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | objects = main.o kbd.o command.o  |
|                                   | display.o \                       |
|                                   |           insert.o search.o files |
|                                   | .o utils.o                        |
|                                   |                                   |
|                                   | edit : $(objects)                 |
|                                   |         cc -o edit $(objects)     |
|                                   | main.o : main.c defs.h            |
|                                   |         cc -c main.c              |
|                                   | kbd.o : kbd.c defs.h command.h    |
|                                   |         cc -c kbd.c               |
|                                   | command.o : command.c defs.h comm |
|                                   | and.h                             |
|                                   |         cc -c command.c           |
|                                   | display.o : display.c defs.h buff |
|                                   | er.h                              |
|                                   |         cc -c display.c           |
|                                   | insert.o : insert.c defs.h buffer |
|                                   | .h                                |
|                                   |         cc -c insert.c            |
|                                   | search.o : search.c defs.h buffer |
|                                   | .h                                |
|                                   |         cc -c search.c            |
|                                   | files.o : files.c defs.h buffer.h |
|                                   |  command.h                        |
|                                   |         cc -c files.c             |
|                                   | utils.o : utils.c defs.h          |
|                                   |         cc -c utils.c             |
|                                   | clean :                           |
|                                   |         rm edit $(objects)        |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

------------------------------------------------------------------------

[]{#Letting-make-deduce-commands}

  ----------------------------------------------------------------------------- ---------------------------------------------------------------------------- --- ----------------------------------------------------------------------------------------- -------------------------------------------- ------------------------------------------------ --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Variables-simplify-makefiles "Previous section in reading order")\]   \[[\>](#Combining-rules-by-prerequisite "Next section in reading order")\]       \[[\<\<](#Putting-a-program-together "Beginning of this chapter or previous chapter")\]   \[[Up](#Writing-a-makefile "Up section")\]   \[[\>\>](#Advanced-operators "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ----------------------------------------------------------------------------- ---------------------------------------------------------------------------- --- ----------------------------------------------------------------------------------------- -------------------------------------------- ------------------------------------------------ --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Letting-make-deduce-commands-1}

### 17.5.5 Letting make deduce commands {#letting-make-deduce-commands .subsection}

[]{#index-Deducing-commands-from-implicit-makefile-rules}
[]{#index-Commands_002c-deducing-from-implicit-makefile-rules}
[]{#index-Implicit-makefile-rules_002c-introduction}
[]{#index-Makefile-rules_002c-implicit_002c-introduction}

It is not necessary to spell out the commands for compiling the
individual C source files, because `make` can figure them out: it has an
*implicit rule* for updating a '.o' file from a correspondingly named
'.c' file using a `gcc -c` command. For example, it will use the command
`gcc -c main.c -o main.o` to compile '`main.c`' into '`main.o`'. We can
therefore omit the commands from the rules for the object files.

When a '.c' file is used automatically in this way, it is also
automatically added to the list of prerequisites. We can therefore omit
the '.c' files from the prerequisites, provided we omit the commands.

Here is the entire example, with both of these changes, and the variable
`objects` as suggested above:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.example}                    |
|                                   | objects = main.o kbd.o command.o  |
|                                   | display.o \                       |
|                                   |           insert.o search.o files |
|                                   | .o utils.o                        |
|                                   |                                   |
|                                   | edit : $(objects)                 |
|                                   |         cc -o edit $(objects)     |
|                                   |                                   |
|                                   | main.o : defs.h                   |
|                                   | kbd.o : defs.h command.h          |
|                                   | command.o : defs.h command.h      |
|                                   | display.o : defs.h buffer.h       |
|                                   | insert.o : defs.h buffer.h        |
|                                   | search.o : defs.h buffer.h        |
|                                   | files.o : defs.h buffer.h command |
|                                   | .h                                |
|                                   | utils.o : defs.h                  |
|                                   |                                   |
|                                   | .PHONY : clean                    |
|                                   | clean :                           |
|                                   |         -rm edit $(objects)       |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

This is how we would write the makefile in actual practice. (See section
[Rules for cleaning the directory](#Rules-for-cleaning-the-directory),
for the complications associated with `clean`.)

Because implicit rules are so convenient, they are important. You will
see them used frequently.

------------------------------------------------------------------------

[]{#Combining-rules-by-prerequisite}

  ----------------------------------------------------------------------------- ----------------------------------------------------------------------------- --- ----------------------------------------------------------------------------------------- -------------------------------------------- ------------------------------------------------ --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Letting-make-deduce-commands "Previous section in reading order")\]   \[[\>](#Rules-for-cleaning-the-directory "Next section in reading order")\]       \[[\<\<](#Putting-a-program-together "Beginning of this chapter or previous chapter")\]   \[[Up](#Writing-a-makefile "Up section")\]   \[[\>\>](#Advanced-operators "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ----------------------------------------------------------------------------- ----------------------------------------------------------------------------- --- ----------------------------------------------------------------------------------------- -------------------------------------------- ------------------------------------------------ --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Combining-rules-by-prerequisite-1}

### 17.5.6 Combining rules by prerequisite {#combining-rules-by-prerequisite .subsection}

[]{#index-Combining-rules-by-prerequisite}
[]{#index-Prerequisite_002c-combining-rules-by}

When the objects of a makefile are created by implicit rules alone, an
alternative style of makefile is possible. In this style of makefile,
you group entries by their prerequisites instead of by their targets.
Here is an example of this alternative style:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | objects = main.o kbd.o command.o  |
|                                   | display.o \                       |
|                                   |           insert.o search.o files |
|                                   | .o utils.o                        |
|                                   |                                   |
|                                   | edit : $(objects)                 |
|                                   |         cc -o edit $(objects)     |
|                                   |                                   |
|                                   | $(objects) : defs.h               |
|                                   | kbd.o command.o files.o : command |
|                                   | .h                                |
|                                   | display.o insert.o search.o files |
|                                   | .o : buffer.h                     |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

Here '`defs.h`' is given as a prerequisite of all the object files, and
'`command.h`' and '`buffer.h`' are prerequisites of the specific object
files listed for them.

Whether this is better is a matter of taste: it is more compact, but
some people dislike it because they find it clearer to put all the
information about each target in one place.

------------------------------------------------------------------------

[]{#Rules-for-cleaning-the-directory}

  -------------------------------------------------------------------------------- --------------------------------------------------------------- --- ----------------------------------------------------------------------------------------- -------------------------------------------- ------------------------------------------------ --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Combining-rules-by-prerequisite "Previous section in reading order")\]   \[[\>](#Building-a-library "Next section in reading order")\]       \[[\<\<](#Putting-a-program-together "Beginning of this chapter or previous chapter")\]   \[[Up](#Writing-a-makefile "Up section")\]   \[[\>\>](#Advanced-operators "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  -------------------------------------------------------------------------------- --------------------------------------------------------------- --- ----------------------------------------------------------------------------------------- -------------------------------------------- ------------------------------------------------ --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Rules-for-cleaning-the-directory-1}

### 17.5.7 Rules for cleaning the directory {#rules-for-cleaning-the-directory .subsection}

[]{#index-cleaning-up}

Compiling a program is not the only thing you might want to write rules
for. Makefiles commonly do a few other things besides compiling a
program: for example, they can often delete all the object files and
executables so that the directory is *clean*.

[]{#index-clean-makefile-target-1}

Here is how we could write a `make` rule for cleaning our example
editor:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | clean:                            |
|                                   |         rm edit $(objects)        |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

In practice, we might want to write the rule in a somewhat more
complicated manner to handle unanticipated situations. For example:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | .PHONY : clean                    |
|                                   | clean :                           |
|                                   |         -rm edit $(objects)       |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

This prevents `make` from getting confused by an actual file called
'`clean`' and causes it to continue in spite of errors from `rm`.

A rule such as this should not be placed at the beginning of the
makefile, because we do not want it to run by default! Thus, in the
example makefile, we want the rule for '`edit`', which recompiles the
editor, to remain the default goal.

Since `clean` is not a prerequisite of '`edit`', this rule will not run
at all if we give the command `make` with no arguments. In order to run
the rule, we have to type `make clean`.

------------------------------------------------------------------------

[]{#Building-a-library}

  --------------------------------------------------------------------------------- --------------------------------------------------------- --- ----------------------------------------------------------------------------------------- ---------------------------------------------------- ------------------------------------------------ --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Rules-for-cleaning-the-directory "Previous section in reading order")\]   \[[\>](#Questions-17 "Next section in reading order")\]       \[[\<\<](#Putting-a-program-together "Beginning of this chapter or previous chapter")\]   \[[Up](#Putting-a-program-together "Up section")\]   \[[\>\>](#Advanced-operators "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  --------------------------------------------------------------------------------- --------------------------------------------------------- --- ----------------------------------------------------------------------------------------- ---------------------------------------------------- ------------------------------------------------ --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Building-a-library-1}

17.6 Building a library {#building-a-library .section}
-----------------------

[]{#index-Building-libraries} []{#index-Compiling-libraries}
[]{#index-Libraries_002c-compiling}

We explored what libraries are and how to use them in a previous
chapter. (See section [Libraries](#Libraries), if you need to refresh
your memory.) You may have wondered how libraries are written in the
first place. Is the whole process too complicated for a mortal C
programmer to attempt? Not at all.

Suppose you have a function (or set of functions) that you would like to
use widely across the various C programs you write. You might even like
to make it available to other users in a convenient way. To create a
code library that will enable you to achieve this, follow the sequence
below. We will use a code example, but you can create your own library
by taking similar steps.

1.  Here's an example of the kind of function you might like to use in
    multiple programs. It accepts one string containing some text to
    print, and then prints it on the default printer.

    For the sake of example, the file below is named '`lpr_print.c`'.

    +-----------------------------------+-----------------------------------+
    |                                   | ``` {.smallexample}               |
    |                                   | #include <stdio.h>                |
    |                                   |                                   |
    |                                   | void lpr_print (char *the_text)   |
    |                                   | {                                 |
    |                                   |   FILE *printer;                  |
    |                                   |                                   |
    |                                   |   printer = popen ("lpr", "w");   |
    |                                   |   fprintf (printer, the_text);    |
    |                                   |   pclose (printer);               |
    |                                   | }                                 |
    |                                   | ```                               |
    +-----------------------------------+-----------------------------------+

    (See section [Programming with pipes](#Programming-with-pipes), for
    the rationale behind this function.)

2.  Now we will create a library.
    -   []{#index-Libraries_002c-static_002c-creating}
        []{#index-Static-libraries_002c-creating}
        []{#index-Creating-static-libraries}
    -   To create a static library called '`liblprprint.a`' containing
        this function, just type the following two command lines in your
        GNU shell: []{#index-ar-program} []{#index-_002dc-option-of-GCC}

        +-----------------------------------+-----------------------------------+
        |                                   | ``` {.smallexample}               |
        |                                   | gcc -c lpr_print.c                |
        |                                   | ar rs liblprprint.a lpr_print.o   |
        |                                   | ```                               |
        +-----------------------------------+-----------------------------------+

        The '-c' option to `gcc` produces only a '.o' object code file,
        without linking it, while the `ar` command (with its 'rs'
        options) permits the creation of an *archive* file, which can
        contain a bundle of other files that can be re-extracted later
        (for example, when executing library code). In this case, we are
        only archiving one object code file, but in some cases, you
        might want to archive multiple ones. (See the `man` page for
        `ar` for more information.)

        []{#index-Libraries_002c-shared_002c-creating}
        []{#index-Shared-libraries_002c-creating}
        []{#index-Creating-shared-libraries}

    -   To create a shared library called '`liblprprint.so`' instead,
        enter the following sequence of commands:[(6)](#FOOT6){#DOCF6}
        []{#index-_002dfpic-option-of-GCC}

        +-----------------------------------+-----------------------------------+
        |                                   | ``` {.smallexample}               |
        |                                   | gcc -c -fpic lpr_print.c          |
        |                                   | gcc -shared -o liblprprint.so lpr |
        |                                   | _print.o                          |
        |                                   | ```                               |
        +-----------------------------------+-----------------------------------+

        []{#index-_002dfPIC-option-of-GCC}

        (For the record, 'pic' stands for "position-independent code",
        an object-code format required for shared libraries. You might
        need to use the option '-fPIC' instead of '-fpic' if your
        library is very large.)

    []{#index-Header-files_002c-for-libraries}
    []{#index-Library-header-files}
3.  Now create a header file that will allow users access to the
    functions in your library. You should provide one function prototype
    for each function in your library. Here is a header file for the
    library we have created, called '`liblprprint.h`'.
    +-----------------------------------+-----------------------------------+
    |                                   | ``` {.smallexample}               |
    |                                   | /*                                |
    |                                   |    liblprprint.h:                 |
    |                                   |    routines in liblprprint.a      |
    |                                   |    and liblprprint.so             |
    |                                   | */                                |
    |                                   |                                   |
    |                                   | extern void lpr_print (char *the_ |
    |                                   | text);                            |
    |                                   | ```                               |
    +-----------------------------------+-----------------------------------+

4.  Now you should put your libraries and include file somewhere your
    code can access them. For the sake of this example, create the
    directories '`include`' and '`lib`' in your home directory. Once you
    have done so, move the '.a' and '.so' files you have created to
    '`lib`', and the '.h' file to '`include`'.
5.  If you have taken the last step, and you want to run a program
    linked to a shared version of your library, you should type a line
    like the following into your shell (the following command line
    assumes you are using the Bash shell and that your home directory is
    named '`/home/fred`'):
    []{#index-LD_005fLIBRARY_005fPATH-shell-variable}

    +-----------------------------------+-----------------------------------+
    |                                   | ``` {.smallexample}               |
    |                                   | export LD_LIBRARY_PATH=/home/fred |
    |                                   | /lib:$LD_LIBRARY_PATH             |
    |                                   | ```                               |
    +-----------------------------------+-----------------------------------+

    This command line sets an environment variable that makes the linker
    search the '`/home/fred/lib`' directory before it searches anywhere
    else. You can include it in your '`.bashrc`' or '`.bash_profile`'
    file. If you don't execute this command before you attempt to run a
    program using your shared library, you will probably receive an
    error.

6.  Now you can write programs that use your library. Consider the
    following short program, called '`printer.c`':
    +-----------------------------------+-----------------------------------+
    |                                   | ``` {.smallexample}               |
    |                                   | #include <liblprprint.h>          |
    |                                   |                                   |
    |                                   | /* To shorten example, not using  |
    |                                   | argp */                           |
    |                                   | int main ()                       |
    |                                   | {                                 |
    |                                   |   lpr_print ("Hello, Multiverse!\ |
    |                                   | nHowarya?\n");                    |
    |                                   |   return 0;                       |
    |                                   | }                                 |
    |                                   | ```                               |
    +-----------------------------------+-----------------------------------+

    -   To compile this program using your static library, type
        something like the following command line:
        []{#index-_002d_002dstatic-option-of-GCC}
        []{#index-_002dI-option-of-GCC-1}
        []{#index-_002dL-option-of-GCC} []{#index-_002dl-option-of-GCC}

        +-----------------------------------+-----------------------------------+
        |                                   | ``` {.smallexample}               |
        |                                   | gcc --static -I../include -L../li |
        |                                   | b -o printer printer.c -llprprint |
        |                                   | ```                               |
        +-----------------------------------+-----------------------------------+

        The '\--static' option forces your static library to be linked;
        the default is your shared version. The '-llprprint' option
        makes GCC link in the '`liblprprint`' library, just as you would
        need to type '-lm' to link in the '`libm`' math library.

        The '-I../include' and '-L../lib' options specify that the
        compiler should look in the '`../include`' directory for include
        files and in the '`../lib`' directory for library files. This
        assumes that you have created the '`include`' and '`lib`'
        directories in your home directory as outlined above, and that
        you are compiling your code in a subdirectory of your home
        directory. If you are working two directories down, you would
        specify '-I../../include', and so on.

        The above command line assumes you are using only one '.c'
        source code file; if you are using more than one, simply include
        them on the command line as well. (See section [Compiling
        multiple files](#Compiling-multiple-files).)

        **Note:** Using the '\--static' option will force the compiler
        to link all libraries you are using statically. If you want to
        use the static version of your library, but some shared versions
        of other libraries, you can omit the '\--static' option from the
        command line and specify the static version of your library
        explicitly, as follows:

        +-----------------------------------+-----------------------------------+
        |                                   | ``` {.smallexample}               |
        |                                   | gcc -I../include -L../lib -o prin |
        |                                   | ter printer.c ../lib/liblprprint. |
        |                                   | a                                 |
        |                                   | ```                               |
        +-----------------------------------+-----------------------------------+

    -   To compile this program using your shared library, type
        something like the following command line.
        +-----------------------------------+-----------------------------------+
        |                                   | ``` {.smallexample}               |
        |                                   | gcc -I../include -L../lib -o prin |
        |                                   | ter printer.c -llprprint          |
        |                                   | ```                               |
        +-----------------------------------+-----------------------------------+

7.  The executable produced is called '`printer`'. Try it!

------------------------------------------------------------------------

[]{#Questions-17}

  ------------------------------------------------------------------- --------------------------------------------------------------- --- ----------------------------------------------------------------------------------------- ---------------------------------------------------- ------------------------------------------------ --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Building-a-library "Previous section in reading order")\]   \[[\>](#Advanced-operators "Next section in reading order")\]       \[[\<\<](#Putting-a-program-together "Beginning of this chapter or previous chapter")\]   \[[Up](#Putting-a-program-together "Up section")\]   \[[\>\>](#Advanced-operators "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ------------------------------------------------------------------- --------------------------------------------------------------- --- ----------------------------------------------------------------------------------------- ---------------------------------------------------- ------------------------------------------------ --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Questions-2}

17.7 Questions {#questions-2 .section}
--------------

1.  What is the name of the preferred method for handling command-line
    options?
2.  What does the '-c' option of the `gcc` command do?
3.  What information does the `argc` variable contain?
4.  What information does the `argv` variable contain?
5.  What information does the `envp` variable contain?

------------------------------------------------------------------------

[]{#Advanced-operators}

  ------------------------------------------------------------- ------------------------------------------------------------------------ --- ----------------------------------------------------------------------------------------- ----------------------------- --------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Questions-17 "Previous section in reading order")\]   \[[\>](#Hidden-operators-and-values "Next section in reading order")\]       \[[\<\<](#Putting-a-program-together "Beginning of this chapter or previous chapter")\]   \[[Up](#Top "Up section")\]   \[[\>\>](#More-data-types "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ------------------------------------------------------------- ------------------------------------------------------------------------ --- ----------------------------------------------------------------------------------------- ----------------------------- --------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Advanced-operators-1}

18. Advanced operators {#advanced-operators .chapter}
======================

*Concise expressions*

  ------------------------------------------------------------------ ---- --
  [18.1 Hidden operators and values](#Hidden-operators-and-values)        
  [18.2 The comma operator](#The-comma-operator)                          
  [18.3 Machine-level operators](#Machine_002dlevel-operators)            
  [18.4 Questions 18](#Questions-18)                                      
  ------------------------------------------------------------------ ---- --

In this chapter, we will examine some advanced mathematical and logical
operators in C.

------------------------------------------------------------------------

[]{#Hidden-operators-and-values}

  ------------------------------------------------------------------- --------------------------------------------------------------- --- --------------------------------------------------------------------------------- -------------------------------------------- --------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Advanced-operators "Previous section in reading order")\]   \[[\>](#Hidden-assignments "Next section in reading order")\]       \[[\<\<](#Advanced-operators "Beginning of this chapter or previous chapter")\]   \[[Up](#Advanced-operators "Up section")\]   \[[\>\>](#More-data-types "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ------------------------------------------------------------------- --------------------------------------------------------------- --- --------------------------------------------------------------------------------- -------------------------------------------- --------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Hidden-operators-and-values-1}

18.1 Hidden operators and values {#hidden-operators-and-values .section}
--------------------------------

[]{#index-Hidden-operators} []{#index-Operators_002c-hidden}

Many operators in C are more versatile than they appear to be at first
glance. Take, for example, the following operators:

[]{#index-_003d-operator} []{#index-_002b_002b-operator}
[]{#index-_002d_002d-operator} []{#index-_002b_003d-operator-1}
[]{#index-_002d_003d-operator-1}

-   `=`
-   `++`
-   `--`
-   `+=`
-   `-=`

These operators can be used in some surprising ways to make C source
code elegant and compact. (See section [Expressions and
operators](#Expressions-and-operators), if you need a refresher in what
they do.) All of them can form expressions that have their own values.
Such an expression can be taken as a whole (a "black box") and treated
as a single value, which can then be assigned and compared to other
expressions, in effect, "hidden" within another expression.

The value of an expression is the result of the operation carried out in
the expression. Increment and decrement statements have a value that is
one greater than or one less than the value of the variable they act
upon, respectively.

Consider the following two statements:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | c = 5;                            |
|                                   | c++;                              |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

The expression `c++` in the above context has the value 6.

Now consider these statements:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | c = 5;                            |
|                                   | c--;                              |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

The expression `c--` in the above context has the value 4.

  ------------------------------------------------------------------------------------------ ---- --
  [18.1.1 Hidden assignments](#Hidden-assignments)                                                
  [18.1.2 Postfix and prefix `++` and `--`](#Postfix-and-prefix-_002b_002b-and-_002d_002d)        
  [18.1.3 Arrays and hidden operators](#Arrays-and-hidden-operators)                              
  [18.1.4 A warning about style](#A-warning-about-style)                                          
  ------------------------------------------------------------------------------------------ ---- --

------------------------------------------------------------------------

[]{#Hidden-assignments}

  ---------------------------------------------------------------------------- ----------------------------------------------------------------------------------------- --- --------------------------------------------------------------------------------- ----------------------------------------------------- --------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Hidden-operators-and-values "Previous section in reading order")\]   \[[\>](#Postfix-and-prefix-_002b_002b-and-_002d_002d "Next section in reading order")\]       \[[\<\<](#Advanced-operators "Beginning of this chapter or previous chapter")\]   \[[Up](#Hidden-operators-and-values "Up section")\]   \[[\>\>](#More-data-types "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ---------------------------------------------------------------------------- ----------------------------------------------------------------------------------------- --- --------------------------------------------------------------------------------- ----------------------------------------------------- --------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Hidden-assignments-1}

### 18.1.1 Hidden assignments {#hidden-assignments .subsection}

[]{#index-Hidden-assignments} []{#index-Assignments_002c-hidden}

Assignment expressions have values too --- their values are the value of
the assignment. For example, the value of the expression `c = 5` is 5.

The fact that assignment statements have values can be used to make C
code more elegant. An assignment expression can itself be assigned to a
variable. For example, the expression `c = 0` can be assigned to the
variable `b`:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | b = (c = 0);                      |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

or simply:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | b = c = 0;                        |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

These equivalent statements set `b` and `c` to the value 0, provided `b`
and `c` are of the same type. They are equivalent to the more usual:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | b = 0;                            |
|                                   | c = 0;                            |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

**Note:** Don't confuse this technique with a logical test for equality.
In the above example, both `b` and `c` are set to 0. Consider the
following, superficially similar, test for equality, however:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | b = (c == 0);                     |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

In this case, `b` will only be assigned a zero value (`FALSE`) if `c`
does not equal 0. If `c` does equal 0, then `b` will be assigned a
non-zero value for `TRUE`, probably 1. (See section [Comparisons and
logic](#Comparisons-and-logic), for more information.)

Any number of these assignments can be strung together:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | a = (b = (c = (d = (e = 5))));    |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

or simply:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | a = b = c = d = e = 5;            |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

This elegant syntax compresses five lines of code into a single line.

There are other uses for treating assignment expressions as values.
Thanks to C's flexible syntax, they can be used anywhere a value can be
used. Consider how an assignment expression might be used as a parameter
to a function. The following statement gets a character from standard
input and passes it to a function called `process_character`.

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | process_character (input_char = g |
|                                   | etchar());                        |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

This is a perfectly valid statement in C, because the hidden assignment
statements passes the value it assigns on to `process_character`. The
assignment is carried out first and then the `process_character`
function is called, so this is merely a more compact way of writing the
following statements.

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | input_char = getchar();           |
|                                   | process_character (input_char);   |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

All the same remarks apply about the specialized assignment operators
`+=`, `*=`, `/=`, and so on.

The following example makes use of a hidden assignment in a `while` loop
to print out all values from 0.2 to 20.0 in steps of 0.2.

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | #include <stdio.h>                |
|                                   |                                   |
|                                   | /* To shorten example, not using  |
|                                   | argp */                           |
|                                   | int main ()                       |
|                                   | {                                 |
|                                   |   double my_dbl = 0;              |
|                                   |                                   |
|                                   |   while ((my_dbl += 0.2) < 20.0)  |
|                                   |     printf ("%lf ", my_dbl);      |
|                                   |                                   |
|                                   |   printf ("\n");                  |
|                                   |                                   |
|                                   |   return 0;                       |
|                                   | }                                 |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

------------------------------------------------------------------------

[]{#Postfix-and-prefix-_002b_002b-and-_002d_002d}

  ------------------------------------------------------------------- ------------------------------------------------------------------------ --- --------------------------------------------------------------------------------- ----------------------------------------------------- --------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Hidden-assignments "Previous section in reading order")\]   \[[\>](#Arrays-and-hidden-operators "Next section in reading order")\]       \[[\<\<](#Advanced-operators "Beginning of this chapter or previous chapter")\]   \[[Up](#Hidden-operators-and-values "Up section")\]   \[[\>\>](#More-data-types "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ------------------------------------------------------------------- ------------------------------------------------------------------------ --- --------------------------------------------------------------------------------- ----------------------------------------------------- --------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Postfix-and-prefix-_002b_002b-and-_002d_002d-1}

### 18.1.2 Postfix and prefix `++` and `--` {#postfix-and-prefix-and--- .subsection}

[]{#index-_002b_002b-postfix-operator}
[]{#index-_002d_002d-postfix-operator}
[]{#index-_002b_002b-increment-operator-1}
[]{#index-_002d_002d-decrement-operator-1} []{#index-Postfix-operators}
[]{#index-Postfix-_002b_002b-operator}
[]{#index-Postfix-_002d_002d-operator}
[]{#index-_002b_002b-prefix-operator}
[]{#index-_002d_002d-prefix-operator} []{#index-Prefix-operators}
[]{#index-Prefix-_002b_002b-operator}
[]{#index-Prefix-_002d_002d-operator}

Increment (`++`) and decrement (`--`) expressions also have values, and
like assignment expressions, can be hidden away in inconspicuous places.
These two operators are slightly more complicated than assignments
because they exist in two forms, postfix (for example, `my_var++`) and
prefix (for example, `++my_var`).

Postfix and prefix forms have subtly different meanings. Take the
following example:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | int my_int = 3;                   |
|                                   | printf ("%d\n", my_int++);        |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

The increment operator is hidden in the parameter list of the `printf`
call. The variable `my_int` has a value before the `++` operator acts on
it (3) and afterwards (4).

Which value is passed to `printf`? Is `my_int` incremented before or
after the `printf` call? This is where the two forms of the operator
(postfix and prefix) come into play.

**If the increment or decrement operator is used as a prefix, the
operation is performed *before* the function call. If the operator is
used as a postfix, the operation is performed *after* the function
call.**

In the example above, then, the value passed to `printf` is 3, and when
the `printf` function returns, the value of `my_int` is incremented to
4. The alternative is to write

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | int my_int = 3;                   |
|                                   | printf ("%d\n", ++my_int);        |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

in which case the value 4 is passed to `printf`.

The same remarks apply to the decrement operator as to the increment
operator.

------------------------------------------------------------------------

[]{#Arrays-and-hidden-operators}

  --------------------------------------------------------------------------------------------- ------------------------------------------------------------------ --- --------------------------------------------------------------------------------- ----------------------------------------------------- --------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Postfix-and-prefix-_002b_002b-and-_002d_002d "Previous section in reading order")\]   \[[\>](#A-warning-about-style "Next section in reading order")\]       \[[\<\<](#Advanced-operators "Beginning of this chapter or previous chapter")\]   \[[Up](#Hidden-operators-and-values "Up section")\]   \[[\>\>](#More-data-types "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  --------------------------------------------------------------------------------------------- ------------------------------------------------------------------ --- --------------------------------------------------------------------------------- ----------------------------------------------------- --------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Arrays-and-hidden-operators-1}

### 18.1.3 Arrays and hidden operators {#arrays-and-hidden-operators .subsection}

[]{#index-Arrays-and-hidden-operators}
[]{#index-Hidden-operators-and-arrays}
[]{#index-Operators_002c-hidden_002c-and-arrays}

Hidden operators can simplify dealing with arrays and strings quite a
bit. Hiding operators inside array subscripts or hidding assignments
inside loops can often streamline tasks such as array initialization.
Consider the following example of a one-dimensional array of integers.

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | #include <stdio.h>                |
|                                   |                                   |
|                                   | #define ARRAY_SIZE 20             |
|                                   |                                   |
|                                   | /* To shorten example, not using  |
|                                   | argp */                           |
|                                   | int main ()                       |
|                                   | {                                 |
|                                   |   int idx, array[ARRAY_SIZE];     |
|                                   |                                   |
|                                   |   for (idx = 0; idx < ARRAY_SIZE; |
|                                   |  array[idx++] = 0)                |
|                                   |     ;                             |
|                                   |                                   |
|                                   |   return 0;                       |
|                                   | }                                 |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

This is a convenient way to initialize an array to zero. Notice that the
body of the loop is completely empty!

Strings can benefit from hidden operators as well. If the standard
library function `strlen`, which finds the length of a string, were not
available, it would be easy to write it with hidden operators:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | #include <stdio.h>                |
|                                   |                                   |
|                                   | int my_strlen (char *my_string)   |
|                                   | {                                 |
|                                   |   char *ptr;                      |
|                                   |   int count = 0;                  |
|                                   |                                   |
|                                   |   for (ptr = my_string; *(ptr++)  |
|                                   | != '\0'; count++)                 |
|                                   |     ;                             |
|                                   |                                   |
|                                   |   return (count);                 |
|                                   | }                                 |
|                                   | ```                               |
|                                   |                                   |
|                                   | ``` {.smallexample}               |
|                                   | ```                               |
|                                   |                                   |
|                                   | ``` {.smallexample}               |
|                                   | /* To shorten example, not using  |
|                                   | argp */                           |
|                                   | int main (int argc, char *argv[], |
|                                   |  char *envp[])                    |
|                                   | {                                 |
|                                   |   char string_ex[] = "Fabulous!"; |
|                                   |                                   |
|                                   |   printf ("String = '%s'\n", stri |
|                                   | ng_ex);                           |
|                                   |   printf ("Length = %d\n", my_str |
|                                   | len (string_ex));                 |
|                                   |                                   |
|                                   |   return 0;                       |
|                                   | }                                 |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

The `my_strlen` function increments `count` while the end of string
marker '\\0' is not found. Again, notice that the body of the loop in
this function is completely empty.

------------------------------------------------------------------------

[]{#A-warning-about-style}

  ---------------------------------------------------------------------------- --------------------------------------------------------------- --- --------------------------------------------------------------------------------- ----------------------------------------------------- --------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Arrays-and-hidden-operators "Previous section in reading order")\]   \[[\>](#The-comma-operator "Next section in reading order")\]       \[[\<\<](#Advanced-operators "Beginning of this chapter or previous chapter")\]   \[[Up](#Hidden-operators-and-values "Up section")\]   \[[\>\>](#More-data-types "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ---------------------------------------------------------------------------- --------------------------------------------------------------- --- --------------------------------------------------------------------------------- ----------------------------------------------------- --------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#A-warning-about-style-1}

### 18.1.4 A warning about style {#a-warning-about-style .subsection}

[]{#index-Style_002c-warning-about} []{#index-Style-2}

Overuse of "hidden" operators can produce code that is difficult to
understand. See section [Hidden operators and
style](#Hidden-operators-and-style), for some cautions about when not to
use them.

------------------------------------------------------------------------

[]{#The-comma-operator}

  ---------------------------------------------------------------------- ------------------------------------------------------------------------ --- --------------------------------------------------------------------------------- -------------------------------------------- --------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#A-warning-about-style "Previous section in reading order")\]   \[[\>](#Machine_002dlevel-operators "Next section in reading order")\]       \[[\<\<](#Advanced-operators "Beginning of this chapter or previous chapter")\]   \[[Up](#Advanced-operators "Up section")\]   \[[\>\>](#More-data-types "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ---------------------------------------------------------------------- ------------------------------------------------------------------------ --- --------------------------------------------------------------------------------- -------------------------------------------- --------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#The-comma-operator-1}

18.2 The comma operator {#the-comma-operator .section}
-----------------------

[]{#index-Comma-operator} []{#index-Operator_002c-comma}
[]{#index-_002c-operator}

The comma operator (`,`) works almost like the semicolon ';' that
separates one C statement from another. You can separate almost any kind
of C statment from another with a comma operator. The comma-separated
expressions are evaluated from left to right and the value of the whole
comma-separated sequence is the value of the rightmost expression in the
sequence. Consider the following code example.

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | #include <stdio.h>                |
|                                   |                                   |
|                                   | /* To shorten example, not using  |
|                                   | argp */                           |
|                                   | int main (int argc, char *argv[], |
|                                   |  char *envp[])                    |
|                                   | {                                 |
|                                   |   int a, b, c, d;                 |
|                                   |                                   |
|                                   |   a = (b = 2, c = 3, d = 4);      |
|                                   |   printf ("a=%d\nb=%d\nc=%d\nd=%d |
|                                   | \n",                              |
|                                   |       a, b, c, d);                |
|                                   |   return 0;                       |
|                                   | }                                 |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

The value of `(b = 2, c = 3, d = 4)` is 4 because the value of its
rightmost sub-expression, `d = 4`, is 4. The value of `a` is thus also
4. When run, this example prints out the following text:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | a=4                               |
|                                   | b=2                               |
|                                   | c=3                               |
|                                   | d=4                               |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

The comma operator is very useful in `for` loops. (See section [The
flexibility of `for`](#The-flexibility-of-for), for an example.)

------------------------------------------------------------------------

[]{#Machine_002dlevel-operators}

  ------------------------------------------------------------------- -------------------------------------------------------------- --- --------------------------------------------------------------------------------- -------------------------------------------- --------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#The-comma-operator "Previous section in reading order")\]   \[[\>](#Bitwise-operators "Next section in reading order")\]       \[[\<\<](#Advanced-operators "Beginning of this chapter or previous chapter")\]   \[[Up](#Advanced-operators "Up section")\]   \[[\>\>](#More-data-types "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ------------------------------------------------------------------- -------------------------------------------------------------- --- --------------------------------------------------------------------------------- -------------------------------------------- --------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Machine_002dlevel-operators-1}

18.3 Machine-level operators {#machine-level-operators .section}
----------------------------

*Bits and Bytes. Flags. Shifting.*

[]{#index-Bits} []{#index-Bytes} []{#index-Binary-digits}

Bits (or binary digits), the values 0 and 1, are the lowest-level
software objects in a computer; there is nothing more primitive. C gives
programmers full access to bits and bit sequences, and even provides
high-level operators for manipulating them.

[]{#index-Bit-strings}

All computer data whatsoever is composed of *bit strings*. The word
"string" is being used here in its more general sense of sequence; do
not confuse the usage with "text string". Although all text strings are
bit strings, not all bit strings are text strings.

The only difference between a text string and a floating-point value is
the way we interpret the pattern of bits in the computer's memory. For
the most part, we can simply ignore the low level of the computer in
which computer data appears as bit strings. Systems programmers, on the
other hand, such as those who wrote GNU/Linux, must frequently
manipulate bits directly in order to handle flags.

[]{#index-Flags}

A *flag* is a bit in a bit string that can be either *set* (1) or
*cleared* (0). We have run across a few flags already, such as the
various flags passed to the GNU C Library functions `open`; the flags
`O_RDONLY` and `O_WRONLY` are actually macros that specify binary
values, which can be manipulated and examined with binary OR and similar
functions. Flags are normally declared as integers in C.

Programmers who perform bit operations on a regular basis often use
either octal (base-8) or hexadecimal (base-16) numbers, because every
octal digit specifies exactly three bits, and every hexadecimal digit
specifies four.

  ------------------------------------------------------------------ ---- --
  [18.3.1 Bitwise operators](#Bitwise-operators)                          
  [18.3.2 Shift operations](#Shift-operations)                            
  [18.3.3 Truth tables and bit masks](#Truth-tables-and-bit-masks)        
  ------------------------------------------------------------------ ---- --

------------------------------------------------------------------------

[]{#Bitwise-operators}

  ---------------------------------------------------------------------------- ------------------------------------------------------------- --- --------------------------------------------------------------------------------- ----------------------------------------------------- --------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Machine_002dlevel-operators "Previous section in reading order")\]   \[[\>](#Shift-operations "Next section in reading order")\]       \[[\<\<](#Advanced-operators "Beginning of this chapter or previous chapter")\]   \[[Up](#Machine_002dlevel-operators "Up section")\]   \[[\>\>](#More-data-types "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ---------------------------------------------------------------------------- ------------------------------------------------------------- --- --------------------------------------------------------------------------------- ----------------------------------------------------- --------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Bitwise-operators-1}

### 18.3.1 Bitwise operators {#bitwise-operators .subsection}

[]{#index-Bitwise-operators} []{#index-Operators_002c-bitwise}

C provides the following operators for handling bit patterns:

[]{#index-Bit_002dshift-left-operator}
[]{#index-_003c_003c-bitwise-operator}

`<<`

Bit-shift left by a specified number of bit positions

[]{#index-Bit_002dshift-right-operator}
[]{#index-_003e_003e-bitwise-operator}

`>>`

Bit-shift right by a specified number of bit positions

[]{#index-Bitwise-inclusive-OR} []{#index-_007c-bitwise-operator}

`|`

Bitwise inclusive OR

[]{#index-Bitwise-exclusive-OR} []{#index-_005e-bitwise-operator}

`^`

Bitwise exclusive OR

[]{#index-Bitwise-AND} []{#index-_0026-bitwise-operator}

`&`

Bitwise AND

[]{#index-Bitwise-NOT} []{#index-_007e-bitwise-operator}

`~`

Bitwise NOT

[]{#index-Bit_002dshift-left-assignment}
[]{#index-_003c_003c_003d-bitwise-operator}

`<<=`

Bit-shift left assignment (var = var \<\< value)

[]{#index-Bit_002dshift-right-assignment}
[]{#index-_003e_003e_003d-bitwise-operator}

`>>=`

Bit-shift right assignment (var = var \>\> value)

[]{#index-Exclusive-OR-assignment}
[]{#index-_007c_003d-bitwise-operator}

`|=`

Exclusive OR assignment (var = var \| value)

[]{#index-Inclusive-OR-assignment}
[]{#index-_005e_003d-bitwise-operator}

`^=`

Inclusive OR assignment (var = var \^ value)

[]{#index-AND-assignment} []{#index-_0026_003d-bitwise-operator}

`&=`

AND assignment (var = var & value)

The meaning and syntax of these operators is given below.

Don't confuse bitwise operators (such as bitwise AND, `&`) with logical
operators (such as logical AND, `&&`). Bitwise operators operate on each
bit in the operand individually.

------------------------------------------------------------------------

[]{#Shift-operations}

  ------------------------------------------------------------------ ----------------------------------------------------------------------- --- --------------------------------------------------------------------------------- ----------------------------------------------------- --------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Bitwise-operators "Previous section in reading order")\]   \[[\>](#Truth-tables-and-bit-masks "Next section in reading order")\]       \[[\<\<](#Advanced-operators "Beginning of this chapter or previous chapter")\]   \[[Up](#Machine_002dlevel-operators "Up section")\]   \[[\>\>](#More-data-types "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ------------------------------------------------------------------ ----------------------------------------------------------------------- --- --------------------------------------------------------------------------------- ----------------------------------------------------- --------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Shift-operations-1}

### 18.3.2 Shift operations {#shift-operations .subsection}

[]{#index-Shift-operators} []{#index-Operators_002c-shift}

Imagine a bit string as represented by the following group of boxes.
Every box represents a bit, a binary digit; the ones and zeros inside
represent their values. The values written across the top are the
place-values of each bit. (Just as a decimal (base-10) number has a ones
place, a tens place, a hundreds place, a thousands place, and so on, a
binary (base-2) number has the places 1, 2, 4, 8, 16, 32, etc.) The
number after the equals sign shows the value of the bit string in
decimal notation.

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   |  128  64  32  16  8   4   2   1   |
|                                   |  -------------------------------  |
|                                   | | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 1 | |
|                                   |   =  1                            |
|                                   |  -------------------------------  |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

Bit-shift operators move whole bit strings left or right. The syntax of
the bit-shift left operation is `value << positions`; that of bit-shift
right is `value >> positions`; So for example, using the bit string (1)
above, the value of `1 << 1` is 2, because the bit string would have
been moved one position to the left:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   |  128  64  32  16  8   4   2   1   |
|                                   |  -------------------------------  |
|                                   | | 0 | 0 | 0 | 0 | 0 | 0 | 1 | 0 | |
|                                   |   =  2                            |
|                                   |  -------------------------------  |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

Notice how the space to the right of the shifted bit string is simply
filled with a 0.

Similarly, the value of `1 << 4` is 16, because the original bit string
is shifted left four places:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   |  128  64  32  16  8   4   2   1   |
|                                   |  -------------------------------  |
|                                   | | 0 | 0 | 0 | 1 | 0 | 0 | 0 | 0 | |
|                                   |   =  16                           |
|                                   |  -------------------------------  |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

Notice, again, that the spaces to the right of the original bit string
are filled out with zeros.

Now for a slightly more difficult one. The value of `6 << 2` is 24. Here
is the bit string representing 6:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   |  128  64  32  16  8   4   2   1   |
|                                   |  -------------------------------  |
|                                   | | 0 | 0 | 0 | 0 | 0 | 1 | 1 | 0 | |
|                                   |   =  6                            |
|                                   |  -------------------------------  |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

Shift 6 left 2 places:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   |  128  64  32  16  8   4   2   1   |
|                                   |  -------------------------------  |
|                                   | | 0 | 0 | 0 | 1 | 1 | 0 | 0 | 0 | |
|                                   |   =  24                           |
|                                   |  -------------------------------  |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

Notice that every shift left multiplies by 2. (Since `6 << 2` means to
shift 6 left twice, the result is 24.)

As you might expect, every shift right performs (integer) division by
two on the number. If a bit is shifted beyond the ones position (the
rightmost "box"), however, then it "drops off" and is lost. So the
following equalities hold:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | 1 >> 1 == 0                       |
|                                   | 2 >> 1 == 1                       |
|                                   | 2 >> 2 == 0                       |
|                                   | n >> n == 0                       |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

One common use of bit-shifting is to scan through the bits of a
bit-string one by one in a loop. This is done with bit masks, as
described in the next section.

------------------------------------------------------------------------

[]{#Truth-tables-and-bit-masks}

  ----------------------------------------------------------------- -------------------------------------------------------- --- --------------------------------------------------------------------------------- ----------------------------------------------------- --------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Shift-operations "Previous section in reading order")\]   \[[\>](#Bitwise-NOT "Next section in reading order")\]       \[[\<\<](#Advanced-operators "Beginning of this chapter or previous chapter")\]   \[[Up](#Machine_002dlevel-operators "Up section")\]   \[[\>\>](#More-data-types "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ----------------------------------------------------------------- -------------------------------------------------------- --- --------------------------------------------------------------------------------- ----------------------------------------------------- --------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Truth-tables-and-bit-masks-1}

### 18.3.3 Truth tables and bit masks {#truth-tables-and-bit-masks .subsection}

[]{#index-Truth-tables} []{#index-Bit-masks}
[]{#index-Tables_002c-truth} []{#index-Masks_002c-bit}

The binary operators AND (`&`), OR (inclusive OR, `|`) and XOR
(exclusive OR, also called EOR, `^`) perform comparisons, or *masking*
operations, between two bit strings. They are also binary operators in
the sense that they take two operands. There is another operator called
NOT (`~`) that is a unary operator; it takes only one operand.

These bitwise operations are best summarized by *truth tables*. Each
truth table for a binary operator (that is, one with two operands),
indicates what the result of the operation is for every possible
combination of two bits.

  ---------------------------------------------------------------------------------------- ---- --
  [18.3.3.1 Bitwise NOT](#Bitwise-NOT)                                                          
  [18.3.3.2 Bitwise AND](#Bitwise-AND)                                                          
  [18.3.3.3 Bitwise inclusive OR](#Bitwise-inclusive-OR)                                        
  [18.3.3.4 Bitwise exclusive OR (XOR/EOR)](#Bitwise-exclusive-OR-_0028XOR_002fEOR_0029)        
  [18.3.3.5 Masks](#Masks)                                                                      
  ---------------------------------------------------------------------------------------- ---- --

------------------------------------------------------------------------

[]{#Bitwise-NOT}

  --------------------------------------------------------------------------- -------------------------------------------------------- --- --------------------------------------------------------------------------------- ---------------------------------------------------- --------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Truth-tables-and-bit-masks "Previous section in reading order")\]   \[[\>](#Bitwise-AND "Next section in reading order")\]       \[[\<\<](#Advanced-operators "Beginning of this chapter or previous chapter")\]   \[[Up](#Truth-tables-and-bit-masks "Up section")\]   \[[\>\>](#More-data-types "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  --------------------------------------------------------------------------- -------------------------------------------------------- --- --------------------------------------------------------------------------------- ---------------------------------------------------- --------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Bitwise-NOT-1}

#### 18.3.3.1 Bitwise NOT {#bitwise-not .subsubsection}

[]{#index-Bitwise-NOT_002c-truth-table}
[]{#index-NOT_002c-bitwise_002c-truth-table}
[]{#index-_007e-bitwise-operator-truth-table}

The unary operator NOT (`~`) simply generates the *one's complement* of
the bit string; that is, it returns the same bit string, with all ones
replaced with zeros and all zeros replaced with ones. As a truth table
this would be summarized as follows:

  --------- --------
  \~value   result
  0         1
  1         0
  --------- --------

------------------------------------------------------------------------

[]{#Bitwise-AND}

  ------------------------------------------------------------ ----------------------------------------------------------------- --- --------------------------------------------------------------------------------- ---------------------------------------------------- --------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Bitwise-NOT "Previous section in reading order")\]   \[[\>](#Bitwise-inclusive-OR "Next section in reading order")\]       \[[\<\<](#Advanced-operators "Beginning of this chapter or previous chapter")\]   \[[Up](#Truth-tables-and-bit-masks "Up section")\]   \[[\>\>](#More-data-types "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ------------------------------------------------------------ ----------------------------------------------------------------- --- --------------------------------------------------------------------------------- ---------------------------------------------------- --------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Bitwise-AND-1}

#### 18.3.3.2 Bitwise AND {#bitwise-and .subsubsection}

[]{#index-Bitwise-AND_002c-truth-table}
[]{#index-AND_002c-bitwise_002c-truth-table}
[]{#index-_0026-bitwise-operator-truth-table}

Bitwise AND operates on two values, for example `0 & 1`. Both the first
value *and* the second value must be 1 in order for the result to be 1.
As a truth table this would be summarized as follows:

  -------- -------- --------
  value1   value2   result
  0        0        0
  0        1        0
  1        0        0
  1        1        1
  -------- -------- --------

------------------------------------------------------------------------

[]{#Bitwise-inclusive-OR}

  ------------------------------------------------------------ --------------------------------------------------------------------------------------- --- --------------------------------------------------------------------------------- ---------------------------------------------------- --------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Bitwise-AND "Previous section in reading order")\]   \[[\>](#Bitwise-exclusive-OR-_0028XOR_002fEOR_0029 "Next section in reading order")\]       \[[\<\<](#Advanced-operators "Beginning of this chapter or previous chapter")\]   \[[Up](#Truth-tables-and-bit-masks "Up section")\]   \[[\>\>](#More-data-types "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ------------------------------------------------------------ --------------------------------------------------------------------------------------- --- --------------------------------------------------------------------------------- ---------------------------------------------------- --------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Bitwise-inclusive-OR-1}

#### 18.3.3.3 Bitwise inclusive OR {#bitwise-inclusive-or .subsubsection}

[]{#index-Bitwise-inclusive-OR_002c-truth-table}
[]{#index-Inclusive-OR_002c-bitwise_002c-truth-table}
[]{#index-OR_002c-bitwise-inclusive_002c-truth-table}
[]{#index-_007c-bitwise-operator-truth-table}

Bitwise OR operates on two values, for example `0 | 1`. The result is 1
if the first value *or* the second value is 1, *or* both are 1. As a
truth table this would be summarized as follows:

  -------- -------- --------
  value1   value2   result
  0        0        0
  0        1        1
  1        0        1
  1        1        1
  -------- -------- --------

------------------------------------------------------------------------

[]{#Bitwise-exclusive-OR-_0028XOR_002fEOR_0029}

  --------------------------------------------------------------------- -------------------------------------------------- --- --------------------------------------------------------------------------------- ---------------------------------------------------- --------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Bitwise-inclusive-OR "Previous section in reading order")\]   \[[\>](#Masks "Next section in reading order")\]       \[[\<\<](#Advanced-operators "Beginning of this chapter or previous chapter")\]   \[[Up](#Truth-tables-and-bit-masks "Up section")\]   \[[\>\>](#More-data-types "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  --------------------------------------------------------------------- -------------------------------------------------- --- --------------------------------------------------------------------------------- ---------------------------------------------------- --------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Bitwise-exclusive-OR-_0028XOR_002fEOR_0029-1}

#### 18.3.3.4 Bitwise exclusive OR (XOR/EOR) {#bitwise-exclusive-or-xoreor .subsubsection}

[]{#index-Bitwise-exclusive-OR_002c-truth-table}
[]{#index-Exclusive-OR_002c-bitwise_002c-truth-table}
[]{#index-OR_002c-bitwise-exclusive_002c-truth-table}
[]{#index-EOR_002c-truth-table} []{#index-XOR_002c-truth-table}
[]{#index-_005e-bitwise-operator-truth-table}

Bitwise XOR operates on two values, for example `0 ^ 1`. The result is 1
if the first value *or* the second value is 1, but *not* if *both* are 1
(hence the name "exclusive OR"). As a truth table this would be
summarized as follows:

  -------- -------- --------
  value1   value2   result
  0        0        0
  0        1        1
  1        0        1
  1        1        0
  -------- -------- --------

------------------------------------------------------------------------

[]{#Masks}

  ------------------------------------------------------------------------------------------- --------------------------------------------------------- --- --------------------------------------------------------------------------------- ---------------------------------------------------- --------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Bitwise-exclusive-OR-_0028XOR_002fEOR_0029 "Previous section in reading order")\]   \[[\>](#Questions-18 "Next section in reading order")\]       \[[\<\<](#Advanced-operators "Beginning of this chapter or previous chapter")\]   \[[Up](#Truth-tables-and-bit-masks "Up section")\]   \[[\>\>](#More-data-types "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ------------------------------------------------------------------------------------------- --------------------------------------------------------- --- --------------------------------------------------------------------------------- ---------------------------------------------------- --------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Masks-1}

#### 18.3.3.5 Masks {#masks .subsubsection}

[]{#index-Bit-masks-1} []{#index-Masks_002c-bit-1}

Bit strings and bitwise operators are often used to make *masks*. A mask
is a bit string that "fits over" another bit string and produces a
desired result, such as singling out particular bits from the second bit
string, when the two bit strings are operated upon. This is particularly
useful for handling flags; programmers often wish to know whether one
particular flag is set in a bit string, but may not care about the
others. For example, you might create a mask that only allows the flag
of interest to have a non-zero value, then AND that mask with the bit
string containing the flag.

Consider the following mask, and two bit strings from which we want to
extract the final bit:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | mask   = 00000001                 |
|                                   | value1 = 10011011                 |
|                                   | value2 = 10011100                 |
|                                   |                                   |
|                                   | mask & value1 == 00000001         |
|                                   | mask & value2 == 00000000         |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

The zeros in the mask *mask off* the first seven bits and only let the
last bit show through. (In the case of the first value, the last bit is
1; in the case of the second value, the last bit is 0.)

Alternatively, masks can be built up by operating on several flags,
usually with inclusive OR:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | flag1 = 00000001                  |
|                                   | flag2 = 00000010                  |
|                                   | flag3 = 00000100                  |
|                                   |                                   |
|                                   | mask = flag1 | flag2 | flag3      |
|                                   |                                   |
|                                   | mask == 00000111                  |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

See section [Opening files at a low
level](#Opening-files-at-a-low-level), for a code example that actually
uses bitwise OR to join together several flags.

It should be emphasized that the flag and mask examples are written in
*pseudo-code*, that is, a means of expressing information that resembles
source code, but cannot be compiled. It is not possible to use binary
numbers directly in C.

The following code example shows how bit masks and bit-shifts can be
combined. It accepts a decimal number from the user between 0 and 128,
and prints out a binary number in response.

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | #include <stdio.h>                |
|                                   | #define NUM_OF_BITS 8             |
|                                   |                                   |
|                                   | /* To shorten example, not using  |
|                                   | argp */                           |
|                                   | int main ()                       |
|                                   | {                                 |
|                                   |   char *my_string;                |
|                                   |   int input_int, args_assigned;   |
|                                   |   int nbytes = 100;               |
|                                   |   short my_short, bit;            |
|                                   |   int idx;                        |
|                                   |                                   |
|                                   |   /* This hex number is the same  |
|                                   | as binary 10000000 */             |
|                                   |   short MASK = 0x80;              |
|                                   |                                   |
|                                   |   args_assigned = 0;              |
|                                   |   input_int = -1;                 |
|                                   |                                   |
|                                   |   while ((args_assigned != 1) ||  |
|                                   |      (input_int < 0) || (input_in |
|                                   | t > 128))                         |
|                                   |     {                             |
|                                   |       puts ("Please enter an inte |
|                                   | ger from 0 to 128.");             |
|                                   |       my_string = (char *) malloc |
|                                   |  (nbytes + 1);                    |
|                                   |       getline (&my_string, &nbyte |
|                                   | s, stdin);                        |
|                                   |       args_assigned = sscanf (my_ |
|                                   | string, "%d", &input_int);        |
|                                   |       if ((args_assigned != 1) || |
|                                   |       (input_int < 0) || (input_i |
|                                   | nt > 128))                        |
|                                   |     puts ("\nInput invalid!");    |
|                                   |     }                             |
|                                   |                                   |
|                                   |   my_short = (short) input_int;   |
|                                   |                                   |
|                                   |   printf ("Binary value = ");     |
|                                   |                                   |
|                                   |   /*                              |
|                                   |      Convert decimal numbers into |
|                                   |  binary                           |
|                                   |      Keep shifting my_short by on |
|                                   | e to the left                     |
|                                   |      and test the highest bit.  T |
|                                   | his does                          |
|                                   |      NOT preserve the value of my |
|                                   | _short!                           |
|                                   |   */                              |
|                                   |                                   |
|                                   |   for (idx = 0; idx < NUM_OF_BITS |
|                                   | ; idx++)                          |
|                                   |     {                             |
|                                   |       bit = my_short & MASK;      |
|                                   |       printf ("%d", bit/MASK);    |
|                                   |       my_short <<= 1;             |
|                                   |     }                             |
|                                   |                                   |
|                                   |   printf ("\n");                  |
|                                   |   return 0;                       |
|                                   | }                                 |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

------------------------------------------------------------------------

[]{#Questions-18}

  ------------------------------------------------------ ------------------------------------------------------------ --- --------------------------------------------------------------------------------- -------------------------------------------- --------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Masks "Previous section in reading order")\]   \[[\>](#More-data-types "Next section in reading order")\]       \[[\<\<](#Advanced-operators "Beginning of this chapter or previous chapter")\]   \[[Up](#Advanced-operators "Up section")\]   \[[\>\>](#More-data-types "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ------------------------------------------------------ ------------------------------------------------------------ --- --------------------------------------------------------------------------------- -------------------------------------------- --------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Questions-18-1}

18.4 Questions 18 {#questions-18 .section}
-----------------

1.  Hidden operators can be used in return statements, for example,

    +-----------------------------------+-----------------------------------+
    |                                   | ``` {.smallexample}               |
    |                                   | return (++x);                     |
    |                                   | ```                               |
    +-----------------------------------+-----------------------------------+

    Would there be any point in writing the following?

    +-----------------------------------+-----------------------------------+
    |                                   | ``` {.smallexample}               |
    |                                   | return (x++);                     |
    |                                   | ```                               |
    +-----------------------------------+-----------------------------------+

2.  What distinguishes a bit string from an ordinary variable? Can any
    variable be a bit string?
3.  What is the difference between an inclusive OR operation and an
    exclusive OR operation?
4.  Find out what the decimal values of the following operations are.

    1.  `7 & 2`
    2.  `1 & 1`
    3.  `15 & 3`
    4.  `15 & 7`
    5.  `15 & 7 & 3`

    Try to explain the results. (Hint: sketch out the numbers as bit
    strings.)

5.  Find out what the decimal values of the following operations are.
    1.  `1 | 2`
    2.  `1 | 2 | 3`
6.  Find out the decimal values of the following operations.

    1.  `1 & (~1)`
    2.  `23 & (~23)`
    3.  `2012 & (~2012)`

    (Hint: write a short program to work them out.)

------------------------------------------------------------------------

[]{#More-data-types}

  ------------------------------------------------------------- ------------------------------------------------- --- --------------------------------------------------------------------------------- ----------------------------- --------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Questions-18 "Previous section in reading order")\]   \[[\>](#enum "Next section in reading order")\]       \[[\<\<](#Advanced-operators "Beginning of this chapter or previous chapter")\]   \[[Up](#Top "Up section")\]   \[[\>\>](#Data-structures "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ------------------------------------------------------------- ------------------------------------------------- --- --------------------------------------------------------------------------------- ----------------------------- --------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#More-data-types-1}

19. More data types {#more-data-types .chapter}
===================

[]{#index-Data-types}

There are still a few data types in C that we have not discussed.
Actually, since C allows you to define new data types at will, no one
can ever cover all possibilities. We will only discuss the most
important examples.

[]{#index-enum-type} []{#index-void-type} []{#index-volatile-type}
[]{#index-const-type}

 `enum`

:   Type specifier for variables that can have a set of different
    values.

 `void`

:   Type specifier for "empty" data.

 `volatile`

:   Type qualifier for data that changes independently of the program.

 `const`

:   Type qualifier for data that cannot change.

[]{#index-struct-type} []{#index-union-type}

In addition, there are two data types called `struct` and `union` that
are so important, they have received their own chapter. (See section
[Data structures](#Data-structures), for more information on `struct`
and `union`.)

  ------------------------------------------------ ---- --
  [19.1 `enum`](#enum)                                  
  [19.2 `void`](#void)                                  
  [19.3 `volatile`](#volatile)                          
  [19.4 Constants](#Constants)                          
  [19.5 `struct` and `union`](#struct-and-union)        
  [19.6 `typedef`](#typedef)                            
  [19.7 Questions 19](#Questions-19)                    
  ------------------------------------------------ ---- --

------------------------------------------------------------------------

[]{#enum}

  ---------------------------------------------------------------- ------------------------------------------------- --- ------------------------------------------------------------------------------ ----------------------------------------- --------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#More-data-types "Previous section in reading order")\]   \[[\>](#void "Next section in reading order")\]       \[[\<\<](#More-data-types "Beginning of this chapter or previous chapter")\]   \[[Up](#More-data-types "Up section")\]   \[[\>\>](#Data-structures "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ---------------------------------------------------------------- ------------------------------------------------- --- ------------------------------------------------------------------------------ ----------------------------------------- --------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#enum-1}

19.1 `enum` {#enum .section}
-----------

[]{#index-enum-type-1}

The `enum` type specifier is short for "enumerated data". The user can
define a fixed set of words that a variable of type `enum` can take as
its value. The words are assigned integer values by the compiler so that
code can compare `enum` variables. Consider the following code example:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | #include <stdio.h>                |
|                                   |                                   |
|                                   | /* To shorten example, not using  |
|                                   | argp */                           |
|                                   | int main ()                       |
|                                   | {                                 |
|                                   |   enum compass_direction          |
|                                   |   {                               |
|                                   |     north,                        |
|                                   |     east,                         |
|                                   |     south,                        |
|                                   |     west                          |
|                                   |   };                              |
|                                   |                                   |
|                                   |   enum compass_direction my_direc |
|                                   | tion;                             |
|                                   |   my_direction = west;            |
|                                   |                                   |
|                                   |   return 0;                       |
|                                   | }                                 |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

This example defines an enumerated variable type called
`compass_direction`, which can be assigned one of four enumerated
values: `north`, `east`, `south`, or `west`. It then declares a variable
called `my_direction` of the enumerated `compass_direction` type, and
assigns `my_direction` the value `west`.

Why go to all this trouble? Because enumerated data types allow the
programmer to forget about any numbers that the computer might need in
order to process a list of words, and simply concentrate on using the
words themselves. It's a higher-level way of doing things; in fact, at a
lower level, the computer assigns each possible value in an enumerated
data type an integer cconstant --- one that you do not need to worry
about.

Enumerated variables have a natural partner in the `switch` statement,
as in the following code example.

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | #include <stdio.h>                |
|                                   |                                   |
|                                   | enum compass_direction            |
|                                   | {                                 |
|                                   |   north,                          |
|                                   |   east,                           |
|                                   |   south,                          |
|                                   |   west                            |
|                                   | };                                |
|                                   | ```                               |
|                                   |                                   |
|                                   | ``` {.smallexample}               |
|                                   | ```                               |
|                                   |                                   |
|                                   | ``` {.smallexample}               |
|                                   | enum compass_direction get_direct |
|                                   | ion()                             |
|                                   | {                                 |
|                                   |   return south;                   |
|                                   | }                                 |
|                                   | ```                               |
|                                   |                                   |
|                                   | ``` {.smallexample}               |
|                                   | ```                               |
|                                   |                                   |
|                                   | ``` {.smallexample}               |
|                                   | /* To shorten example, not using  |
|                                   | argp */                           |
|                                   | int main ()                       |
|                                   | {                                 |
|                                   |   enum compass_direction my_direc |
|                                   | tion;                             |
|                                   |   puts ("Which way are you going? |
|                                   | ");                               |
|                                   |   my_direction = get_direction(); |
|                                   |                                   |
|                                   |   switch (my_direction)           |
|                                   |   {                               |
|                                   |     case north:                   |
|                                   |       puts("North? Say hello to t |
|                                   | he polar bears!");                |
|                                   |       break;                      |
|                                   | ```                               |
|                                   |                                   |
|                                   | ``` {.smallexample}               |
|                                   | ```                               |
|                                   |                                   |
|                                   | ``` {.smallexample}               |
|                                   |     case south:                   |
|                                   |       puts("South? Say hello to T |
|                                   | ux the penguin!");                |
|                                   |       break;                      |
|                                   | ```                               |
|                                   |                                   |
|                                   | ``` {.smallexample}               |
|                                   | ```                               |
|                                   |                                   |
|                                   | ``` {.smallexample}               |
|                                   |     case east:                    |
|                                   |       puts("If you go far enough  |
|                                   | east, you'll be west!");          |
|                                   |       break;                      |
|                                   |                                   |
|                                   |     case west:                    |
|                                   |       puts("If you go far enough  |
|                                   | west, you'll be east!");          |
|                                   |       break;                      |
|                                   |   }                               |
|                                   |                                   |
|                                   |   return 0;                       |
|                                   | }                                 |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

In this example, the `compass_direction` type has been made global, so
that the `get_direction` function can return that type. The `main`
function prompts the user, 'Which way are you going?', then calls the
"dummy" function `get_direction`. In a "real" program, such a function
would accept input from the user and return an enumerated value to
`main`, but in this case it merely returns the value `south`. The output
from this code example is therefore as follows:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | Which way are you going?          |
|                                   | South? Say hello to Tux the pengu |
|                                   | in!                               |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

As mentioned above, enumerated values are converted into integer values
internally by the compiler. It is practically never necessary to know
what integer values the compiler assigns to the enumerated words in the
list, but it may be useful to know the order of the enumerated items
with respect to one another. The following code example demonstrates
this.

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | #include <stdio.h>                |
|                                   |                                   |
|                                   | /* To shorten example, not using  |
|                                   | argp */                           |
|                                   | int main ()                       |
|                                   | {                                 |
|                                   |   enum planets                    |
|                                   |   {                               |
|                                   |     Mercury,                      |
|                                   |     Venus,                        |
|                                   |     Earth,                        |
|                                   |     Mars,                         |
|                                   |     Jupiter,                      |
|                                   |     Saturn,                       |
|                                   |     Uranus,                       |
|                                   |     Neptune,                      |
|                                   |     Pluto                         |
|                                   |   };                              |
|                                   | ```                               |
|                                   |                                   |
|                                   | ``` {.smallexample}               |
|                                   | ```                               |
|                                   |                                   |
|                                   | ``` {.smallexample}               |
|                                   |   enum planets planet1, planet2;  |
|                                   |                                   |
|                                   |   planet1 = Mars;                 |
|                                   |   planet2 = Earth;                |
|                                   |                                   |
|                                   |   if (planet1 > planet2)          |
|                                   |     puts ("Mars is farther from t |
|                                   | he Sun than Earth is.");          |
|                                   |   else                            |
|                                   |     puts ("Earth is farther from  |
|                                   | the Sun than Mars is.");          |
|                                   |                                   |
|                                   |   return 0;                       |
|                                   | }                                 |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

The output from this example reads as follows:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | Mars is farther from the Sun than |
|                                   |  Earth is.                        |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

------------------------------------------------------------------------

[]{#void}

  ----------------------------------------------------- ----------------------------------------------------- --- ------------------------------------------------------------------------------ ----------------------------------------- --------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#enum "Previous section in reading order")\]   \[[\>](#volatile "Next section in reading order")\]       \[[\<\<](#More-data-types "Beginning of this chapter or previous chapter")\]   \[[Up](#More-data-types "Up section")\]   \[[\>\>](#Data-structures "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ----------------------------------------------------- ----------------------------------------------------- --- ------------------------------------------------------------------------------ ----------------------------------------- --------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#void-1}

19.2 `void` {#void .section}
-----------

[]{#index-void-type-1}

The `void` data type was introduced to make C syntactically consistent.
The main reason for `void` is to declare functions that have no return
value. The word "void" is therefore used in the sense of "empty" rather
than that of "invalid".

C functions are considered by the compiler to return type `int` unless
otherwise specified. Although the data returned by a function can
legally be ignored by the function calling it, the `void` data type was
introduced by the ANSI standard so that C compilers can issue warnings
when an integer value is not returned by a function that is supposed to
return one. If you want to write a function that does not return a
value, simply declare it `void`. A function declared `void` has no
return value and simply returns with the command `return;`.

Variables can be declared `void` as well as functions:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | void my_variable;                 |
|                                   | void *my_pointer;                 |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

A variable that is itself declared `void` (such as `my_variable` above)
is useless; it cannot be assigned a value, cannot be cast to another
type, in fact, cannot be used in any way.

Void pointers (type `void *`) are a different case, however. A void
pointer is a *generic pointer*; any pointer can be cast to a void
pointer and back without any loss of information. Any type of pointer
can be assigned to (or compared with) a void pointer, without casting
the pointer explicitly.

Finally, a function call can be cast to `void` in order to explicitly
discard a return value. For example, `printf` returns a value, but it is
seldom used. Nevertheless, the two lines of code that follow are
equivalent:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | printf ("Hullo!\n");              |
|                                   | (void) printf ("Hullo!\n");       |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

There is no good reason to prefer the second line to the first, however,
so using the more concise form is preferred.

------------------------------------------------------------------------

[]{#volatile}

  ----------------------------------------------------- ------------------------------------------------------ --- ------------------------------------------------------------------------------ ----------------------------------------- --------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#void "Previous section in reading order")\]   \[[\>](#Constants "Next section in reading order")\]       \[[\<\<](#More-data-types "Beginning of this chapter or previous chapter")\]   \[[Up](#More-data-types "Up section")\]   \[[\>\>](#Data-structures "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ----------------------------------------------------- ------------------------------------------------------ --- ------------------------------------------------------------------------------ ----------------------------------------- --------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#volatile-1}

19.3 `volatile` {#volatile .section}
---------------

[]{#index-volatile-type-1}

The `volatile` type qualifier was introduced by the ANSI Standard to
permit the use of *memory-mapped variables*, that is, variables whose
value changes autonomously based on input from hardware. One might
declare a volatile variable `volatile float temperature;` whose value
fluctuated according to readings from a digital thermometer connected to
the computer.

There is another use for the `volatile` qualifier that has to do with
multiprocessing operating systems. Independent processes that share
common memory might each change the value of a variable independently.
The `volatile` keyword serves as a warning to the compiler that it
should not *optimize* the code containing the variable (that is, compile
it so that it will run in the most efficient way possible) by storing
the value of the variable and referring to it repeatedly, but should
reread the value of the variable every time. (Volatile variables are
also flagged by the compiler as not to be stored in read-only memory.)

------------------------------------------------------------------------

[]{#Constants}

  --------------------------------------------------------- -------------------------------------------------- --- ------------------------------------------------------------------------------ ----------------------------------------- --------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#volatile "Previous section in reading order")\]   \[[\>](#const "Next section in reading order")\]       \[[\<\<](#More-data-types "Beginning of this chapter or previous chapter")\]   \[[Up](#More-data-types "Up section")\]   \[[\>\>](#Data-structures "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  --------------------------------------------------------- -------------------------------------------------- --- ------------------------------------------------------------------------------ ----------------------------------------- --------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Constants-1}

19.4 Constants {#constants .section}
--------------

[]{#index-Constants} []{#index-const-type-1}

*Constants* in C usually refer to two things: either a type of variable
whose value cannot change declared with the `const` qualifier (in this
case, "variable" is something of a misnomer), or a string or numeric
value incorporated directly into C code, such as '1000'. We will examine
both kinds of constant in the next two sections.

  ------------------------------------------------------ ---- --
  [19.4.1 `const`](#const)                                    
  [19.4.2 Constant expressions](#Constant-expressions)        
  ------------------------------------------------------ ---- --

------------------------------------------------------------------------

[]{#const}

  ---------------------------------------------------------- ----------------------------------------------------------------- --- ------------------------------------------------------------------------------ ----------------------------------- --------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Constants "Previous section in reading order")\]   \[[\>](#Constant-expressions "Next section in reading order")\]       \[[\<\<](#More-data-types "Beginning of this chapter or previous chapter")\]   \[[Up](#Constants "Up section")\]   \[[\>\>](#Data-structures "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ---------------------------------------------------------- ----------------------------------------------------------------- --- ------------------------------------------------------------------------------ ----------------------------------- --------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#const-1}

### 19.4.1 `const` {#const .subsection}

[]{#index-const-type-2}

Sometime a variable must be assigned a value once and once only; for
example, it might be in read-only memory. The reserved word `const` is,
like `static` and `volatile`, a data type qualifier that can be applied
to many different data types. It declares a variable to be a constant,
whose value cannot be reassigned. A `const` must be assigned a value
when it is declared.

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | const double avogadro = 6.02e23;  |
|                                   | const int moon_landing = 1969;    |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

You can also declare constant arrays:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | const int my_array[] =            |
|                                   | {0, 1, 2, 3, 4, 5, 6, 7, 8};      |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

Any attempt to assign a new value to a `const` variable will result in a
compile-time error such as the following:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | const.c: In function `main':      |
|                                   | const.c:11: warning: assignment o |
|                                   | f read-only variable `avogadro'   |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

------------------------------------------------------------------------

[]{#Constant-expressions}

  ------------------------------------------------------ ------------------------------------------------------------- --- ------------------------------------------------------------------------------ ----------------------------------- --------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#const "Previous section in reading order")\]   \[[\>](#struct-and-union "Next section in reading order")\]       \[[\<\<](#More-data-types "Beginning of this chapter or previous chapter")\]   \[[Up](#Constants "Up section")\]   \[[\>\>](#Data-structures "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ------------------------------------------------------ ------------------------------------------------------------- --- ------------------------------------------------------------------------------ ----------------------------------- --------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Constant-expressions-1}

### 19.4.2 Constant expressions {#constant-expressions .subsection}

[]{#index-Constant-expressions} []{#index-Expressions_002c-constant}

You can declare constant expressions explicitly as a particular type of
value, such as a long integer, a float, a character, or a hexadecimal
value, with certain typographical conventions. For example, it is
possible to declare a value explicitly as a long by placing the letter
'L' after the numeric constant. For example:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | #define MY_LONG1 23L;             |
|                                   | #define MY_LONG2 236526598L;      |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

Similarly, you can declare a value to be a float by appending the letter
'F' to it. Of course, numeric constants containing a decimal point are
automatically considered floats. The following constants are both
floating-point numbers:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | #define MY_FLOAT1 23F;            |
|                                   | #define MY_FLOAT2 23.5001;        |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

You can declare a hexadecimal (base-16) number by prefixing it with
'0x'; you can declare an octal (base-8) number by prefixing it with '0'.
For example:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | int my_hex_integer = 0xFF;   /* h |
|                                   | ex FF */                          |
|                                   | int my_octal_integer = 077;  /* o |
|                                   | ctal 77 */                        |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

You can use this sort of notation with strings and character constants
too. ASCII character values range from 0 to 255. You can print any
character in this range by prefixing a hexadecimal value with '\\x' or
an octal value with '\\'. Consider the following code example, which
demonstrates how to print the letter 'A', using either a hexadecimal
character code ('\\x41') or an octal one ('\\101').

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | #include <stdio.h>                |
|                                   |                                   |
|                                   | /* To shorten example, not using  |
|                                   | argp */                           |
|                                   | int main ()                       |
|                                   | {                                 |
|                                   |   printf ("\\x41 hex   = \x41\n") |
|                                   | ;                                 |
|                                   |   printf ("\\101 octal = \101\n") |
|                                   | ;                                 |
|                                   |                                   |
|                                   |   return 0;                       |
|                                   | }                                 |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

The preceding code prints the following text:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | \x41 hex   = A                    |
|                                   | \101 octal = A                    |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

Of course, you can assign a variable declared with the `const` qualifier
(the first kind of "constant" we examined) a constant expression
declared with one of the typographical expressions above. For example:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | const int my_hex_integer = 0xFF;  |
|                                   |   /* hex FF */                    |
|                                   | const int my_octal_integer = 077; |
|                                   |   /* octal 77 */                  |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

------------------------------------------------------------------------

[]{#struct-and-union}

  --------------------------------------------------------------------- ---------------------------------------------------- --- ------------------------------------------------------------------------------ ----------------------------------------- --------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Constant-expressions "Previous section in reading order")\]   \[[\>](#typedef "Next section in reading order")\]       \[[\<\<](#More-data-types "Beginning of this chapter or previous chapter")\]   \[[Up](#More-data-types "Up section")\]   \[[\>\>](#Data-structures "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  --------------------------------------------------------------------- ---------------------------------------------------- --- ------------------------------------------------------------------------------ ----------------------------------------- --------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#struct-and-union-1}

19.5 `struct` and `union` {#struct-and-union .section}
-------------------------

[]{#index-struct-type-1} []{#index-union-type-1}

Structures and unions are data types that are important enough to merit
a chapter of their own. See section [Data structures](#Data-structures),
for more information on structures and unions.

------------------------------------------------------------------------

[]{#typedef}

  ----------------------------------------------------------------- --------------------------------------------------------- --- ------------------------------------------------------------------------------ ----------------------------------------- --------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#struct-and-union "Previous section in reading order")\]   \[[\>](#Questions-19 "Next section in reading order")\]       \[[\<\<](#More-data-types "Beginning of this chapter or previous chapter")\]   \[[Up](#More-data-types "Up section")\]   \[[\>\>](#Data-structures "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ----------------------------------------------------------------- --------------------------------------------------------- --- ------------------------------------------------------------------------------ ----------------------------------------- --------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#typedef-1}

19.6 `typedef` {#typedef .section}
--------------

[]{#index-typedef-command}

You can define your own data types in C with the `typedef` command,
which may be written inside functions or in global scope. This statement
is used as follows:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | typedef existing_type new_type;   |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

You can then use the new type to declare variables, as in the following
code example, which declares a new type called `my_type` and declares
three variables to be of that type.

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | #include <stdio.h>                |
|                                   |                                   |
|                                   | /* To shorten example, not using  |
|                                   | argp */                           |
|                                   | int main (int argc, char *argv[], |
|                                   |  char *envp[])                    |
|                                   | {                                 |
|                                   |   typedef int my_type;            |
|                                   |   my_type var1, var2, var3;       |
|                                   |                                   |
|                                   |   var1 = 10;                      |
|                                   |   var2 = 20;                      |
|                                   |   var3 = 30;                      |
|                                   |                                   |
|                                   |   return 0;                       |
|                                   | }                                 |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

The new type called `my_type` behaves just like an integer. Why, then,
would we use it instead of `integer`?

Actually, you will seldom wish to rename an existing data type. The most
important use for `typedef` is in renaming structures and unions, whose
names can become long and tedious to declare otherwise. We'll
investigate structures and unions in the next chapter. (See section
[Data structures](#Data-structures).)

------------------------------------------------------------------------

[]{#Questions-19}

  -------------------------------------------------------- ------------------------------------------------------------ --- ------------------------------------------------------------------------------ ----------------------------------------- --------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#typedef "Previous section in reading order")\]   \[[\>](#Data-structures "Next section in reading order")\]       \[[\<\<](#More-data-types "Beginning of this chapter or previous chapter")\]   \[[Up](#More-data-types "Up section")\]   \[[\>\>](#Data-structures "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  -------------------------------------------------------- ------------------------------------------------------------ --- ------------------------------------------------------------------------------ ----------------------------------------- --------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Questions-19-1}

19.7 Questions 19 {#questions-19 .section}
-----------------

1.  Enumerated names are given integer values by the compiler so that it
    can do multiplication and division with them. True or false?
2.  Does `void` do anything which C cannot already do without this type?
3.  What type qualifier might a variable accessed directly by a timer be
    given?
4.  Write a statement which declares a new type \"real\" to be like the
    usual type \"double\".
5.  Variables declared with the qualifier `const` can be of any type.
    True or false?

------------------------------------------------------------------------

[]{#Data-structures}

  ------------------------------------------------------------- --------------------------------------------------- --- ------------------------------------------------------------------------------ ----------------------------- --------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Questions-19 "Previous section in reading order")\]   \[[\>](#struct "Next section in reading order")\]       \[[\<\<](#More-data-types "Beginning of this chapter or previous chapter")\]   \[[Up](#Top "Up section")\]   \[[\>\>](#Recursion "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ------------------------------------------------------------- --------------------------------------------------- --- ------------------------------------------------------------------------------ ----------------------------- --------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Data-structures-1}

20. Data structures {#data-structures .chapter}
===================

*Grouping data. Tidying up programs.*

[]{#index-Data-structures} []{#index-Structures_002c-data}

It would be hard for a program to manipulate data if it were scattered
around with no particular structure. C therefore has several facilities
to group data together in convenient packages, or *data structures*. One
type of data structure in C is the `struct` (or *structure*) data type,
which is a group of variables clustered together with a common name. A
related data type is the `union`, which can contain any type of
variable, but only one at a time. Finally, structures and unions can be
linked together into complex data structures such as lists and trees.
This chapter explores all of these kinds of data structure.

[]{#index-Data-structures_002c-as-distinguished-from-structures}
[]{#index-Structures_002c-as-distinguished-from-data-structures}

It is important to distinguish the terms *structure* and *data
structure*. "Data structure" is a generic term that refers to any
pattern of data in a computer program. An array is a data structure, as
is a string. A structure is a particular data type in C, the `struct`;
all `struct` variables (structures) are data structures, but not all
data structures are structures.

  -------------------------------------------------------------------------- ---- --
  [20.1 `struct`](#struct)                                                        
  [20.2 Memory allocation](#Memory-allocation)                                    
  [20.3 `union`](#union)                                                          
  [20.4 Complex data structures](#Complex-data-structures)                        
  [20.5 Further data structure examples](#Further-data-structure-examples)        
  [20.6 Questions 20](#Questions-20)                                              
  -------------------------------------------------------------------------- ---- --

------------------------------------------------------------------------

[]{#struct}

  ---------------------------------------------------------------- ------------------------------------------------------------------- --- ------------------------------------------------------------------------------ ----------------------------------------- --------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Data-structures "Previous section in reading order")\]   \[[\>](#Structure-declarations "Next section in reading order")\]       \[[\<\<](#Data-structures "Beginning of this chapter or previous chapter")\]   \[[Up](#Data-structures "Up section")\]   \[[\>\>](#Recursion "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ---------------------------------------------------------------- ------------------------------------------------------------------- --- ------------------------------------------------------------------------------ ----------------------------------------- --------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#struct-1}

20.1 `struct` {#struct .section}
-------------

[]{#index-Structures} []{#index-struct-type-2}

A *structure* is a group of one or more variables under a single name.
Unlike arrays, structures can contain a combination of different types
of data; they can even contain arrays. A structure can be arbitrarily
complex.

[]{#index-Members-of-structures} []{#index-Structures_002c-members-of}

Every type of structure that is defined is given a name, and the
variables it contains (called *members*) are also given names. Finally,
every variable declared to be of a particular structure type has its own
name as well, just as any other variable does.

  ------------------------------------------------------------ ---- --
  [20.1.1 Structure declarations](#Structure-declarations)          
  [20.1.2 Using structures](#Using-structures)                      
  [20.1.3 Arrays of structures](#Arrays-of-structures)              
  [20.1.4 Nested structures](#Nested-structures)                    
  [20.1.5 Pointers to structures](#Pointers-to-structures)          
  [20.1.6 Initializing structures](#Initializing-structures)        
  ------------------------------------------------------------ ---- --

------------------------------------------------------------------------

[]{#Structure-declarations}

  ------------------------------------------------------- --------------------------------------------------------------------------------- --- ------------------------------------------------------------------------------ -------------------------------- --------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#struct "Previous section in reading order")\]   \[[\>](#Structure-declarations-using-typedef "Next section in reading order")\]       \[[\<\<](#Data-structures "Beginning of this chapter or previous chapter")\]   \[[Up](#struct "Up section")\]   \[[\>\>](#Recursion "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ------------------------------------------------------- --------------------------------------------------------------------------------- --- ------------------------------------------------------------------------------ -------------------------------- --------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Structure-declarations-1}

### 20.1.1 Structure declarations {#structure-declarations .subsection}

[]{#index-Declaring-structures} []{#index-Structures_002c-declaring}

The following statement is a type declaration, so it belongs with other
declarations, either at the start of a program or the start of a code
block.

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | struct personal_data              |
|                                   | {                                 |
|                                   |   char name[100];                 |
|                                   |   char address[200];              |
|                                   |   int year_of_birth;              |
|                                   |   int month_of_birth;             |
|                                   |   int day_of_birth;               |
|                                   | };                                |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

The statement says: define a type of variable that holds a string of 100
characters called `name`, a string of 200 characters called `address`,
and three integers called `year_of_birth`, `month_of_birth`, and
`day_of_birth`. Any variable declared to be of type
`struct personal_data` will contain these components, which are called
*members*. Different structures, even different *types* of structure,
can have members with the same name, but the values of members of
different structures are independent of one another. You can also use
the same name for a member as for an ordinary variable in your program,
but the computer will recognize them as different entities, with
different values. This is similar to the naming convention for humans,
where two different men may share the name \"John Smith\", but are
recognized as being different people.

Once you have declared a type of structure, you can declare variables to
be of that type. For example:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | struct personal_data person0001;  |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

The statement above declares a variable called `person0001` to be of
type `struct personal_data`. This is probably the most common method of
declaring a structure variable, but there are two equivalent methods.
For example, a structure variable can be declared immediately after the
declaration of the structure type:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | struct personal_data              |
|                                   | {                                 |
|                                   |   char name[100];                 |
|                                   |   char address[200];              |
|                                   |   int year_of_birth;              |
|                                   |   int month_of_birth;             |
|                                   |   int day_of_birth;               |
|                                   | } person0001;                     |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

  ---------------------------------------------------------------------------------------- ---- --
  [20.1.1.1 Structure declarations using typedef](#Structure-declarations-using-typedef)        
  ---------------------------------------------------------------------------------------- ---- --

------------------------------------------------------------------------

[]{#Structure-declarations-using-typedef}

  ----------------------------------------------------------------------- ------------------------------------------------------------- --- ------------------------------------------------------------------------------ ------------------------------------------------ --------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Structure-declarations "Previous section in reading order")\]   \[[\>](#Using-structures "Next section in reading order")\]       \[[\<\<](#Data-structures "Beginning of this chapter or previous chapter")\]   \[[Up](#Structure-declarations "Up section")\]   \[[\>\>](#Recursion "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ----------------------------------------------------------------------- ------------------------------------------------------------- --- ------------------------------------------------------------------------------ ------------------------------------------------ --------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Structure-declarations-using-typedef-1}

#### 20.1.1.1 Structure declarations using typedef {#structure-declarations-using-typedef .subsubsection}

[]{#index-Declaring-structures-with-typedef}
[]{#index-typedef_002c-declaring-structures-with}
[]{#index-Structures_002c-declaring-with-typedef}

Alternatively, the `typedef` command can be used to cut down on typing
out code in the long term. The type definition is made once at the start
of the program and subsequent variable declarations are made by using
the new name, without the word `struct`:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | typedef struct                    |
|                                   | {                                 |
|                                   |   char name[100];                 |
|                                   |   char address[200];              |
|                                   |   int year_of_birth;              |
|                                   |   int month_of_birth;             |
|                                   |   int day_of_birth;               |
|                                   | } personal_data;                  |
|                                   |                                   |
|                                   | personal_data person001;          |
|                                   | personal_data person002;          |
|                                   | personal_data person003;          |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

Note that this use of the `typedef` command parallels the usage we have
already seen:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | typedef existing_type new_type    |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

In the example above of using `typedef` to declare a new type of
structure, the metasyntactic variable new\_type corresponds to the
identifier `personal_data`, and the metasyntactic variable
existing\_type corresponds to the following code:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | struct                            |
|                                   | {                                 |
|                                   |   char name[100];                 |
|                                   |   char address[200];              |
|                                   |   int year_of_birth;              |
|                                   |   int month_of_birth;             |
|                                   |   int day_of_birth;               |
|                                   | }                                 |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

Structure type and variable declarations can be either local or global,
depending on their placement in the code, just as any other declaration
can be.

------------------------------------------------------------------------

[]{#Using-structures}

  ------------------------------------------------------------------------------------- ----------------------------------------------------------------- --- ------------------------------------------------------------------------------ -------------------------------- --------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Structure-declarations-using-typedef "Previous section in reading order")\]   \[[\>](#Arrays-of-structures "Next section in reading order")\]       \[[\<\<](#Data-structures "Beginning of this chapter or previous chapter")\]   \[[Up](#struct "Up section")\]   \[[\>\>](#Recursion "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ------------------------------------------------------------------------------------- ----------------------------------------------------------------- --- ------------------------------------------------------------------------------ -------------------------------- --------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Using-structures-1}

### 20.1.2 Using structures {#using-structures .subsection}

[]{#index-Structures_002c-using} []{#index-Using-structures}

Structures are extremely powerful data types. Not only can you pass a
whole structure as a parameter to a function, or return one as a value
from a function. You can even assign one structure to another.

[]{#index-_002e-dot-operator-of-structures}
[]{#index-Structures_002c-_002e-dot-operator}
[]{#index-Member-operator-of-structures}
[]{#index-Structures_002c-member-operator-of}

You can get and set the values of the members of a structure with the
'.' dot character. This is called the *member operator*. The general
form of a member reference is:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | structure_name.member_name        |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

In the following example, the year 1852 is assigned to the
`year_of_birth` member of the structure variable `person1`, of type
`struct personal_data`. Similarly, month 5 is assigned to the
`month_of_birth` member, and day 4 is assigned to the `day_of_birth`
member.

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | struct personal_data person1;     |
|                                   |                                   |
|                                   | person1.year_of_birth = 1852;     |
|                                   | person1.month_of_birth = 5;       |
|                                   | person1.day_of_birth = 4;         |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

[]{#index-_002d_003e-dot-operator-of-structures}
[]{#index-Structures_002c-_002d_003e-operator}
[]{#index-Member-operator-of-structures-1}
[]{#index-Structures_002c-member-operator-of-1}

Besides the dot operator, C also provides a special `->` member operator
for use in conjunction with pointers, because pointers and structures
are used together so often. (See section [Pointers to
structures](#Pointers-to-structures).)

Structures are easy to use For example, you can assign one structure to
another structure of the same type (unlike strings, for example, which
must use the string library routine `strcpy`). Here is an example of
assigning one structure to another:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | struct personal_data person1, per |
|                                   | son2;                             |
|                                   |                                   |
|                                   | person2 = person1;                |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

The members of the `person2` variable now contain all the data of the
members of the `person1` variable.

Structures are passed as parameters in the usual way:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | my_structure_fn (person2);        |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

You would declare such a function thus:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | void my_structure_fn (struct pers |
|                                   | onal_data some_struct)            |
|                                   | {                                 |
|                                   | }                                 |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

Note that in order to declare this function, the `struct personal_data`
type must be declared globally.

Finally, a function that returns a structure variable would be declared
thusly:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | struct personal_data structure_re |
|                                   | turning_fn ()                     |
|                                   | {                                 |
|                                   |   struct personal_data random_per |
|                                   | son;                              |
|                                   |   return random_person;           |
|                                   | }                                 |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

Of course, `random_person` is a good name for the variable returned by
this bare-bones function, because without unless one writes code to
initialize it, it can only be filled with garbage values.

------------------------------------------------------------------------

[]{#Arrays-of-structures}

  ----------------------------------------------------------------- -------------------------------------------------------------- --- ------------------------------------------------------------------------------ -------------------------------- --------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Using-structures "Previous section in reading order")\]   \[[\>](#Nested-structures "Next section in reading order")\]       \[[\<\<](#Data-structures "Beginning of this chapter or previous chapter")\]   \[[Up](#struct "Up section")\]   \[[\>\>](#Recursion "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ----------------------------------------------------------------- -------------------------------------------------------------- --- ------------------------------------------------------------------------------ -------------------------------- --------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Arrays-of-structures-1}

### 20.1.3 Arrays of structures {#arrays-of-structures .subsection}

[]{#index-Arrays-of-structures} []{#index-Structures_002c-arrays-of}

Just as arrays of basic types such as integers and floats are allowed in
C, so are arrays of structures. An array of structures is declared in
the usual way:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | struct personal_data my_struct_ar |
|                                   | ray[100];                         |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

The members of the structures in the array are then accessed by
statements such as the following:

The value of a member of a structure in an array can be assigned to
another variable, or the value of a variable can be assigned to a
member. For example, the following code assigns the number 1965 to the
`year_of_birth` member of the fourth element of `my_struct_array`:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | my_struct_array[3].year_of_birth  |
|                                   | = 1965;                           |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

(Like all other arrays in C, `struct` arrays start their numbering at
zero.)

The following code assigns the value of the `year_of_birth` member of
the fourth element of `my_struct_array` to the variable `yob`:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | yob = my_struct_array[3].year_of_ |
|                                   | birth;                            |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

Finally, the following example assigns the values of all the members of
the second element of `my_struct_array`, namely `my_struct_array[1]`, to
the third element, so `my_struct_array[2]` takes the overall value of
`my_struct_array[1]`.

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | my_struct_array[2] = my_struct_ar |
|                                   | ray[1];                           |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

------------------------------------------------------------------------

[]{#Nested-structures}

  --------------------------------------------------------------------- ------------------------------------------------------------------- --- ------------------------------------------------------------------------------ -------------------------------- --------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Arrays-of-structures "Previous section in reading order")\]   \[[\>](#Pointers-to-structures "Next section in reading order")\]       \[[\<\<](#Data-structures "Beginning of this chapter or previous chapter")\]   \[[Up](#struct "Up section")\]   \[[\>\>](#Recursion "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  --------------------------------------------------------------------- ------------------------------------------------------------------- --- ------------------------------------------------------------------------------ -------------------------------- --------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Nested-structures-1}

### 20.1.4 Nested structures {#nested-structures .subsection}

[]{#index-Nested-structures} []{#index-Structures_002c-nested}

Structures can contain other structures as members; in other words,
structures can *nest*. Consider the following two structure types:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | struct first_structure_type       |
|                                   | {                                 |
|                                   |   int integer_member;             |
|                                   |   float float_member;             |
|                                   | };                                |
|                                   |                                   |
|                                   | struct second_structure_type      |
|                                   | {                                 |
|                                   |   double double_member;           |
|                                   |   struct first_structure_type str |
|                                   | uct_member;                       |
|                                   | };                                |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

The first structure type is incorporated as a member of the second
structure type. You can initialize a variable of the second type as
follows:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | struct second_structure_type demo |
|                                   | ;                                 |
|                                   |                                   |
|                                   | demo.double_member = 12345.6789;  |
|                                   | demo.struct_member.integer_member |
|                                   |  = 5;                             |
|                                   | demo.struct_member.float_member = |
|                                   |  1023.17;                         |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

The member operator '.' is used to access members of structures that are
themselves members of a larger structure. No parentheses are needed to
force a special order of evaluation; a member operator expression is
simply evaluated from left to right.

In principle, structures can be nested indefinitely. Statements such as
the following are syntactically acceptable, but bad style. (See section
[Style](#Style).)

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | my_structure.member1.member2.memb |
|                                   | er3.member4 = 5;                  |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

What happens if a structure contains an instance of its own type,
however? For example:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | struct regression                 |
|                                   | {                                 |
|                                   |   int int_member;                 |
|                                   |   struct regression self_member;  |
|                                   | };                                |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

In order to compile a statement of this type, your computer would
theoretically need an infinite amount of memory. In practice, however,
you will simply receive an error message along the following lines:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | struct5.c: In function `main':    |
|                                   | struct5.c:8: field `self_member'  |
|                                   | has incomplete type               |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

The compiler is telling you that `self_member` has been declared before
its data type, `regression` has been fully declared --- naturally, since
you're declaring `self_member` in the middle of declaring its own data
type!

------------------------------------------------------------------------

[]{#Pointers-to-structures}

  ------------------------------------------------------------------ -------------------------------------------------------------------- --- ------------------------------------------------------------------------------ -------------------------------- --------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Nested-structures "Previous section in reading order")\]   \[[\>](#Initializing-structures "Next section in reading order")\]       \[[\<\<](#Data-structures "Beginning of this chapter or previous chapter")\]   \[[Up](#struct "Up section")\]   \[[\>\>](#Recursion "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ------------------------------------------------------------------ -------------------------------------------------------------------- --- ------------------------------------------------------------------------------ -------------------------------- --------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Pointers-to-structures-1}

### 20.1.5 Pointers to structures {#pointers-to-structures .subsection}

[]{#index-Pointers-to-structures} []{#index-Structures_002c-pointers-to}

Although a structure cannot contain an instance of its own type, it can
can contain a pointer to another structure of its own type, or even to
itself. This is because a pointer to a structure is not itself a
structure, but merely a variable that holds the address of a structure.
Pointers to structures are quite invaluable, in fact, for building data
structures such as linked lists and trees. (See section [Complex data
structures](#Complex-data-structures).)

A pointer to a structure type variable is declared by a statement such
as the following:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | struct personal_data *my_struct_p |
|                                   | tr;                               |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

The variable `my_struct_ptr` is a pointer to a variable of type
`struct personal_data`. This pointer can be assigned to any other
pointer of the same type, and can be used to access the members of its
structure. According to the rules we have outlined so far, this would
have to be done like so:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | struct personal_data person1;     |
|                                   |                                   |
|                                   | my_struct_ptr = &person1;         |
|                                   | (*my_struct_ptr).day_of_birth = 2 |
|                                   | 3;                                |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

This code example says, in effect, "Let the member `day_of_birth` of the
structure pointed to by `my_struct_ptr` take the value 23." Notice the
use of parentheses to avoid confusion about the precedence of the '\*'
and '.' operators.

There is a better way to write the above code, however, using a new
operator: '-\>'. This is an arrow made out of a minus sign and a greater
than symbol, and it is used as follows:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | my_struct_ptr->day_of_birth = 23; |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

The '-\>' enables you to access the members of a structure directly via
its pointer. This statement means the same as the last line of the
previous code example, but is considerably clearer. The '-\>' operator
will come in very handy when manipulating complex data structures. (See
section [Complex data structures](#Complex-data-structures).)

------------------------------------------------------------------------

[]{#Initializing-structures}

  ----------------------------------------------------------------------- -------------------------------------------------------------- --- ------------------------------------------------------------------------------ -------------------------------- --------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Pointers-to-structures "Previous section in reading order")\]   \[[\>](#Memory-allocation "Next section in reading order")\]       \[[\<\<](#Data-structures "Beginning of this chapter or previous chapter")\]   \[[Up](#struct "Up section")\]   \[[\>\>](#Recursion "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ----------------------------------------------------------------------- -------------------------------------------------------------- --- ------------------------------------------------------------------------------ -------------------------------- --------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Initializing-structures-1}

### 20.1.6 Initializing structures {#initializing-structures .subsection}

[]{#index-Initializing-structures}
[]{#index-Structures_002c-initializing}

In the chapter on arrays, we explored how to initialize an array with
values at compile time. (See section [Initializing
arrays](#Initializing-arrays).) It is also possible to initialize
structures at compile time, as shown below. (This code example also
shows how to dynamically allocate structures with `malloc` and
initialize them with the `->` operator. See section [Memory
allocation](#Memory-allocation), for more information on this
technique.)

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | #include <stdio.h>                |
|                                   |                                   |
|                                   | /* To shorten example, not using  |
|                                   | argp */                           |
|                                   | int main()                        |
|                                   | {                                 |
|                                   |   struct personal_data            |
|                                   |   {                               |
|                                   |     char name[100];               |
|                                   |     char address[200];            |
|                                   |     int year_of_birth;            |
|                                   |     int month_of_birth;           |
|                                   |     int day_of_birth;             |
|                                   |   };                              |
|                                   | ```                               |
|                                   |                                   |
|                                   | ``` {.smallexample}               |
|                                   | ```                               |
|                                   |                                   |
|                                   | ``` {.smallexample}               |
|                                   |   struct personal_data person1 =  |
|                                   |   {                               |
|                                   |     "Liddell, Alice",             |
|                                   |     "Wonderland",                 |
|                                   |     1852,                         |
|                                   |     5,                            |
|                                   |     4                             |
|                                   |   };                              |
|                                   | ```                               |
|                                   |                                   |
|                                   | ``` {.smallexample}               |
|                                   | ```                               |
|                                   |                                   |
|                                   | ``` {.smallexample}               |
|                                   |   struct personal_data person2 =  |
|                                   |   {                               |
|                                   |     "Hale-Evans, Ron",            |
|                                   |     "Seattle, Washington",        |
|                                   |     1965,                         |
|                                   |     6,                            |
|                                   |     27                            |
|                                   |   };                              |
|                                   | ```                               |
|                                   |                                   |
|                                   | ``` {.smallexample}               |
|                                   | ```                               |
|                                   |                                   |
|                                   | ``` {.smallexample}               |
|                                   |   struct personal_data* person_pt |
|                                   | r1;                               |
|                                   |   struct personal_data* person_pt |
|                                   | r2;                               |
|                                   |                                   |
|                                   |   person_ptr1 = (struct personal_ |
|                                   | data*)                            |
|                                   |     malloc (sizeof (struct person |
|                                   | al_data));                        |
|                                   |                                   |
|                                   |   strcpy (person_ptr1->name, "Ada |
|                                   | ms, Douglas");                    |
|                                   |   strcpy (person_ptr1->address, " |
|                                   | The Galaxy");                     |
|                                   |   person_ptr1->year_of_birth = 19 |
|                                   | 52;                               |
|                                   |   person_ptr1->month_of_birth = 3 |
|                                   | ;                                 |
|                                   |   /* Don't know his exact birthda |
|                                   | y */                              |
|                                   | ```                               |
|                                   |                                   |
|                                   | ``` {.smallexample}               |
|                                   | ```                               |
|                                   |                                   |
|                                   | ``` {.smallexample}               |
|                                   |   person_ptr2 = (struct personal_ |
|                                   | data*)                            |
|                                   |     malloc (sizeof (struct person |
|                                   | al_data));                        |
|                                   |                                   |
|                                   |   strcpy (person_ptr2->name, "Ega |
|                                   | n, Greg");                        |
|                                   |   strcpy (person_ptr2->address, " |
|                                   | Permutation City");               |
|                                   |   person_ptr2->year_of_birth = 19 |
|                                   | 61;                               |
|                                   |   /* Don't know his birthday */   |
|                                   | ```                               |
|                                   |                                   |
|                                   | ``` {.smallexample}               |
|                                   | ```                               |
|                                   |                                   |
|                                   | ``` {.smallexample}               |
|                                   |   puts ("Data contained:");       |
|                                   |   puts (person1.name);            |
|                                   |   puts (person2.name);            |
|                                   |   puts (person_ptr1->name);       |
|                                   |   puts (person_ptr2->name);       |
|                                   |                                   |
|                                   |   return 0;                       |
|                                   | }                                 |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

Any trailing items not initialized by data you specify are set to zero.

------------------------------------------------------------------------

[]{#Memory-allocation}

  ------------------------------------------------------------------------ -------------------------------------------------- --- ------------------------------------------------------------------------------ ----------------------------------------- --------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Initializing-structures "Previous section in reading order")\]   \[[\>](#union "Next section in reading order")\]       \[[\<\<](#Data-structures "Beginning of this chapter or previous chapter")\]   \[[Up](#Data-structures "Up section")\]   \[[\>\>](#Recursion "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ------------------------------------------------------------------------ -------------------------------------------------- --- ------------------------------------------------------------------------------ ----------------------------------------- --------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Memory-allocation-1}

20.2 Memory allocation {#memory-allocation .section}
----------------------

[]{#index-Memory-allocation} []{#index-Allocation-of-memory}

Most variables in C have a fixed size. For example, a string declared to
be 200 bytes long will always be 200 bytes long throughout the program.
Sometimes, however, you will need variables whose size can vary. You
might want a string whose size can vary between 0 and 100 kilobytes, for
instance. We have already seen occasions where this sort of string is
needed with the `getline` function. (See section [`getline`](#getline).)

[]{#index-Dynamic-data} []{#index-Data_002c-dynamic}
[]{#index-malloc-function} []{#index-realloc-function}

This is where *dynamic data*, or data whose size can vary, comes in.
Dynamic data is created via the process of *memory allocation*, that is,
assigning a block of memory to a variable. Blocks of memory are usually
assigned with the `malloc` function (the function name is from the
phrase "memory allocation"), and can be resized with the `realloc`
("memory reallocation") function, and even merged back into the pool of
available memory with the `free` function.

[]{#index-malloc-function-1}

The `malloc` function takes one argument, the number of bytes to
allocate. It returns a void pointer, which provides the address of the
beginning of a block of memory that the program can use. This void
pointer can be assigned to any other type of pointer. The only way to
make use of the block of memory that has been allocated is through its
pointer; in that sense, the block is not a "real" variable, that is to
say, you cannot assign a value to the memory block directly. Instead,
the address returned by `malloc` enables you to use the block
indirectly; in this way, the block can contain any kind of value a real
variable can. Having to use blocks indirectly through pointers is a
small price to pay for the flexibility of dynamic data.

The following code example allocates a ten-byte string:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | char *my_string;                  |
|                                   | my_string = (char *) malloc(10+1) |
|                                   | ;                                 |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

Notice that the void pointer returned by `malloc` is cast to a character
pointer (type `char *`) before it is assigned to `my_string`. (See
section [The cast operator](#The-cast-operator).) Also notice that we
have actually allocated 11 bytes of space; this is because the 11th byte
must contain a null character that terminates the string but does not
count toward its actual length. **Careful!** The newly-allocated block
will be filled with garbage.

[]{#index-realloc-function-1}

To reallocate the memory, use the `realloc` function. This function
takes two parameters. The first is the pointer to the memory block to be
reallocated, and the second is a number of type `size_t` that specifies
the new size for the block. It returns a void pointer to the newly
reallocated block. Here is how to reallocate the block allocated for
`my_string` above, to a new size of 1000 bytes:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | my_string = (char *) realloc (my_ |
|                                   | string, 1001);                    |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

The new block will contain all the data in the old block, followed by
enough space to pad out the block to the new length. The new space will
be filled with garbage.

[]{#index-free-function}

Finally, to free up the memory allocated to a block and return it to the
common pool of memory available to your program, use the `free`
function, which takes only one argument, the pointer to the block you
wish to free. It does not return a value.

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | free (my_string);                 |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

[]{#index-_002d_003e-member-operator}

It is also possible to allocate the memory for a structure when it is
needed and use the '-\>' operator to access the members of the
structure, since we must access the structure via a pointer. (See the
code sample following the next paragraph for an example of how to do
this.) If you are creating complex data structures that require hundreds
or thousands of structure variables (or more), the ability to create and
destroy them dynamically can mean quite a savings in memory.

[]{#index-sizeof-function}

It's easy enough to allocate a block of memory when you know you want
1000 bytes for a string, but how do you know how much memory to allocate
for a structure? For this task, C provides the `sizeof` function, which
calculates the size of an object. For example, `sizeof (int)` returns
the numbers of bytes occupied by an integer variable. Similarly,
`sizeof (struct personal_data)` returns the number of bytes occupied by
our `personal_data` structure. To allocate a pointer to one of these
structures, then set the `year_of_birth` member to 1852, you would write
something like the following:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | struct personal_data* my_struct_p |
|                                   | tr;                               |
|                                   |                                   |
|                                   | my_struct_ptr = (struct personal_ |
|                                   | data*)                            |
|                                   |   malloc (sizeof (struct personal |
|                                   | _data));                          |
|                                   | my_struct_ptr->year_of_birth = 18 |
|                                   | 52;                               |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

------------------------------------------------------------------------

[]{#union}

  ------------------------------------------------------------------ ------------------------------------------------------------------ --- ------------------------------------------------------------------------------ ----------------------------------------- --------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Memory-allocation "Previous section in reading order")\]   \[[\>](#Declaration-of-unions "Next section in reading order")\]       \[[\<\<](#Data-structures "Beginning of this chapter or previous chapter")\]   \[[Up](#Data-structures "Up section")\]   \[[\>\>](#Recursion "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ------------------------------------------------------------------ ------------------------------------------------------------------ --- ------------------------------------------------------------------------------ ----------------------------------------- --------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#union-1}

20.3 `union` {#union .section}
------------

[]{#index-Unions} []{#index-union-type-2}

A union is like a structure in which all of the members are stored at
the same address. Only one member can be in a union at one time. The
`union` data type was invented to prevent the computer from breaking its
memory up into many inefficiently sized chunks, a condition that is
called *memory fragmentation*.

The `union` data type prevents fragmentation by creating a standard size
for certain data. When the computer allocates memory for a program, it
usually does so in one large block of bytes. Every variable allocated
when the program runs occupies a segment of that block. When a variable
is freed, it leaves a "hole" in the block allocated for the program. If
this hole is of an unusual size, the computer may have difficulty
allocating another variable to "fill" the hole, thus leading to
inefficient memory usage. Since unions have a standard data size,
however, any "hole" left in memory by freeing a union can be filled by
another instance of the same type of union. A union works because the
space allocated for it is the space taken by its largest member; thus,
the small-scale memory inefficiency of allocating space for the worst
case leads to memory efficiency on a larger scale.

  -------------------------------------------------------- ---- --
  [20.3.1 Declaration of unions](#Declaration-of-unions)        
  [20.3.2 Using unions](#Using-unions)                          
  -------------------------------------------------------- ---- --

------------------------------------------------------------------------

[]{#Declaration-of-unions}

  ------------------------------------------------------ --------------------------------------------------------- --- ------------------------------------------------------------------------------ ------------------------------- --------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#union "Previous section in reading order")\]   \[[\>](#Using-unions "Next section in reading order")\]       \[[\<\<](#Data-structures "Beginning of this chapter or previous chapter")\]   \[[Up](#union "Up section")\]   \[[\>\>](#Recursion "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ------------------------------------------------------ --------------------------------------------------------- --- ------------------------------------------------------------------------------ ------------------------------- --------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Declaration-of-unions-1}

### 20.3.1 Declaration of unions {#declaration-of-unions .subsection}

[]{#index-Declaring-unions} []{#index-Unions_002c-declaring}

A union is declared in the same way as a structure. It has a list of
members, as in the example below:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | union int_or_float                |
|                                   | {                                 |
|                                   |   int int_member;                 |
|                                   |   float float_member;             |
|                                   | };                                |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

Declaring union variables is similar to declaring structure variables:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | union int_or_float my_union1, my_ |
|                                   | union2;                           |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

Just like structures, the members of unions can be accessed with the '.'
and '-\>' operators. However, unlike structures, the variables
`my_union1` and `my_union2` above can be treated as either integers or
floating-point variables at different times during the program. For
example, if you write `my_union1.int_member = 5;`, then the program sees
`my_union1` as being an integer. (This is only a manner of speaking.
However, `my_union1` by itself does not have a value; only its members
have values.) On the other hand, if you then type
`my_union1.float_member = 7.7;`, the `my_union` variable loses its
integer value. It is crucial to remember that a union variable can only
have one type at the same time.

------------------------------------------------------------------------

[]{#Using-unions}

  ---------------------------------------------------------------------- -------------------------------------------------------------------- --- ------------------------------------------------------------------------------ ------------------------------- --------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Declaration-of-unions "Previous section in reading order")\]   \[[\>](#Complex-data-structures "Next section in reading order")\]       \[[\<\<](#Data-structures "Beginning of this chapter or previous chapter")\]   \[[Up](#union "Up section")\]   \[[\>\>](#Recursion "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ---------------------------------------------------------------------- -------------------------------------------------------------------- --- ------------------------------------------------------------------------------ ------------------------------- --------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Using-unions-1}

### 20.3.2 Using unions {#using-unions .subsection}

[]{#index-Unions_002c-using} []{#index-Using-unions}
[]{#index-Unions-and-flag-variables}

One way to tell what type of member is currently stored in the union is
to maintain a flag variable for each union. This can be done easily with
enumerated data. For example, for the `int_or_float` type, we might want
an associated enumerated type like this:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | enum which_member                 |
|                                   | {                                 |
|                                   |   INT,                            |
|                                   |   FLOAT                           |
|                                   | };                                |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

Notice that we used all-uppercase letters for the enumerated values. We
would have received a syntax error if we had actually used the C
keywords `int` and `float`.

Associated union and enumerated variables can now be declared in pairs:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | union int_or_float my_union1;     |
|                                   | enum which_member my_union_status |
|                                   | 1;                                |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

Handling union members is now straightforward. For example:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | switch (my_union_status1)         |
|                                   |   {                               |
|                                   |   case INT:                       |
|                                   |     my_union1.int_member += 5;    |
|                                   |     break;                        |
|                                   |   case FLOAT:                     |
|                                   |     my_union1.float_member += 23. |
|                                   | 222333;                           |
|                                   |     break;                        |
|                                   |   }                               |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

These variables could even be grouped into a structure for ease of use:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | struct multitype                  |
|                                   | {                                 |
|                                   |     union int_or_float number;    |
|                                   |     enum which_member status;     |
|                                   | };                                |
|                                   |                                   |
|                                   | struct multitype my_multi;        |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

You would then make assignments to the members of this structure in
pairs:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | my_multi.number.int_member = 5;   |
|                                   | my_multi.status = INT;            |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

------------------------------------------------------------------------

[]{#Complex-data-structures}

  ------------------------------------------------------------- -------------------------------------------------------------------- --- ------------------------------------------------------------------------------ ----------------------------------------- --------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Using-unions "Previous section in reading order")\]   \[[\>](#Data-structure-diagrams "Next section in reading order")\]       \[[\<\<](#Data-structures "Beginning of this chapter or previous chapter")\]   \[[Up](#Data-structures "Up section")\]   \[[\>\>](#Recursion "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ------------------------------------------------------------- -------------------------------------------------------------------- --- ------------------------------------------------------------------------------ ----------------------------------------- --------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Complex-data-structures-1}

20.4 Complex data structures {#complex-data-structures .section}
----------------------------

[]{#index-Complex-data-structures}
[]{#index-Data-structures_002c-complex}

When building data structures, it is best to model the situation in
question clearly and efficiently. Different types of data structure are
good for different things. For example, arrays are good for storing
tabular information. A chessboard looks like a two-dimensional array, so
such an array is a good data structure to model a chess game. In this
section we will examine more complex data structures that are useful for
modeling more complex situations.

  ----------------------------------------------------------------------------------------- ---- --
  [20.4.1 Data structure diagrams](#Data-structure-diagrams)                                     
  [20.4.2 Dynamic data structures, Pointers and Dynamic Memory](#Dynamic-data-structures)        
  [20.4.3 Lists and trees](#Lists-and-trees)                                                     
  [20.4.4 Setting up a data structure](#Setting-up-a-data-structure)                             
  ----------------------------------------------------------------------------------------- ---- --

------------------------------------------------------------------------

[]{#Data-structure-diagrams}

  ------------------------------------------------------------------------ -------------------------------------------------------------------- --- ------------------------------------------------------------------------------ ------------------------------------------------- --------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Complex-data-structures "Previous section in reading order")\]   \[[\>](#Dynamic-data-structures "Next section in reading order")\]       \[[\<\<](#Data-structures "Beginning of this chapter or previous chapter")\]   \[[Up](#Complex-data-structures "Up section")\]   \[[\>\>](#Recursion "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ------------------------------------------------------------------------ -------------------------------------------------------------------- --- ------------------------------------------------------------------------------ ------------------------------------------------- --------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Data-structure-diagrams-1}

### 20.4.1 Data structure diagrams {#data-structure-diagrams .subsection}

[]{#index-Data-structure-diagrams}
[]{#index-Diagrams_002c-data-structures}

Sometimes you will want to draw a picture that shows how to solve a
problem by displaying how all its parts are connected. Such a picture is
called a *structure diagram*.

Consider a hypothetical application that stores a map of the local
countryside. This program must store information about individual towns
and be able to give directions to the user about how to get from one
town to another. A person driving a car from town to town might use a
map, but the application programmer might use a structure diagram. Here
is a structure diagram for the imaginary town of New Haven, and its
neighboring towns North Haven, East Haven, South Haven, and West Haven:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   |               North Haven         |
|                                   |                                   |
|                                   |                    ^              |
|                                   |                    |              |
|                                   |                    v              |
|                                   |                                   |
|                                   | West Haven <-> New Haven <-> East |
|                                   |  Haven                            |
|                                   |                                   |
|                                   |                    ^              |
|                                   |                    |              |
|                                   |                    v              |
|                                   |                                   |
|                                   |               South Haven         |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

Once you have a structure diagram that represents your information, you
can create a data structure that translates the structure diagram into
the computer's memory. In this case, we can create a "town structure"
that contains pointers to the towns that lie at the end of roads in the
various compass directions. The town structure might look something like
this:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | struct town                       |
|                                   | {                                 |
|                                   |   struct town *north;             |
|                                   |   struct town *south;             |
|                                   |   struct town *east;              |
|                                   |   struct town *west;              |
|                                   |   char name[50];                  |
|                                   | };                                |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

If the user of this hypothetical application wishes to know what is to
the north of a particular town, the program only has to check that
town's `north` pointer.

------------------------------------------------------------------------

[]{#Dynamic-data-structures}

  ------------------------------------------------------------------------ ------------------------------------------------------------ --- ------------------------------------------------------------------------------ ------------------------------------------------- --------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Data-structure-diagrams "Previous section in reading order")\]   \[[\>](#Lists-and-trees "Next section in reading order")\]       \[[\<\<](#Data-structures "Beginning of this chapter or previous chapter")\]   \[[Up](#Complex-data-structures "Up section")\]   \[[\>\>](#Recursion "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ------------------------------------------------------------------------ ------------------------------------------------------------ --- ------------------------------------------------------------------------------ ------------------------------------------------- --------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Dynamic-data-structures_002c-Pointers-and-Dynamic-Memory}

### 20.4.2 Dynamic data structures, Pointers and Dynamic Memory {#dynamic-data-structures-pointers-and-dynamic-memory .subsection}

[]{#index-Dynamic-data-structures}
[]{#index-Data-structures_002c-dynamic}
[]{#index-Complex-data-structures-1}
[]{#index-Data-structures_002c-complex-1}

For programs dealing with large sets of data, it would be a nuisance to
have to name every structure variable containing every piece of data in
the code --- for one thing, it would be inconvenient to enter new data
at run time because you would have to know the name of the variable in
which to store the data when you wrote the program. For another thing,
variables with names are permanent --- they cannot be freed and their
memory reallocated, so you might have to allocate an impractically large
block of memory for your program at compile time, even though you might
need to store much of the data you entered at run time temporarily.

Fortunately, complex data structures are built out of dynamically
allocated memory, which does not have these limitations. All your
program needs to do is keep track of a pointer to a dynamically
allocated block, and it will always be able to find the block.

A complex data structure is usually built out of the following
components:

[]{#index-Nodes}

*nodes*

Dynamically-allocated blocks of data, usually structures.

[]{#index-Links}

*links*

Pointers from nodes to their related nodes.

[]{#index-Root-node} []{#index-Node_002c-root}

*root*

The node where a data structure starts, also known as the *root node*.
The address of the root of a data structure must be stored explicitly in
a C variable, or else you will lose track of it.

There are some advantages to the use of dynamic storage for data
structures:

-   As mentioned above, since memory is allocated as needed, we don't
    need to declare how much we shall use in advance.
-   Complex data structures can be made up of lots of "lesser" data
    structures in a modular way, making them easier to program.
-   Using pointers to connect structures means that they can be
    re-connected in different ways as the need arises. (Data structures
    can be sorted, for example.)

------------------------------------------------------------------------

[]{#Lists-and-trees}

  ------------------------------------------------------------------------ --------------------------------------------------------- --- ------------------------------------------------------------------------------ ------------------------------------------------- --------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Dynamic-data-structures "Previous section in reading order")\]   \[[\>](#Linked-lists "Next section in reading order")\]       \[[\<\<](#Data-structures "Beginning of this chapter or previous chapter")\]   \[[Up](#Complex-data-structures "Up section")\]   \[[\>\>](#Recursion "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ------------------------------------------------------------------------ --------------------------------------------------------- --- ------------------------------------------------------------------------------ ------------------------------------------------- --------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Lists-and-trees-1}

### 20.4.3 Lists and trees {#lists-and-trees .subsection}

[]{#index-Lists} []{#index-Trees} []{#index-Nodes-1} []{#index-Links-1}

Two data structures that use nodes and links are very common: the linked
list and the binary tree

  ----------------------------------------- ---- --
  [20.4.3.1 Linked lists.](#Linked-lists)        
  [20.4.3.2 Binary trees](#Binary-trees)         
  ----------------------------------------- ---- --

------------------------------------------------------------------------

[]{#Linked-lists}

  ---------------------------------------------------------------- --------------------------------------------------------- --- ------------------------------------------------------------------------------ ----------------------------------------- --------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Lists-and-trees "Previous section in reading order")\]   \[[\>](#Binary-trees "Next section in reading order")\]       \[[\<\<](#Data-structures "Beginning of this chapter or previous chapter")\]   \[[Up](#Lists-and-trees "Up section")\]   \[[\>\>](#Recursion "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ---------------------------------------------------------------- --------------------------------------------------------- --- ------------------------------------------------------------------------------ ----------------------------------------- --------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Linked-lists_002e}

#### 20.4.3.1 Linked lists. {#linked-lists. .subsubsection}

[]{#index-Linked-lists} []{#index-Lists_002c-linked}

A *linked list* is a linear sequence of structures joined together by
pointers. Each node's pointer links to the next node in the sequence.
Linked lists have two main advantages over one dimensional arrays: they
can be sorted easily simply by redirecting pointers, and they can be
made any length at all dynamically.

Here is an example of a structure type from a linked list:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | struct list_node                  |
|                                   | {                                 |
|                                   |   double value;                   |
|                                   |   struct list_node *next;         |
|                                   | };                                |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

Here the `value` member holds the actual content of the node, in this
case a double-precision floating-point number, and the `next` member
points to the next node in the list.

You will often encounter another basic kind of linked list, called a
*doubly-linked list*. Each node in a doubly-linked list contains not
only a pointer to the next node, but also to the previous node. This
kind of list makes it easier to determine what the node preceding a node
is, as well as the node succeeding it.

------------------------------------------------------------------------

[]{#Binary-trees}

  ------------------------------------------------------------- ------------------------------------------------------------------------ --- ------------------------------------------------------------------------------ ----------------------------------------- --------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Linked-lists "Previous section in reading order")\]   \[[\>](#Setting-up-a-data-structure "Next section in reading order")\]       \[[\<\<](#Data-structures "Beginning of this chapter or previous chapter")\]   \[[Up](#Lists-and-trees "Up section")\]   \[[\>\>](#Recursion "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ------------------------------------------------------------- ------------------------------------------------------------------------ --- ------------------------------------------------------------------------------ ----------------------------------------- --------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Binary-trees-1}

#### 20.4.3.2 Binary trees {#binary-trees .subsubsection}

[]{#index-Trees_002c-binary} []{#index-Binary-trees}

A *binary tree* is a data structure in which each node contains links to
two successor nodes, so that the whole structure is shaped like a
branching tree. A typical use for a binary tree might be storing
genealogical information; since (at this point in human evolution) every
individual has two parents, each node can represent a person and the two
linked nodes can represent that person's mother and father. Let's extend
our `personal_data` structure to incorporate this kind of information:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | struct personal_data              |
|                                   | {                                 |
|                                   |   char name[100];                 |
|                                   |   char address[200];              |
|                                   |   int year_of_birth;              |
|                                   |   int month_of_birth;             |
|                                   |   int day_of_birth;               |
|                                   |                                   |
|                                   |   struct personal_data *mother;   |
|                                   |   struct personal_data *father;   |
|                                   | };                                |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

------------------------------------------------------------------------

[]{#Setting-up-a-data-structure}

  ------------------------------------------------------------- -------------------------------------------------------------------------- --- ------------------------------------------------------------------------------ ------------------------------------------------- --------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Binary-trees "Previous section in reading order")\]   \[[\>](#Designing-your-data-structure "Next section in reading order")\]       \[[\<\<](#Data-structures "Beginning of this chapter or previous chapter")\]   \[[Up](#Complex-data-structures "Up section")\]   \[[\>\>](#Recursion "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ------------------------------------------------------------- -------------------------------------------------------------------------- --- ------------------------------------------------------------------------------ ------------------------------------------------- --------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Setting-up-a-data-structure-1}

### 20.4.4 Setting up a data structure {#setting-up-a-data-structure .subsection}

[]{#index-Data-structures_002c-setting-up}
[]{#index-Setting-up-data-structures}

Plan your data structures well, before you write any program code.
Changes in program code may not affect data structures, but changes to
data structures will likely imply drastic changes to program code.

  -------------------------------------------------------------------------------- ---- --
  [20.4.4.1 Designing your data structure](#Designing-your-data-structure)              
  [20.4.4.2 Initializing your data structure](#Initializing-your-data-structure)        
  -------------------------------------------------------------------------------- ---- --

------------------------------------------------------------------------

[]{#Designing-your-data-structure}

  ---------------------------------------------------------------------------- ----------------------------------------------------------------------------- --- ------------------------------------------------------------------------------ ----------------------------------------------------- --------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Setting-up-a-data-structure "Previous section in reading order")\]   \[[\>](#Initializing-your-data-structure "Next section in reading order")\]       \[[\<\<](#Data-structures "Beginning of this chapter or previous chapter")\]   \[[Up](#Setting-up-a-data-structure "Up section")\]   \[[\>\>](#Recursion "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ---------------------------------------------------------------------------- ----------------------------------------------------------------------------- --- ------------------------------------------------------------------------------ ----------------------------------------------------- --------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Designing-your-data-structure-1}

#### 20.4.4.1 Designing your data structure {#designing-your-data-structure .subsubsection}

The steps you should take in designing a data structure follow a basic
pattern:

1.  Group together all the kinds of information that must be stored and
    define a structure type with a member for each kind of information.
2.  Add structure pointers to the structure type to reflect the way in
    which each bundle of information is connected to the others.
3.  Design the algorithms to handle the memory allocation, node linking,
    and data storage.

------------------------------------------------------------------------

[]{#Initializing-your-data-structure}

  ------------------------------------------------------------------------------ ---------------------------------------------------------------------------- --- ------------------------------------------------------------------------------ ----------------------------------------------------- --------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Designing-your-data-structure "Previous section in reading order")\]   \[[\>](#Further-data-structure-examples "Next section in reading order")\]       \[[\<\<](#Data-structures "Beginning of this chapter or previous chapter")\]   \[[Up](#Setting-up-a-data-structure "Up section")\]   \[[\>\>](#Recursion "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ------------------------------------------------------------------------------ ---------------------------------------------------------------------------- --- ------------------------------------------------------------------------------ ----------------------------------------------------- --------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Initializing-your-data-structure-1}

#### 20.4.4.2 Initializing your data structure {#initializing-your-data-structure .subsubsection}

[]{#index-Data-structures_002c-initializing}
[]{#index-Initializing-data-structurse}

Once you understand your data structure, you can set about initializing
it in the following way:

1.  Declare your structure type. For example:
    +-----------------------------------+-----------------------------------+
    |                                   | ``` {.smallexample}               |
    |                                   | struct town                       |
    |                                   | {                                 |
    |                                   |   struct town *north;             |
    |                                   |   struct town *south;             |
    |                                   |   struct town *east;              |
    |                                   |   struct town *west;              |
    |                                   |   char name[50];                  |
    |                                   | };                                |
    |                                   | ```                               |
    +-----------------------------------+-----------------------------------+

2.  Declare two pointers to this type:

    +-----------------------------------+-----------------------------------+
    |                                   | ``` {.smallexample}               |
    |                                   | struct town *root, *current;      |
    |                                   | ```                               |
    +-----------------------------------+-----------------------------------+

    []{#index-Root-nodes} []{#index-Nodes_002c-root}

    The `root` pointer is used to point to the root node of the data
    structure, and the `current` pointer points to the node with which
    we are currently working.

3.  Allocate memory for the root node:

    +-----------------------------------+-----------------------------------+
    |                                   | ``` {.smallexample}               |
    |                                   | root = (struct town *) malloc (si |
    |                                   | zeof (struct town));              |
    |                                   | ```                               |
    +-----------------------------------+-----------------------------------+

    Be sure to check for errors. The variable `root` will be a null
    pointer if no memory could be allocated for the node.

4.  Initialize the members of the root node:

    +-----------------------------------+-----------------------------------+
    |                                   | ``` {.smallexample}               |
    |                                   | root->north = NULL;               |
    |                                   | root->south = NULL;               |
    |                                   | root->east  = NULL;               |
    |                                   | root->west  = NULL;               |
    |                                   | strcpy (root->name, "New Haven"); |
    |                                   | ```                               |
    +-----------------------------------+-----------------------------------+

    []{#index-Null-pointers} []{#index-NULL-pointer}

    Note that `NULL` pointers tell the program when it has come to the
    edge of the data structure, that is, when it has found a link that
    doesn't lead anywhere. At the moment, the links of the root node do
    not point anywhere. This will change as we add more nodes to the
    data structure.

5.  Create a new, non-root node:
    +-----------------------------------+-----------------------------------+
    |                                   | ``` {.smallexample}               |
    |                                   | current = (struct town *) malloc  |
    |                                   | (sizeof (struct town));           |
    |                                   | ```                               |
    +-----------------------------------+-----------------------------------+

6.  Initialize the current node:
    +-----------------------------------+-----------------------------------+
    |                                   | ``` {.smallexample}               |
    |                                   | current->north = NULL;            |
    |                                   | current->south = root;            |
    |                                   | current->east  = NULL;            |
    |                                   | current->west  = NULL;            |
    |                                   | strcpy (current->name, "North Hav |
    |                                   | en");                             |
    |                                   | ```                               |
    +-----------------------------------+-----------------------------------+

7.  Link neighboring nodes to the current node, as appropriate:
    +-----------------------------------+-----------------------------------+
    |                                   | ``` {.smallexample}               |
    |                                   | root->north = current;            |
    |                                   | ```                               |
    +-----------------------------------+-----------------------------------+

8.  Repeat steps 5 through 7, as necessary.

See section [Controlled recursion with data
structures](#Controlled-recursion-with-data-structures), for a practical
example of building a simple linked list programmatically.

------------------------------------------------------------------------

[]{#Further-data-structure-examples}

  --------------------------------------------------------------------------------- --------------------------------------------------------- --- ------------------------------------------------------------------------------ ----------------------------------------- --------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Initializing-your-data-structure "Previous section in reading order")\]   \[[\>](#Questions-20 "Next section in reading order")\]       \[[\<\<](#Data-structures "Beginning of this chapter or previous chapter")\]   \[[Up](#Data-structures "Up section")\]   \[[\>\>](#Recursion "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  --------------------------------------------------------------------------------- --------------------------------------------------------- --- ------------------------------------------------------------------------------ ----------------------------------------- --------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Further-data-structure-examples-1}

20.5 Further data structure examples {#further-data-structure-examples .section}
------------------------------------

See section [Example programs](#Example-programs), to see a complete
application program that uses a complex data structure with nodes and
links to stores its data later in the book.

------------------------------------------------------------------------

[]{#Questions-20}

  -------------------------------------------------------------------------------- ------------------------------------------------------ --- ------------------------------------------------------------------------------ ----------------------------------------- --------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Further-data-structure-examples "Previous section in reading order")\]   \[[\>](#Recursion "Next section in reading order")\]       \[[\<\<](#Data-structures "Beginning of this chapter or previous chapter")\]   \[[Up](#Data-structures "Up section")\]   \[[\>\>](#Recursion "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  -------------------------------------------------------------------------------- ------------------------------------------------------ --- ------------------------------------------------------------------------------ ----------------------------------------- --------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Questions-20-1}

20.6 Questions 20 {#questions-20 .section}
-----------------

1.  What is the difference between a structure and a union?
2.  What is a member?
3.  If `foo` is a structure variable, how would you find out the value
    of its member `bar`?
4.  If `foo` is a pointer to a structure variable, how would you find
    out the value of its member `bar`?
5.  How are data usually linked to make a complex data structure?
6.  Every structure variable in a complex data structure must have its
    own variable name. True or false?
7.  How are the members of structures accessed in a data structure?
8.  Write a small program to make linked list that contains three nodes
    long and set all their values to be zero. Can you automate this
    program with a loop? Can you make it work for any number of nodes?

------------------------------------------------------------------------

[]{#Recursion}

  ------------------------------------------------------------- ------------------------------------------------------ --- ------------------------------------------------------------------------------ ----------------------------- ----------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Questions-20 "Previous section in reading order")\]   \[[\>](#The-stack "Next section in reading order")\]       \[[\<\<](#Data-structures "Beginning of this chapter or previous chapter")\]   \[[Up](#Top "Up section")\]   \[[\>\>](#Style "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ------------------------------------------------------------- ------------------------------------------------------ --- ------------------------------------------------------------------------------ ----------------------------- ----------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Recursion-1}

21. Recursion {#recursion .chapter}
=============

*The program that swallowed its tail.*

[]{#index-Recursion}

This chapter is about functions that call themselves. Consider the
program below:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | #include <stdio.h>                |
|                                   |                                   |
|                                   | void black_hole()                 |
|                                   | {                                 |
|                                   |   black_hole();                   |
|                                   | }                                 |
|                                   |                                   |
|                                   | /* To shorten example, not using  |
|                                   | argp */                           |
|                                   | int main ()                       |
|                                   | {                                 |
|                                   |   black_hole();                   |
|                                   |   return 0;                       |
|                                   | }                                 |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

The `main` function calls the `black_hole` function, which calls itself,
which calls itself, which calls... Once the control flow enters
`black_hole`, it will never exit. This kind of function is called a
*recursive function*, and a function's act of calling itself is called
*recursion*.

  ---------------------------------------------------------------------------------------------- ---- --
  [21.1 The stack](#The-stack)                                                                        
  [21.2 Controlled recursion](#Controlled-recursion)                                                  
  [21.3 Controlled recursion with data structures](#Controlled-recursion-with-data-structures)        
  [21.4 Recursion summary](#Recursion-summary)                                                        
  [21.5 Questions 21](#Questions-21)                                                                  
  ---------------------------------------------------------------------------------------------- ---- --

------------------------------------------------------------------------

[]{#The-stack}

  ---------------------------------------------------------- ---------------------------------------------------------------- --- ------------------------------------------------------------------------ ----------------------------------- ----------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Recursion "Previous section in reading order")\]   \[[\>](#The-stack-in-detail "Next section in reading order")\]       \[[\<\<](#Recursion "Beginning of this chapter or previous chapter")\]   \[[Up](#Recursion "Up section")\]   \[[\>\>](#Style "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ---------------------------------------------------------- ---------------------------------------------------------------- --- ------------------------------------------------------------------------ ----------------------------------- ----------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#The-stack-1}

21.1 The stack {#the-stack .section}
--------------

[]{#index-Stack}

What happens when we run the last example program? The `black_hole`
function calls itself indefinitely. Each function call uses up a small
portion of the computer's memory called the *stack*. Eventually all of
this memory is used up, and a kind of error called a *stack overflow*
occurs. The program then crashes with a *Segmentation fault* error.

It is sometimes helpful to think of a function as a robot that does a
job. A function definition in effect provides the blueprints for a
robot. When the function is executed, it is as though a robot is built
on an assembly line in a robot factory. A recursive function is like a
robot that builds a copy of itself on the same assembly line. The second
robot is identical to the first in every way, except that it is an
assistant to the first robot, and has been passed different arguments.
This second robot may in turn build a copy of itself as well, and so on.
It is crucial that the process of robots building robots stop at some
point; otherwise, the robot factory will run out of raw materials (that
is, computer memory), and the assembly line will grind to a halt.

  ---------------------------------------------------- ---- --
  [21.1.1 The stack in detail](#The-stack-in-detail)        
  ---------------------------------------------------- ---- --

------------------------------------------------------------------------

[]{#The-stack-in-detail}

  ---------------------------------------------------------- ----------------------------------------------------------------- --- ------------------------------------------------------------------------ ----------------------------------- ----------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#The-stack "Previous section in reading order")\]   \[[\>](#Controlled-recursion "Next section in reading order")\]       \[[\<\<](#Recursion "Beginning of this chapter or previous chapter")\]   \[[Up](#The-stack "Up section")\]   \[[\>\>](#Style "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ---------------------------------------------------------- ----------------------------------------------------------------- --- ------------------------------------------------------------------------ ----------------------------------- ----------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#The-stack-in-detail-1}

### 21.1.1 The stack in detail {#the-stack-in-detail .subsection}

[]{#index-Stack-1}

Let's examine this process in detail. When one function calls another
function in a C program, control passes from the first function to the
second function. When the second function ends, control passes back to
the statement in the first function that immediately follows the
function call. But how does the computer know where in its memory this
statement resides?

The answer is simple. The computer keeps a list of the addresses in
memory of the places to which it must return, no matter how many
function calls are made. This list is the stack.

The stack gets its name from the fact that it is a *LIFO*, or *last in,
first out* structure, meaning that the last item to be *pushed onto* the
stack is the first item to be *popped off*. It works, in other words,
like the stack of dinner plates you keep in your kitchen cabinet. As you
wash plates, you pile them one by one on top of the stack, and when you
want a plate, you take one from the top of the stack. The stack of
plates in your cabinet is therefore also a last in, first out structure,
like the computer's stack.

When one C function calls a second function, the computer leaves itself
an address at the top of the stack of where it should return when it has
finished executing the second function. If the second function calls a
third function, the computer will push another address onto the stack.
When the third function has finished executing, the computer pops the
top address off the stack, which tells it where in the second function
it should return. When the second function has finished, the computer
again pops the top address off the stack --- which tells it where in the
first function it should return. Perhaps the first function then calls
another function, and the whole process starts again.

What happens when `black_hole` calls itself? The computer makes a note
of the address it must return to and pushes that address onto the top of
the stack. It begins executing `black_hole` again, and encounters
another call to `black_hole`. The computer pushes another address onto
the top of the stack, and begins executing `black_hole` again. Since the
program has no chance of popping addresses off the stack, as the process
continues, the stack gets filled up with addresses. Eventually, the
stack fills up and the program crashes.

------------------------------------------------------------------------

[]{#Controlled-recursion}

  -------------------------------------------------------------------- -------------------------------------------------------------------------------------- --- ------------------------------------------------------------------------ ----------------------------------- ----------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#The-stack-in-detail "Previous section in reading order")\]   \[[\>](#Controlled-recursion-with-data-structures "Next section in reading order")\]       \[[\<\<](#Recursion "Beginning of this chapter or previous chapter")\]   \[[Up](#Recursion "Up section")\]   \[[\>\>](#Style "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  -------------------------------------------------------------------- -------------------------------------------------------------------------------------- --- ------------------------------------------------------------------------ ----------------------------------- ----------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Controlled-recursion-1}

21.2 Controlled recursion {#controlled-recursion .section}
-------------------------

[]{#index-Recursion_002c-controlled}

If that were all there is to recursion, no one would ever use it.
However, recursion can be limited so it does not go out of control.
Controlled recursion can be a powerful programming technique.

When we discussed data structures, we remarked that programs and data
structures should aim to model the situation they deal with closely.
Some structures, both in real life and in computer memory, are made up
of many levels of detail, and the details are roughly the same at every
level. For example, a genealogical tree starts with an individual with
two parents, each of whom has two parents, each of whom... These sorts
of structure are called *self-similar*.

Since recursion employs functions that contain calls to themselves, in
effect creating multiple self-similar levels of detail, controlled
recursion is useful for dealing with self-similar problems.

Recursive functions can be controlled by making sure that there is a
safe way to exit them at some point in the chain of function calls. The
number of times recursion takes place is limited by making a decision
about whether the function calls itself or not. Simply put, somewhere
along the chain of function calls, the function makes the decision not
to call itself again, in a process nicknamed *bottoming out*. At that
point, the program begins popping addresses off the stack and returning
to the previous functions. Eventually, the very first function in the
chain terminates, and the program ends successfully.

A standard example of controlled recursion is the factorial function.
This is a mathematical function which is important in statistics. The
factorial function is defined to be the product (multiplication) of all
integers from 1 to the parameter of the function. (The factorial of 0 is
1.)

Here are some examples of the factorial function. These are not
executable C code examples, but pseudocode:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | factorial(3) == 1 * 2 * 3         |
|                                   |  ==   6                           |
|                                   | factorial(4) == 1 * 2 * 3 * 4     |
|                                   |  ==  24                           |
|                                   | factorial(3) == 1 * 2 * 3 * 4 * 5 |
|                                   |  == 120                           |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

Formally, the factorial function is defined by two equations. (Again,
these are in pseudocode).

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | factorial(n) = n * factorial(n-1) |
|                                   | factorial(0) = 1                  |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

The first of these statements is recursive, because it defines the value
of `factorial(n)` in terms of `factorial(n-1)`. The second statement
allows the function to "bottom out".

Here is a short code example that incorporates a `factorial` function.

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | #include <stdio.h>                |
|                                   |                                   |
|                                   | int factorial (int n)             |
|                                   | {                                 |
|                                   |   if (n == 0)                     |
|                                   |     return 1;                     |
|                                   |   else                            |
|                                   |     return (n * factorial (n-1)); |
|                                   | }                                 |
|                                   |                                   |
|                                   | /* To shorten example, not using  |
|                                   | argp */                           |
|                                   | int main ()                       |
|                                   | {                                 |
|                                   |   printf ("%d\n", factorial(3));  |
|                                   |   return 0;                       |
|                                   | }                                 |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

Let's follow the control flow in this program to see how controlled
recursion can work. The `main` function prints the value of
`factorial(3)`. First, the `factorial` function is called with the
parameter 3. The function tests whether its parameter `n` is zero. It is
not, so it takes the `else` branch if the `if` statement, which
instructs it to return the value of `factorial(3-1)`. It therefore calls
itself recursively with a parameter of 2.

The new call checks whether its parameter is zero. It isn't (it's 2), so
it takes the `else` branch again, and tries to calculate
`2 * factorial (1)`. In order to do so, it calls itself recursively with
a value of 2-1, or 1. The new call checks whether its parameter is zero.
It is actually 1, so it takes the `else` branch again and attempts to
calculate `1 * factorial (0)`. In order to do so, it calls itself again
with the parameter 0.

Again, the function checks whether its parameter is zero. This time it
is, so the function bottoms out. It takes the first branch of the `if`
statement and returns a value of 1. Now the previous function call can
also return a value, and so on, until the very first call to `factorial`
terminates, and the function returns a value of 6.

To sum up, the expression `factorial(3)` goes through the following
steps before finally being evaluated:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | factorial (3) == 3 * factorial(2) |
|                                   |               == 3 * (2 * factori |
|                                   | al(1))                            |
|                                   |               == 3 * (2 * (1 * fa |
|                                   | ctorial(0)))                      |
|                                   |               == 3 * (2 * (1 * 1) |
|                                   | ))                                |
|                                   |               == 6                |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

**Note:** Make sure that the test for whether to bottom out your
recursive function does not depend on a global variable.

Suppose you have a global variable called `countdown`, which your
recursive function decrements by 1 every time it is called. When
`countdown` equals zero, your recursive function bottoms out. However,
since other functions than the recursive function have access to global
variables, it is possible that another function might independently
change `countdown` in such a way that your recursive function would
never bottom out --- perhaps by continually incrementing it, or perhaps
even by setting it to a negative number.

------------------------------------------------------------------------

[]{#Controlled-recursion-with-data-structures}

  --------------------------------------------------------------------- -------------------------------------------------------------- --- ------------------------------------------------------------------------ ----------------------------------- ----------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Controlled-recursion "Previous section in reading order")\]   \[[\>](#Recursion-summary "Next section in reading order")\]       \[[\<\<](#Recursion "Beginning of this chapter or previous chapter")\]   \[[Up](#Recursion "Up section")\]   \[[\>\>](#Style "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  --------------------------------------------------------------------- -------------------------------------------------------------- --- ------------------------------------------------------------------------ ----------------------------------- ----------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Controlled-recursion-with-data-structures-1}

21.3 Controlled recursion with data structures {#controlled-recursion-with-data-structures .section}
----------------------------------------------

[]{#index-Recursive-data-structures}
[]{#index-Data-structures_002c-recursive}
[]{#index-Data-structures-with-controlled-recursion}
[]{#index-Controlled-recursion-with-data-structures}
[]{#index-Recursion_002c-controlled_002c-with-data-structures}

Self-similar data structures are sometimes called *recursive data
structures*. The simplest recursive data structure is the linked list.
At every node in a linked list, there is data of a certain type and a
link to the next node. The next simplest recursive data structure is the
binary tree, which splits into two branches at every node. Recursive
functions be useful for manipulating such recursive data structures.

The following code example makes use of recursion to print the value
contained in the last node in a linked list.

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | #include <stdio.h>                |
|                                   |                                   |
|                                   | struct list_node                  |
|                                   | {                                 |
|                                   |   int data;                       |
|                                   |   struct list_node *next;         |
|                                   | };                                |
|                                   | ```                               |
|                                   |                                   |
|                                   | ``` {.smallexample}               |
|                                   | ```                               |
|                                   |                                   |
|                                   | ``` {.smallexample}               |
|                                   | struct list_node *last_node (stru |
|                                   | ct list_node *node)               |
|                                   | {                                 |
|                                   |   if (node->next == NULL)         |
|                                   |     return node;                  |
|                                   |   else                            |
|                                   |     return last_node (node->next) |
|                                   | ;                                 |
|                                   | }                                 |
|                                   | ```                               |
|                                   |                                   |
|                                   | ``` {.smallexample}               |
|                                   | ```                               |
|                                   |                                   |
|                                   | ``` {.smallexample}               |
|                                   | /* To shorten example, not using  |
|                                   | argp */                           |
|                                   | int main ()                       |
|                                   | {                                 |
|                                   |   struct list_node *root;         |
|                                   |   struct list_node *current;      |
|                                   |   struct list_node *old;          |
|                                   |   struct list_node *last;         |
|                                   | ```                               |
|                                   |                                   |
|                                   | ``` {.smallexample}               |
|                                   | ```                               |
|                                   |                                   |
|                                   | ``` {.smallexample}               |
|                                   |   /* Initialize list. */          |
|                                   |   root = (struct list_node *) mal |
|                                   | loc (sizeof (struct list_node));  |
|                                   |   root->data = 1;                 |
|                                   |   old = root;                     |
|                                   | ```                               |
|                                   |                                   |
|                                   | ``` {.smallexample}               |
|                                   | ```                               |
|                                   |                                   |
|                                   | ``` {.smallexample}               |
|                                   |   current = (struct list_node *)  |
|                                   | malloc (sizeof (struct list_node) |
|                                   | );                                |
|                                   |   current->data = 2;              |
|                                   |   old->next = current;            |
|                                   |   old = current;                  |
|                                   | ```                               |
|                                   |                                   |
|                                   | ``` {.smallexample}               |
|                                   | ```                               |
|                                   |                                   |
|                                   | ``` {.smallexample}               |
|                                   |   current = (struct list_node *)  |
|                                   | malloc (sizeof (struct list_node) |
|                                   | );                                |
|                                   |   current->data = 3;              |
|                                   |   old->next = current;            |
|                                   |   current->next = NULL;           |
|                                   |                                   |
|                                   |   /* Print data in last node. */  |
|                                   |   last = last_node (root);        |
|                                   |   printf ("Data in last node is % |
|                                   | d.\n", last->data);               |
|                                   |                                   |
|                                   |   return 0;                       |
|                                   | }                                 |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

This example program prints out the following line:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | Data in last node is 3.           |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

The `last_node` function, when passed a pointer to a node (such as the
root), follows the linked list to its end from that point, and returns a
pointer to that node. It does so through recursion. When it is passed a
pointer to a node, it checks whether that node's `next` link is a null
pointer. If the pointer is null, `last_node` has found the last node,
and bottoms out, returning a pointer to the current node; otherwise, it
calls itself with a pointer to the next node as a parameter.

------------------------------------------------------------------------

[]{#Recursion-summary}

  ------------------------------------------------------------------------------------------ --------------------------------------------------------- --- ------------------------------------------------------------------------ ----------------------------------- ----------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Controlled-recursion-with-data-structures "Previous section in reading order")\]   \[[\>](#Questions-21 "Next section in reading order")\]       \[[\<\<](#Recursion "Beginning of this chapter or previous chapter")\]   \[[Up](#Recursion "Up section")\]   \[[\>\>](#Style "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ------------------------------------------------------------------------------------------ --------------------------------------------------------- --- ------------------------------------------------------------------------ ----------------------------------- ----------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Recursion-summary-1}

21.4 Recursion summary {#recursion-summary .section}
----------------------

Recursion can be a powerful programming technique, especially when
dealing with mathematical functions such as factorialisation that lend
themselves naturally to recursion, or with self-similar data structures.
There is a major disadvantage to recursion, however, and that is the
amount of memory required to make it work. Do not forget that the
program stack grows each time a function call is made. If a function
calls itself too many times, your program will run out of memory and
crash. Recursive programming can also be difficult; runaway recursion is
a common error. Therefore, be judicious in your use of recursion.

------------------------------------------------------------------------

[]{#Questions-21}

  ------------------------------------------------------------------ -------------------------------------------------- --- ------------------------------------------------------------------------ ----------------------------------- ----------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Recursion-summary "Previous section in reading order")\]   \[[\>](#Style "Next section in reading order")\]       \[[\<\<](#Recursion "Beginning of this chapter or previous chapter")\]   \[[Up](#Recursion "Up section")\]   \[[\>\>](#Style "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ------------------------------------------------------------------ -------------------------------------------------- --- ------------------------------------------------------------------------ ----------------------------------- ----------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Questions-21-1}

21.5 Questions 21 {#questions-21 .section}
-----------------

1.  What is a recursive function?
2.  What is a program stack, and what is it for?
3.  State the major disadvantage of recursion.

------------------------------------------------------------------------

[]{#Style}

  ------------------------------------------------------------- ------------------------------------------------------------ --- ------------------------------------------------------------------------ ----------------------------- --------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Questions-21 "Previous section in reading order")\]   \[[\>](#Formatting-code "Next section in reading order")\]       \[[\<\<](#Recursion "Beginning of this chapter or previous chapter")\]   \[[Up](#Top "Up section")\]   \[[\>\>](#Debugging "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ------------------------------------------------------------- ------------------------------------------------------------ --- ------------------------------------------------------------------------ ----------------------------- --------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Style-1}

22. Style {#style .chapter}
=========

[]{#index-Style-3} []{#index-Style-guidelines}

C has no rules about when to start new lines, where to place whitespace,
and so on. Users are free to choose a style which best suits them, but
unless a strict style is adopted, sloppy programs tend to result.

In older compilers, memory restrictions sometimes necessitated bizarre,
cryptic styles in the interest of efficiency. However, contemporary
compilers such as GCC have no such restrictions, and have optimizers
that can produce faster code than most programmers could write
themselves by hand, so there are no excuses not to write programs as
clearly as possible.

No simple set of rules will ever provide a complete methodology for
writing good programs. In the end, experience and good judgment are the
factors which determine whether you will write good programs.
Nevertheless, a few guidelines to good style can be stated.

Many of the guidelines in this chapter are the distilled wisdom of
countless C programmers over the decades that C has existed, and some
come directly from the *GNU Coding Standards*. That document contains
more good advice than can be crammed into this short chapter, so if you
plan to write programs for the Free Software Foundation, you are urged
to consult [(standards)Top](standards.html#Top) section 'Table of
Contents' in GNU Coding Standards.

  -------------------------------------------------------------------------- ---- --
  [22.1 Formatting code](#Formatting-code)                                        
  [22.2 Comments and style](#Comments-and-style)                                  
  [22.3 Variable and function names](#Variable-and-function-names)                
  [22.4 Declarations and initialization](#Declarations-and-initialization)        
  [22.5 Global variables and style](#Global-variables-and-style)                  
  [22.6 Hidden operators and style](#Hidden-operators-and-style)                  
  [22.7 Final words on style](#Final-words-on-style)                              
  [22.8 Questions 22](#Questions-22)                                              
  -------------------------------------------------------------------------- ---- --

------------------------------------------------------------------------

[]{#Formatting-code}

  ------------------------------------------------------ --------------------------------------------------------------- --- -------------------------------------------------------------------- ------------------------------- --------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Style "Previous section in reading order")\]   \[[\>](#Comments-and-style "Next section in reading order")\]       \[[\<\<](#Style "Beginning of this chapter or previous chapter")\]   \[[Up](#Style "Up section")\]   \[[\>\>](#Debugging "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ------------------------------------------------------ --------------------------------------------------------------- --- -------------------------------------------------------------------- ------------------------------- --------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Formatting-code-1}

22.1 Formatting code {#formatting-code .section}
--------------------

[]{#index-Formatting-code_002c-style-guidelines}
[]{#index-Style-guidelines-for-formatting-code}

Place the open curly bracket that starts the body of a C function in the
first column of your source file, and avoid placing any other open
brackets or open parentheses in that column. This will help many
code-processing utilities find the beginnings of your functions.
Similarly, you should also place the name of your functions within your
function definitions in the first column. Thus, your functions should
resemble the following example:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | static char *                     |
|                                   | concat (char *s1, char *s2)       |
|                                   | {                                 |
|                                   |   …                               |
|                                   | }                                 |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

When you split an expression into multiple lines, split it before an
operator, not after one. Here is the right way:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | if (foo_this_is_long && bar > win |
|                                   |  (x, y, z)                        |
|                                   |     && remaining_condition)       |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

Don't declare multiple variables in one declaration that spans lines.
Start a new declaration on each line instead. For example, instead of
this:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | int    foo,                       |
|                                   |        bar;                       |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

write either this:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | int foo, bar;                     |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

or this:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | int foo;                          |
|                                   | int bar;                          |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

------------------------------------------------------------------------

[]{#Comments-and-style}

  ---------------------------------------------------------------- ------------------------------------------------------------------------ --- -------------------------------------------------------------------- ------------------------------- --------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Formatting-code "Previous section in reading order")\]   \[[\>](#Variable-and-function-names "Next section in reading order")\]       \[[\<\<](#Style "Beginning of this chapter or previous chapter")\]   \[[Up](#Style "Up section")\]   \[[\>\>](#Debugging "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ---------------------------------------------------------------- ------------------------------------------------------------------------ --- -------------------------------------------------------------------- ------------------------------- --------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Comments-and-style-1}

22.2 Comments and style {#comments-and-style .section}
-----------------------

[]{#index-Comments_002c-style-guidelines-for}
[]{#index-Style-guidelines-for-comments}

Comments are crucial for other programmers trying to understand your
code. Every program should start with a comment saying briefly what it
is for. Example: 'fmt - filter for simple filling of text'. Similarly,
you should put a comment on each function saying what the function does,
what sort of arguments it takes, what the possible values of arguments
mean, and what they are used for.

Please write all comments in a GNU program in English, because English
is the one language that nearly all programmers in all countries can
read.

------------------------------------------------------------------------

[]{#Variable-and-function-names}

  ------------------------------------------------------------------- ---------------------------------------------------------------------------- --- -------------------------------------------------------------------- ------------------------------- --------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Comments-and-style "Previous section in reading order")\]   \[[\>](#Declarations-and-initialization "Next section in reading order")\]       \[[\<\<](#Style "Beginning of this chapter or previous chapter")\]   \[[Up](#Style "Up section")\]   \[[\>\>](#Debugging "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ------------------------------------------------------------------- ---------------------------------------------------------------------------- --- -------------------------------------------------------------------- ------------------------------- --------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Variable-and-function-names-1}

22.3 Variable and function names {#variable-and-function-names .section}
--------------------------------

[]{#index-Variable-names_002c-style-guidelines-for}
[]{#index-Function-names_002c-style-guidelines-for}
[]{#index-Style-guidelines-for-variable-names}
[]{#index-Style-guidelines-for-function-names}

The names of variables and functions in a program serve as comments of a
sort, so try to give your variables descriptive names (for example,
`num_of_books`, `cost_per_entry`, or `distance_from_center`). Names
should be in English, like other comments.

Use underscores rather than internal capitalization in names, so that
Emacs word commands can be useful within them --- thus
`distance_from_center` rather than `distanceFromCenter` or
`DistanceFromCenter`. In fact, upper-case letters should be reserved for
macros and `enum` constants. Macros should be completely in upper case,
for example `STANDARD_SIZE`.

It used to be common practice to use the same local variables (with
names like `temp`) over and over for different purposes within one
function. Instead, it is better to declare a separate local variable for
each distinct purpose, and give it a meaningful name. This not only
makes programs easier to understand, it also facilitates optimization by
good compilers.

------------------------------------------------------------------------

[]{#Declarations-and-initialization}

  ---------------------------------------------------------------------------- ----------------------------------------------------------------------- --- -------------------------------------------------------------------- ------------------------------- --------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Variable-and-function-names "Previous section in reading order")\]   \[[\>](#Global-variables-and-style "Next section in reading order")\]       \[[\<\<](#Style "Beginning of this chapter or previous chapter")\]   \[[Up](#Style "Up section")\]   \[[\>\>](#Debugging "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ---------------------------------------------------------------------------- ----------------------------------------------------------------------- --- -------------------------------------------------------------------- ------------------------------- --------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Declarations-and-initialization-1}

22.4 Declarations and initialization {#declarations-and-initialization .section}
------------------------------------

[]{#index-Declarations_002c-style-guidelines-for}
[]{#index-Initialization_002c-style-guidelines-for}
[]{#index-Style-guidelines-for-declarations}
[]{#index-Style-guidelines-for-initialization}

You should explicitly declare the types of all objects. For example,
explicitly declare all arguments to functions, and declare all function
that return integers to return type `int`, even though the ANSI Standard
permits omitting the `int`.

If there are only a few declarations, then initializing variables where
you declare them can be tidy, but if there are many variables to
declare, then it is usually better to declare and initialize separately,
for the sake of clarity. In a long function, it is often good to
initialize the variable near where you are using it, so that someone
reading the code does not have to hunt around in the function to
discover its initial value. (See section
[Initialization](#Initialization).)

------------------------------------------------------------------------

[]{#Global-variables-and-style}

  -------------------------------------------------------------------------------- ----------------------------------------------------------------------- --- -------------------------------------------------------------------- ------------------------------- --------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Declarations-and-initialization "Previous section in reading order")\]   \[[\>](#Hidden-operators-and-style "Next section in reading order")\]       \[[\<\<](#Style "Beginning of this chapter or previous chapter")\]   \[[Up](#Style "Up section")\]   \[[\>\>](#Debugging "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  -------------------------------------------------------------------------------- ----------------------------------------------------------------------- --- -------------------------------------------------------------------- ------------------------------- --------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Global-variables-and-style-1}

22.5 Global variables and style {#global-variables-and-style .section}
-------------------------------

[]{#index-Global-variables_002c-style-guidelines-for}
[]{#index-Style-guidelines-for-global-variables}

Global variables have caused almost as much controversy as the `goto`
statement. Some programmers say you should never use them. Other
programmers use them on a regular basis. In fact, while global variables
should not be overused, they can simplify your code considerably. The
following guidelines may help you decide where to use globals.

-   Always think of using local variables first. Global variables can
    puncture the *encapsulization* of your functions, that is, the
    logical isolation of your functions from the rest of your code. It
    is difficult to see what variables are being passed to a function
    unless they are all passed as parameters, so it is easier to debug a
    program when encapsulization is maintained.
-   Local variables may be impractical, however, if they mean passing
    the same dozen parameters to multiple functions; in such cases,
    global variables will often streamline your code.
-   Data structures that are important to the whole program should be
    defined globally. In "real programs" such as GNU Emacs, there are
    far more global variables than there are local variables visible in
    any one function.

Finally, don't use local variables or parameters that have the same
names as global identifiers. This can make debugging very difficult.

------------------------------------------------------------------------

[]{#Hidden-operators-and-style}

  --------------------------------------------------------------------------- ----------------------------------------------------------------- --- -------------------------------------------------------------------- ------------------------------- --------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Global-variables-and-style "Previous section in reading order")\]   \[[\>](#Final-words-on-style "Next section in reading order")\]       \[[\<\<](#Style "Beginning of this chapter or previous chapter")\]   \[[Up](#Style "Up section")\]   \[[\>\>](#Debugging "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  --------------------------------------------------------------------------- ----------------------------------------------------------------- --- -------------------------------------------------------------------- ------------------------------- --------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Hidden-operators-and-style-1}

22.6 Hidden operators and style {#hidden-operators-and-style .section}
-------------------------------

[]{#index-Hidden-operators_002c-style-guidelines-for}
[]{#index-Style-guidelines-for-hidden-operators}

Hiding operators away inside other statements can certainly make
programs *look* elegant and compact, but it can make programs harder to
understand. Never forget that besides being a set of instructions to the
computer, programming is a form of communication to other programmers.
Be kind to the reader of your program. It could be you in months or
years to come.

Statements such as:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | if ((my_int = (int)my_char++) <=  |
|                                   | --my_int2)                        |
|                                   |   {                               |
|                                   |     …                             |
|                                   |   }                               |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

are not good style, and are no more efficient than the more longwinded:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | my_int = (int) my_char;           |
|                                   | my_char++;                        |
|                                   | my_int2--;                        |
|                                   |                                   |
|                                   | if (my_int <= my_int2)            |
|                                   |   {                               |
|                                   |     …                             |
|                                   |   }                               |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

------------------------------------------------------------------------

[]{#Final-words-on-style}

  --------------------------------------------------------------------------- --------------------------------------------------------- --- -------------------------------------------------------------------- ------------------------------- --------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Hidden-operators-and-style "Previous section in reading order")\]   \[[\>](#Questions-22 "Next section in reading order")\]       \[[\<\<](#Style "Beginning of this chapter or previous chapter")\]   \[[Up](#Style "Up section")\]   \[[\>\>](#Debugging "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  --------------------------------------------------------------------------- --------------------------------------------------------- --- -------------------------------------------------------------------- ------------------------------- --------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Final-words-on-style-1}

22.7 Final words on style {#final-words-on-style .section}
-------------------------

It is easy to support pre-ANSI-Standard compilers in most programs, so
if you know how to do that and a program you are maintaining has such
support, you should try to keep it working.

Whatever style you use, use it consistently. A mixture of styles within
a single program tends to look ugly and be hard to read and maintain. If
you are contributing changes to an existing program, it is best to
follow the style of that program.

------------------------------------------------------------------------

[]{#Questions-22}

  --------------------------------------------------------------------- ------------------------------------------------------ --- -------------------------------------------------------------------- ------------------------------- --------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Final-words-on-style "Previous section in reading order")\]   \[[\>](#Debugging "Next section in reading order")\]       \[[\<\<](#Style "Beginning of this chapter or previous chapter")\]   \[[Up](#Style "Up section")\]   \[[\>\>](#Debugging "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  --------------------------------------------------------------------- ------------------------------------------------------ --- -------------------------------------------------------------------- ------------------------------- --------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Questions-22-1}

22.8 Questions 22 {#questions-22 .section}
-----------------

1.  Where should the name of a program and the opening bracket of a
    function definition begin?
2.  In what human language should comments be written for the GNU
    Project? Why?
3.  Which is better as the name of a variable: `plotArea`, `PlotArea`,
    or `plot_area`? Why?
4.  Why is it important to initialize a variable near where it is used
    in a long function?
5.  Give an example of a case where using local variables is
    impractical.

------------------------------------------------------------------------

[]{#Debugging}

  ------------------------------------------------------------- -------------------------------------------------------------------- --- -------------------------------------------------------------------- ----------------------------- ---------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Questions-22 "Previous section in reading order")\]   \[[\>](#Compile_002dtime-errors "Next section in reading order")\]       \[[\<\<](#Style "Beginning of this chapter or previous chapter")\]   \[[Up](#Top "Up section")\]   \[[\>\>](#Example-programs "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ------------------------------------------------------------- -------------------------------------------------------------------- --- -------------------------------------------------------------------- ----------------------------- ---------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Debugging-1}

23. Debugging {#debugging .chapter}
=============

[]{#index-Debugging}

True artificial intelligence has not yet been achieved. C compilers are
not intelligent, but unconscious: mechanical in the derogatory sense of
the word. Therefore, debugging your programs can be a difficult process.
A single typographical error can cause a compiler to completely
misunderstand your code and generate a misleading error message.
Sometimes a long string of compiler error messages are generated because
of a single error in your code. To minimize the time you spend
debugging, it is useful to become familiar with the most common compiler
messages and their probable causes.

The first section in this chapter lists some of these common
compile-time errors and what to do about them. The next two sections
discuss run-time errors in general, and mathematical errors in
particular. The final section introduces GDB, the GNU Debugger, and
explains some simple steps you can take to debug your programs with it.

  ----------------------------------------------------------------------------------------------------------------------- ---- --
  [23.1 Compile-time errors](#Compile_002dtime-errors)                                                                         
  [23.2 ...undeclared (first use in this function)](#g_t_002e_002e_002eundeclared-_0028first-use-in-this-function_0029)        
  [23.3 Run-time errors](#Run_002dtime-errors)                                                                                 
  [23.4 Mathematical errors](#Mathematical-errors)                                                                             
  [23.5 Introduction to GDB](#Introduction-to-GDB)                                                                             
  [23.6 Questions 23](#Questions-23)                                                                                           
  ----------------------------------------------------------------------------------------------------------------------- ---- --

------------------------------------------------------------------------

[]{#Compile_002dtime-errors}

  ---------------------------------------------------------- -------------------------------------------------------------------------- --- ------------------------------------------------------------------------ ----------------------------------- ---------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Debugging "Previous section in reading order")\]   \[[\>](#parse-error-at_002e_002e_002e "Next section in reading order")\]       \[[\<\<](#Debugging "Beginning of this chapter or previous chapter")\]   \[[Up](#Debugging "Up section")\]   \[[\>\>](#Example-programs "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ---------------------------------------------------------- -------------------------------------------------------------------------- --- ------------------------------------------------------------------------ ----------------------------------- ---------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Compile_002dtime-errors-1}

23.1 Compile-time errors {#compile-time-errors .section}
------------------------

[]{#index-Compile_002dtime-errors-2} []{#index-Errors_002c-compile-time}

In this section, we will examine a variety of compile-time errors and
what you can do about them. The aim is not to be a comprehensive guide
to everything that can go wrong with your program and all the
corresponding error messages, but rather to give you a taste of the
kinds of errors you are likely to make, and to build your confidence by
showing that even fairly scary-looking error messages often have a
simple cause.

  ------------------------------------------------------------------------------------------------ ---- --
  [23.1.1 parse error at..., parse error before...](#parse-error-at_002e_002e_002e)                     
  [23.1.2 undefined reference to...](#undefined-reference-to_002e_002e_002e)                            
  [23.1.3 unterminated string or character constant](#unterminated-string-or-character-constant)        
  ------------------------------------------------------------------------------------------------ ---- --

------------------------------------------------------------------------

[]{#parse-error-at_002e_002e_002e}

  ------------------------------------------------------------------------ ---------------------------------------------------------------------------------- --- ------------------------------------------------------------------------ ------------------------------------------------- ---------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Compile_002dtime-errors "Previous section in reading order")\]   \[[\>](#undefined-reference-to_002e_002e_002e "Next section in reading order")\]       \[[\<\<](#Debugging "Beginning of this chapter or previous chapter")\]   \[[Up](#Compile_002dtime-errors "Up section")\]   \[[\>\>](#Example-programs "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ------------------------------------------------------------------------ ---------------------------------------------------------------------------------- --- ------------------------------------------------------------------------ ------------------------------------------------- ---------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#parse-error-at_2026_002c-parse-error-before_2026}

### 23.1.1 parse error at..., parse error before... {#parse-error-at-parse-error-before .subsection}

[]{#index-Parse-error}

This is a general-purpose syntax error. It is frequently caused by a
missing semicolon. For example, the following code:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | #include <stdio.h>                |
|                                   |                                   |
|                                   | /* To shorten example, not using  |
|                                   | argp */                           |
|                                   | int main()                        |
|                                   | {                                 |
|                                   |   printf ("Hello, world!\n")      |
|                                   |   return 0;                       |
|                                   | }                                 |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

generates the following error:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | semicolon.c: In function `main':  |
|                                   | semicolon.c:6: parse error before |
|                                   |  `return'                         |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

Adding a semicolon (';') at the end of the line
`printf ("Hello, world!")` will get rid of this error.

Notice that the error refers to line 6, but the error is actually on the
previous line. This is quite common. Since C compilers are lenient about
where you place whitespace, the compiler treats line 5 and line 6 as a
single line that reads as follows:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | printf ("Hello, world!\n") return |
|                                   |  0;                               |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

Of course this code makes no sense, and that is why the compiler
complains.

Often a missing curly bracket will cause one of these errors. For
example, the following code:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | #include <stdio.h>                |
|                                   |                                   |
|                                   | /* To shorten example, not using  |
|                                   | argp */                           |
|                                   | int main()                        |
|                                   | {                                 |
|                                   |   if (1==1)                       |
|                                   |     {                             |
|                                   |       printf ("Hello, world!\n"); |
|                                   |                                   |
|                                   |                                   |
|                                   |   return 0;                       |
|                                   | }                                 |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

generates the following error:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | brackets.c: In function `main':   |
|                                   | brackets.c:11: parse error at end |
|                                   |  of input                         |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

Because there is no closing curly bracket for the `if` statement, the
compiler thinks the curly bracket that terminates the `main` function
actually terminates the `if` statement. When it does not find a curly
bracket on line 11 of the program to terminate the `main` function, it
complains. One way to avoid this problem is to type both members of a
matching pair of brackets before you fill them in.

------------------------------------------------------------------------

[]{#undefined-reference-to_002e_002e_002e}

  ------------------------------------------------------------------------------ -------------------------------------------------------------------------------------- --- ------------------------------------------------------------------------ ------------------------------------------------- ---------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#parse-error-at_002e_002e_002e "Previous section in reading order")\]   \[[\>](#unterminated-string-or-character-constant "Next section in reading order")\]       \[[\<\<](#Debugging "Beginning of this chapter or previous chapter")\]   \[[Up](#Compile_002dtime-errors "Up section")\]   \[[\>\>](#Example-programs "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ------------------------------------------------------------------------------ -------------------------------------------------------------------------------------- --- ------------------------------------------------------------------------ ------------------------------------------------- ---------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#undefined-reference-to_2026}

### 23.1.2 undefined reference to... {#undefined-reference-to .subsection}

[]{#index-Undefined-reference-error}

This error is often generated because you have typed the name of a
function or variable incorrectly. For example, the following code:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | #include <stdio.h>                |
|                                   |                                   |
|                                   | void print_hello()                |
|                                   | {                                 |
|                                   |   printf ("Hello!\n");            |
|                                   | }                                 |
|                                   | ```                               |
|                                   |                                   |
|                                   | ``` {.smallexample}               |
|                                   | ```                               |
|                                   |                                   |
|                                   | ``` {.smallexample}               |
|                                   | /* To shorten example, not using  |
|                                   | argp */                           |
|                                   | int main()                        |
|                                   | {                                 |
|                                   |   Print_hello();                  |
|                                   |   return 0;                       |
|                                   | }                                 |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

generates the following rather forbidding error:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | /tmp/cc9KXhmV.o: In function `mai |
|                                   | n':                               |
|                                   | /tmp/cc9KXhmV.o(.text+0x1f): unde |
|                                   | fined reference to `Print_hello'  |
|                                   | collect2: ld returned 1 exit stat |
|                                   | us                                |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

The answer, however, is very simple. C is case-sensitive. The `main`
function calls the function `Print_hello` (with a capital 'P'), but the
correct name of the function is `print_hello` (with a lower-case 'p').
The linker could not find a function with the name `Print_hello`.

------------------------------------------------------------------------

[]{#unterminated-string-or-character-constant}

  -------------------------------------------------------------------------------------- -------------------------------------------------------------------------------------------------------------- --- ------------------------------------------------------------------------ ------------------------------------------------- ---------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#undefined-reference-to_002e_002e_002e "Previous section in reading order")\]   \[[\>](#g_t_002e_002e_002eundeclared-_0028first-use-in-this-function_0029 "Next section in reading order")\]       \[[\<\<](#Debugging "Beginning of this chapter or previous chapter")\]   \[[Up](#Compile_002dtime-errors "Up section")\]   \[[\>\>](#Example-programs "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  -------------------------------------------------------------------------------------- -------------------------------------------------------------------------------------------------------------- --- ------------------------------------------------------------------------ ------------------------------------------------- ---------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#unterminated-string-or-character-constant-1}

### 23.1.3 unterminated string or character constant {#unterminated-string-or-character-constant .subsection}

This error is often generated by code like the following:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | #include <stdio.h>                |
|                                   |                                   |
|                                   | /* To shorten example, not using  |
|                                   | argp */                           |
|                                   | int main()                        |
|                                   | {                                 |
|                                   |   printf("hello!\n);              |
|                                   |   printf("Hello again!\n");       |
|                                   |   return 0;                       |
|                                   | }                                 |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

The actual error message received was:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | missquotes.c:6: unterminated stri |
|                                   | ng or character constant          |
|                                   | missquotes.c:5: possible real sta |
|                                   | rt of unterminated constant       |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

The compiler never found a close quote ('\"') for the string
'Hello!\\n'. It read all the text up from the quote in the line
`printf("Hello!\n);` to the *first* quote in the line
`printf("Hello again!\n");` as a single string. Notice that GCC
helpfully suggests that it is line 5 that actually contains the
unterminated string. GCC is pretty smart as C compilers go.

------------------------------------------------------------------------

[]{#g_t_002e_002e_002eundeclared-_0028first-use-in-this-function_0029}

  ------------------------------------------------------------------------------------------ --------------------------------------------------------------- --- ------------------------------------------------------------------------ ----------------------------------- ---------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#unterminated-string-or-character-constant "Previous section in reading order")\]   \[[\>](#different-type-arg "Next section in reading order")\]       \[[\<\<](#Debugging "Beginning of this chapter or previous chapter")\]   \[[Up](#Debugging "Up section")\]   \[[\>\>](#Example-programs "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ------------------------------------------------------------------------------------------ --------------------------------------------------------------- --- ------------------------------------------------------------------------ ----------------------------------- ---------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#g_t_2026undeclared-_0028first-use-in-this-function_0029}

23.2 ...undeclared (first use in this function) {#undeclared-first-use-in-this-function .section}
-----------------------------------------------

This is similar to the 'undefined reference to...' error, but instead of
referring to an undefined function, you are referring to an undefined
variable.

Sometimes this is a scope problem. You might get this error if you tried
to refer to another function's local variable. For example:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | #include <stdio.h>                |
|                                   |                                   |
|                                   | void set_value()                  |
|                                   | {                                 |
|                                   |   int my_int = 5;                 |
|                                   | }                                 |
|                                   | ```                               |
|                                   |                                   |
|                                   | ``` {.smallexample}               |
|                                   | ```                               |
|                                   |                                   |
|                                   | ``` {.smallexample}               |
|                                   | /* To shorten example, not using  |
|                                   | argp */                           |
|                                   | int main()                        |
|                                   | {                                 |
|                                   |   my_int = 23;                    |
|                                   |   return 0;                       |
|                                   | }                                 |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

The variable `my_int` is local to the function `set_value`, so referring
to it from within `main` results in the following error:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | undec.c: In function `main':      |
|                                   | undec.c:10: `my_int' undeclared ( |
|                                   | first use in this function)       |
|                                   | undec.c:10: (Each undeclared iden |
|                                   | tifier is reported only once      |
|                                   | undec.c:10: for each function it  |
|                                   | appears in.)                      |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

  -------------------------------------------------------------------------------------------- ---- --
  [23.2.1 different type arg](#different-type-arg)                                                  
  [23.2.2 too few parameters..., too many parameters...](#too-few-parameters_002e_002e_002e)        
  -------------------------------------------------------------------------------------------- ---- --

------------------------------------------------------------------------

[]{#different-type-arg}

  ------------------------------------------------------------------------------------------------------------------ ------------------------------------------------------------------------------ --- ------------------------------------------------------------------------ ------------------------------------------------------------------------------------------- ---------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#g_t_002e_002e_002eundeclared-_0028first-use-in-this-function_0029 "Previous section in reading order")\]   \[[\>](#too-few-parameters_002e_002e_002e "Next section in reading order")\]       \[[\<\<](#Debugging "Beginning of this chapter or previous chapter")\]   \[[Up](#g_t_002e_002e_002eundeclared-_0028first-use-in-this-function_0029 "Up section")\]   \[[\>\>](#Example-programs "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ------------------------------------------------------------------------------------------------------------------ ------------------------------------------------------------------------------ --- ------------------------------------------------------------------------ ------------------------------------------------------------------------------------------- ---------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#different-type-arg-1}

### 23.2.1 different type arg {#different-type-arg .subsection}

[]{#index-Different-type-argument-error}

You might get this warning if you mismatch a parameter to `printf` and a
conversion specifier. For example, the following code:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | #include <stdio.h>                |
|                                   |                                   |
|                                   | /* To shorten example, not using  |
|                                   | argp */                           |
|                                   | int main()                        |
|                                   | {                                 |
|                                   |   int my_int = 5;                 |
|                                   |   printf ("%f", my_int);          |
|                                   |   return 0;                       |
|                                   | }                                 |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

produces the folliwing warning:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | wrongtype2.c: In function `main': |
|                                   | wrongtype2.c:6: warning: double f |
|                                   | ormat, different type arg (arg 2) |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

The '%f' conversion specifier requires a floating-point argument, while
`my_int` is an integer, so GCC complains.

**Note:** GCC is quite lenient about type mismatches and will usually
coerce one type to another dynamically without complaining, for example
when assigning a floating-point number to an integer. This extends to
mismatched parameters and conversion specifiers --- although you may
receive odd results from `printf` and so on, the causes of which may not
be obvious. Therefore, in order to generate this warning, the '-Wall'
option of GCC was used. This option causes GCC to be especially
sensitive to errors, and to complain about problems it usually ignores.
You will often find the '-Wall' option to be useful in finding tricky
problems. Here is the actual command line used to compile this program:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | gcc -Wall -o wrong wrongtype2.c   |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

------------------------------------------------------------------------

[]{#too-few-parameters_002e_002e_002e}

  ------------------------------------------------------------------- ---------------------------------------------------------------- --- ------------------------------------------------------------------------ ------------------------------------------------------------------------------------------- ---------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#different-type-arg "Previous section in reading order")\]   \[[\>](#Run_002dtime-errors "Next section in reading order")\]       \[[\<\<](#Debugging "Beginning of this chapter or previous chapter")\]   \[[Up](#g_t_002e_002e_002eundeclared-_0028first-use-in-this-function_0029 "Up section")\]   \[[\>\>](#Example-programs "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ------------------------------------------------------------------- ---------------------------------------------------------------- --- ------------------------------------------------------------------------ ------------------------------------------------------------------------------------------- ---------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#too-few-parameters_2026_002c-too-many-parameters_2026}

### 23.2.2 too few parameters..., too many parameters... {#too-few-parameters-too-many-parameters .subsection}

[]{#index-Too-few-parameters-error}

Consider the following program:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | #include <stdio.h>                |
|                                   |                                   |
|                                   | void tweedledee (int a, int b, in |
|                                   | t c)                              |
|                                   | {                                 |
|                                   | }                                 |
|                                   |                                   |
|                                   | void tweedledum (int a, int b)    |
|                                   | {                                 |
|                                   | }                                 |
|                                   | ```                               |
|                                   |                                   |
|                                   | ``` {.smallexample}               |
|                                   | ```                               |
|                                   |                                   |
|                                   | ``` {.smallexample}               |
|                                   | /* To shorten example, not using  |
|                                   | argp */                           |
|                                   | int main()                        |
|                                   | {                                 |
|                                   |                                   |
|                                   |   tweedledee (1, 2);              |
|                                   |   tweedledum (1, 2, 3);           |
|                                   |                                   |
|                                   |   return 0;                       |
|                                   | }                                 |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

The `tweedledee` function takes three parameters, but `main` passes it
two, whereas the `tweedledum` function takes two parameters, but `main`
passes it three. The result is a pair of straightforward error messages:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | params.c: In function `main':     |
|                                   | params.c:14: too few arguments to |
|                                   |  function `tweedledee'            |
|                                   | params.c:15: too many arguments t |
|                                   | o function `tweedledum'           |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

This is one reason for the existence of function prototypes. Before the
ANSI Standard, compilers did not complain about this kind of error. If
you were working with a library of functions with which you were not
familiar, and you passed one the wrong number of parameters, the error
was sometimes difficult to track. Contemporary C compilers such as GCC
that follow the standard make finding parameter mismatch errors simple.

------------------------------------------------------------------------

[]{#Run_002dtime-errors}

  ---------------------------------------------------------------------------------- ------------------------------------------------------------------------------ --- ------------------------------------------------------------------------ ----------------------------------- ---------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#too-few-parameters_002e_002e_002e "Previous section in reading order")\]   \[[\>](#Confusion-of-_003d-and-_003d_003d "Next section in reading order")\]       \[[\<\<](#Debugging "Beginning of this chapter or previous chapter")\]   \[[Up](#Debugging "Up section")\]   \[[\>\>](#Example-programs "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ---------------------------------------------------------------------------------- ------------------------------------------------------------------------------ --- ------------------------------------------------------------------------ ----------------------------------- ---------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Run_002dtime-errors-1}

23.3 Run-time errors {#run-time-errors .section}
--------------------

This section examines errors that cannot be caught by the compiler and
are exhibited only when the program is run.

  ---------------------------------------------------------------------------------------- ---- --
  [23.3.1 Confusion of `=` and `==`](#Confusion-of-_003d-and-_003d_003d)                        
  [23.3.2 Confusing `foo++` and `++foo`](#Confusing-foo_002b_002b-and-_002b_002bfoo)            
  [23.3.3 Unwarranted assumptions about storage](#Unwarranted-assumptions-about-storage)        
  [23.3.4 Array out of bounds](#Array-out-of-bounds)                                            
  [23.3.5 Uncoordinated output](#Uncoordinated-output)                                          
  [23.3.6 Global variables and recursion](#Global-variables-and-recursion)                      
  ---------------------------------------------------------------------------------------- ---- --

------------------------------------------------------------------------

[]{#Confusion-of-_003d-and-_003d_003d}

  -------------------------------------------------------------------- -------------------------------------------------------------------------------------- --- ------------------------------------------------------------------------ --------------------------------------------- ---------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Run_002dtime-errors "Previous section in reading order")\]   \[[\>](#Confusing-foo_002b_002b-and-_002b_002bfoo "Next section in reading order")\]       \[[\<\<](#Debugging "Beginning of this chapter or previous chapter")\]   \[[Up](#Run_002dtime-errors "Up section")\]   \[[\>\>](#Example-programs "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  -------------------------------------------------------------------- -------------------------------------------------------------------------------------- --- ------------------------------------------------------------------------ --------------------------------------------- ---------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Confusion-of-_003d-and-_003d_003d-1}

### 23.3.1 Confusion of `=` and `==` {#confusion-of-and .subsection}

[]{#index-_003d-confused-with-_003d_003d-2}
[]{#index-_003d_003d-confused-with-_003d-2}

Consider the following program:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | #include <stdio.h>                |
|                                   |                                   |
|                                   | /* To shorten example, not using  |
|                                   | argp */                           |
|                                   | int main()                        |
|                                   | {                                 |
|                                   |   int my_int = 0;                 |
|                                   |                                   |
|                                   |   if (my_int = 1)                 |
|                                   |     {                             |
|                                   |       printf ("Hello!\n");        |
|                                   |     }                             |
|                                   |                                   |
|                                   |   return 0;                       |
|                                   | }                                 |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

What will this program do? If you guessed that it will print 'Hello!',
you are correct. The assignment operator (`=`) was used by mistake
instead of the equality operator (`==`). What is being tested in the
above `if` statement is not whether `my_int` has a value of 1 (which
would be written `if my_int == 1`), but instead what the value is of the
assignment statement `my_int = 1`. Since the value of an assignment
statement is always the result of the assignment, and `my_int` is here
being assigned a value of 1, the result is 1, which C considers to be
equivalent to `TRUE`. Thus, the program prints out its greeting.

Even the best C programmers make this mistake from time to time, and
tracking down an error like this can be maddening. Using the '-Wall'
option of GCC can help at least a little by giving you a warning like
the following:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | equals.c: In function `main':     |
|                                   | equals.c:7: warning: suggest pare |
|                                   | ntheses around assignment used as |
|                                   |  truth value                      |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

------------------------------------------------------------------------

[]{#Confusing-foo_002b_002b-and-_002b_002bfoo}

  ---------------------------------------------------------------------------------- ---------------------------------------------------------------------------------- --- ------------------------------------------------------------------------ --------------------------------------------- ---------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Confusion-of-_003d-and-_003d_003d "Previous section in reading order")\]   \[[\>](#Unwarranted-assumptions-about-storage "Next section in reading order")\]       \[[\<\<](#Debugging "Beginning of this chapter or previous chapter")\]   \[[Up](#Run_002dtime-errors "Up section")\]   \[[\>\>](#Example-programs "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ---------------------------------------------------------------------------------- ---------------------------------------------------------------------------------- --- ------------------------------------------------------------------------ --------------------------------------------- ---------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Confusing-foo_002b_002b-and-_002b_002bfoo-1}

### 23.3.2 Confusing `foo++` and `++foo` {#confusing-foo-and-foo .subsection}

[]{#index-Postfix-and-prefix-_002b_002b_002c-confused}

In many cases, the forms `foo++` and `++foo` are identical. However, if
they are hidden inside another statement, there can be a subtle
difference. For example:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | my_array [++my_index] = 0;        |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

The code `++my_index` cause `my_index` to be incremented by 1 *before*
the assignment takes place, whereas `my_index++` would have cause
`my_index` to be incremented *after* the assignment takes place.
Sometimes you'll want one and sometimes the other. If you find that your
program is miscalculating by a difference of 1 (this is called an
*off-by-one bug* and is quite common), a prefix or postfix '++' could be
the cause. The same holds for other prefix and postfix operators, such
as '\--'.

------------------------------------------------------------------------

[]{#Unwarranted-assumptions-about-storage}

  ------------------------------------------------------------------------------------------ ---------------------------------------------------------------- --- ------------------------------------------------------------------------ --------------------------------------------- ---------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Confusing-foo_002b_002b-and-_002b_002bfoo "Previous section in reading order")\]   \[[\>](#Array-out-of-bounds "Next section in reading order")\]       \[[\<\<](#Debugging "Beginning of this chapter or previous chapter")\]   \[[Up](#Run_002dtime-errors "Up section")\]   \[[\>\>](#Example-programs "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ------------------------------------------------------------------------------------------ ---------------------------------------------------------------- --- ------------------------------------------------------------------------ --------------------------------------------- ---------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Unwarranted-assumptions-about-storage-1}

### 23.3.3 Unwarranted assumptions about storage {#unwarranted-assumptions-about-storage .subsection}

[]{#index-Storage_002c-false-assumptions-about}

Do not assume that the size of a structure is the sum of the sizes of
its parts. The two may differ for various reasons; for example, the
operating system may be aligning variables with specific addresses
within the data structure. Furthermore, the elements of an array may not
even be next to one another in memory.

This kind of code is always safe:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | int my_array[3];                  |
|                                   |                                   |
|                                   | my_array[0] = 0;                  |
|                                   | my_array[1] = 0;                  |
|                                   | my_array[2] = 0;                  |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

This kind of code is not:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | int my_array[3];                  |
|                                   |                                   |
|                                   | *my_array = 0;                    |
|                                   | *(my_array + (1 * sizeof(int))) = |
|                                   |  0;                               |
|                                   | *(my_array + (2 * sizeof(int))) = |
|                                   |  0;                               |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

While it is true that the variable `my_array` used without its square
brackets is a pointer to the first element of the array, you must not
assume that you can simply calculate a pointer to the third element with
code like the following:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | my_array + 2 * sizeof(int);       |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

Do something like this instead:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | &(my_array[2]);                   |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

------------------------------------------------------------------------

[]{#Array-out-of-bounds}

  -------------------------------------------------------------------------------------- ----------------------------------------------------------------- --- ------------------------------------------------------------------------ --------------------------------------------- ---------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Unwarranted-assumptions-about-storage "Previous section in reading order")\]   \[[\>](#Uncoordinated-output "Next section in reading order")\]       \[[\<\<](#Debugging "Beginning of this chapter or previous chapter")\]   \[[Up](#Run_002dtime-errors "Up section")\]   \[[\>\>](#Example-programs "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  -------------------------------------------------------------------------------------- ----------------------------------------------------------------- --- ------------------------------------------------------------------------ --------------------------------------------- ---------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Array-out-of-bounds-1}

### 23.3.4 Array out of bounds {#array-out-of-bounds .subsection}

[]{#index-Arrays_002c-out-of-bounds}
[]{#index-Array-out-of-bounds-errors}

When you get or set the value of an element of an array, GCC does not
check whether you are working within the bound of the array. In the
worst case, this can lead to your program crashing (but probably nothing
worse happening on a GNU system). See section [Array
bounds](#Array-bounds), for more information on this error. See section
[Introduction to GDB](#Introduction-to-GDB), for information on how you
can check whether you are violating array bounds, using the GNU
Debugger.

------------------------------------------------------------------------

[]{#Uncoordinated-output}

  -------------------------------------------------------------------- --------------------------------------------------------------------------- --- ------------------------------------------------------------------------ --------------------------------------------- ---------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Array-out-of-bounds "Previous section in reading order")\]   \[[\>](#Global-variables-and-recursion "Next section in reading order")\]       \[[\<\<](#Debugging "Beginning of this chapter or previous chapter")\]   \[[Up](#Run_002dtime-errors "Up section")\]   \[[\>\>](#Example-programs "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  -------------------------------------------------------------------- --------------------------------------------------------------------------- --- ------------------------------------------------------------------------ --------------------------------------------- ---------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Uncoordinated-output-1}

### 23.3.5 Uncoordinated output {#uncoordinated-output .subsection}

[]{#index-Uncoordinated-output} []{#index-Output_002c-uncoordinated}
[]{#index-Flushing-buffers} []{#index-Buffers_002c-flushing}
[]{#index-fflush-function-1}

You may occasionally experience strange effects when writing output to
the screen, such as no output at all until the input is complete, or
spontaneous bursts of output at seemingly random intervals. This sort of
problem usually has to do with the way the output is buffered. The
solution is usually to write a newline character ('\\n') to the output
when you are ready to display it, or to use a function like `fflush` to
flush the buffer. (See section [Stream buffering](#Stream-buffering),
for more information.)

------------------------------------------------------------------------

[]{#Global-variables-and-recursion}

  --------------------------------------------------------------------- ---------------------------------------------------------------- --- ------------------------------------------------------------------------ --------------------------------------------- ---------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Uncoordinated-output "Previous section in reading order")\]   \[[\>](#Mathematical-errors "Next section in reading order")\]       \[[\<\<](#Debugging "Beginning of this chapter or previous chapter")\]   \[[Up](#Run_002dtime-errors "Up section")\]   \[[\>\>](#Example-programs "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  --------------------------------------------------------------------- ---------------------------------------------------------------- --- ------------------------------------------------------------------------ --------------------------------------------- ---------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Global-variables-and-recursion-1}

### 23.3.6 Global variables and recursion {#global-variables-and-recursion .subsection}

[]{#index-Global-variables-and-recursion}
[]{#index-Recursion-and-global-variables}
[]{#index-Variables_002c-global_002c-and-recursion}

Global variables and recursion usually do not mix. Make sure that the
test for whether to "bottom out" your recursive function does not depend
on a global variable. See section [Controlled
recursion](#Controlled-recursion), for more information on why this is a
bad thing.

------------------------------------------------------------------------

[]{#Mathematical-errors}

  ------------------------------------------------------------------------------- ---------------------------------------------------------------- --- ------------------------------------------------------------------------ ----------------------------------- ---------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Global-variables-and-recursion "Previous section in reading order")\]   \[[\>](#Introduction-to-GDB "Next section in reading order")\]       \[[\<\<](#Debugging "Beginning of this chapter or previous chapter")\]   \[[Up](#Debugging "Up section")\]   \[[\>\>](#Example-programs "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ------------------------------------------------------------------------------- ---------------------------------------------------------------- --- ------------------------------------------------------------------------ ----------------------------------- ---------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Mathematical-errors-1}

23.4 Mathematical errors {#mathematical-errors .section}
------------------------

[]{#index-Mathematical-errors} []{#index-Errors_002c-methematical}

Mathematical errors are a special kind of run-time error. They may not
necessarily cause your program to crash, but they are likely to produce
all sorts of strange results if you are doing some complex calculations
in your program. Consider the following line of code:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | root = sqrt (-1.0);               |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

Readers with a smattering of mathematics will recognise that this code
cannot give a sensible answer. The square root of -1 is a complex number
called [![\$i\$](ctut_6.svg)]{.MATH}. The number
[![\$i\$](ctut_6.svg)]{.MATH} is a so-called imaginary number, and
cannot be represented by a floating-point value, which is what the
`sqrt` function returns.

What happens in such a case? Two things:

1.  []{#index-NAN-macro} []{#index-INFINITY-macro}
2.  The value returned is a special floating-point macro such as `NAN`
    (which means "not a number") or `INFINITY`.
    []{#index-Floating_002dpoint-exceptions}
    []{#index-Exceptions_002c-floating_002dpoint}
3.  More importantly from a debugging standpoint, a floating-point
    *exception* occurs. An exception is an error condition, and when a
    floating-point exception is *raised*, as the jargon goes, an error
    flag is set in the operating system, signifying what kind of
    exception it was (in other words, what kind of error caused the
    exception to be raised).

There are several kinds of floating-point exception:

-   []{#index-FE_005fINVALID-floating_002dpoint-exception}
-   `FE_INVALID`: The "Invalid Operation" exception. Raised if the
    operands are invalid for the given operation, for example, if you
    are trying to take the square root of a negative number, as above.
    []{#index-FE_005fDIVBYZERO-floating_002dpoint-exception}
-   `FE_DIVBYZERO`: The "Division by Zero" exception. Raised when a
    finite, nonzero number is divided by zero.
    []{#index-FE_005fOVERFLOW-floating_002dpoint-exception}
-   `FE_OVERFLOW`: The "Overflow" exception. Raised when the result
    cannot be expressed as a finite value, for example when a finite,
    nonzero number is divided by zero. Whenever this exception is
    raised, the `FE_INEXACT` exception is also raised.
    []{#index-FE_005fUNDERFLOW-floating_002dpoint-exception}
-   `FE_UNDERFLOW`: The "Underflow" exception. Raised when an
    intermediate result is too small to be calculated accurately, or
    when an operation's rounded result is too small to be *normalized*.
    Normalisation, roughly speaking, is the process of converting a
    number to scientific notation, such as converting 235 to 2.35e2,
    where the *mantissa*, or number to the left of the 'e', must not be
    zero. See section [Floating point
    variables](#Floating-point-variables), for more information on
    scientific notation.)
    []{#index-FE_005fINEXACT-floating_002dpoint-exception}
-   `FE_INEXACT`: The "Inexact" exception. Raised if a rounded result is
    not exact, for example when calculating an irrational number such as
    the square root of 2.

[]{#index-fetestexcept-function}
[]{#index-FE_005fALL_005fEXCEPT-function}

You can test for these exceptions with the `fetestexcept` function,
which takes one parameter, a bitwise OR'd list of the exception flags
from the list above for which you are testing, and returns a nonzero
value containing a bitwise OR'd list of the flags you passed it for the
exceptions that actually occurred. You can also clear selected flags
with the `feclearexcept` function, which accepts a bitwise-OR'd list of
exception flags to clear, and returns zero if it was successful. (You
can pass either of these function the macro `FE_ALL_EXCEPT`, which
contains all of the floating-point exception flags OR'd together.)

In case this explanation is unclear, let's look at a practical example.

------------------------------------------------------------------------

[]{#Introduction-to-GDB}

  -------------------------------------------------------------------- --------------------------------------------------------- --- ------------------------------------------------------------------------ ----------------------------------- ---------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Mathematical-errors "Previous section in reading order")\]   \[[\>](#Questions-23 "Next section in reading order")\]       \[[\<\<](#Debugging "Beginning of this chapter or previous chapter")\]   \[[Up](#Debugging "Up section")\]   \[[\>\>](#Example-programs "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  -------------------------------------------------------------------- --------------------------------------------------------- --- ------------------------------------------------------------------------ ----------------------------------- ---------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Introduction-to-GDB-1}

23.5 Introduction to GDB {#introduction-to-gdb .section}
------------------------

[]{#index-GDB_002c-introduction-to}

Blah blah blah.

------------------------------------------------------------------------

[]{#Questions-23}

  -------------------------------------------------------------------- ------------------------------------------------------------- --- ------------------------------------------------------------------------ ----------------------------------- ---------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Introduction-to-GDB "Previous section in reading order")\]   \[[\>](#Example-programs "Next section in reading order")\]       \[[\<\<](#Debugging "Beginning of this chapter or previous chapter")\]   \[[Up](#Debugging "Up section")\]   \[[\>\>](#Example-programs "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  -------------------------------------------------------------------- ------------------------------------------------------------- --- ------------------------------------------------------------------------ ----------------------------------- ---------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Questions-23-1}

23.6 Questions 23 {#questions-23 .section}
-----------------

Spot the errors in the following:

Blah blah blah.

------------------------------------------------------------------------

[]{#Example-programs}

  ------------------------------------------------------------- ---------------------------------------------------------------------------- --- ------------------------------------------------------------------------ ----------------------------- ------------------------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Questions-23 "Previous section in reading order")\]   \[[\>](#A-note-from-the-original-author "Next section in reading order")\]       \[[\<\<](#Debugging "Beginning of this chapter or previous chapter")\]   \[[Up](#Top "Up section")\]   \[[\>\>](#A-note-from-the-original-author "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ------------------------------------------------------------- ---------------------------------------------------------------------------- --- ------------------------------------------------------------------------ ----------------------------- ------------------------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Example-programs-1}

24. Example programs {#example-programs .chapter}
====================

[]{#index-Example-program_002c-substantial} []{#index-Disk-input}
[]{#index-Disk-output} []{#index-Input_002c-disk}
[]{#index-Output_002c-disk} []{#index-GNU-long-options-1}
[]{#index-Long-options_002c-GNU-1} []{#index-Linked-lists-1}
[]{#index-Lists_002c-linked-1}

The aim of this section is to provide a substantial example of C
programming, using input from and output to disk, GNU-style long
options, and the linked list data structure (including insertion,
deletion, and sorting of nodes).

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | #include <stdio.h>                |
|                                   | #include <string.h>               |
|                                   | #include <argp.h>                 |
|                                   |                                   |
|                                   | #define NAME_LEN 100              |
|                                   | #define ADDR_LEN 500              |
|                                   |                                   |
|                                   | const char *argp_program_version  |
|                                   | =                                 |
|                                   | "bigex 1.0";                      |
|                                   |                                   |
|                                   | const char *argp_program_bug_addr |
|                                   | ess =                             |
|                                   | "<bug-gnu-utilsgnu.org>";         |
|                                   |                                   |
|                                   |                                   |
|                                   | /* This structure is used by main |
|                                   |  to communicate with parse_opt. * |
|                                   | /                                 |
|                                   | struct arguments                  |
|                                   | {                                 |
|                                   |   char *args[1];            /* No |
|                                   |  arguments to this function */    |
|                                   |   int verbose;              /* Th |
|                                   | e -v flag */                      |
|                                   |   char *infile;             /* Ar |
|                                   | gument for -i */                  |
|                                   |   char *outfile;            /* Ar |
|                                   | gument for -o */                  |
|                                   | };                                |
|                                   |                                   |
|                                   |                                   |
|                                   | struct personal_data              |
|                                   | {                                 |
|                                   |   char name[NAME_LEN];            |
|                                   |   char address[ADDR_LEN];         |
|                                   |   struct personal_data *next;     |
|                                   | };                                |
|                                   |                                   |
|                                   |                                   |
|                                   | /*                                |
|                                   |   OPTIONS.  Field 1 in ARGP.      |
|                                   |   Order of fields: {NAME, KEY, AR |
|                                   | G, FLAGS, DOC}.                   |
|                                   | */                                |
|                                   | static struct argp_option options |
|                                   | [] =                              |
|                                   |   {                               |
|                                   |     {"verbose", 'v', 0, 0, "Produ |
|                                   | ce verbose output"},              |
|                                   |                                   |
|                                   |     {"input",   'i', "INFILE",  0 |
|                                   | ,                                 |
|                                   |      "Read addresses from INFILE" |
|                                   | },                                |
|                                   |                                   |
|                                   |     {"output",  'o', "OUTFILE", 0 |
|                                   | ,                                 |
|                                   |      "Output to OUTFILE instead o |
|                                   | f to standard output"},           |
|                                   |                                   |
|                                   |     {0}                           |
|                                   |   };                              |
|                                   |                                   |
|                                   |                                   |
|                                   | /*                                |
|                                   |   PARSER. Field 2 in ARGP.        |
|                                   |   Order of parameters: KEY, ARG,  |
|                                   | STATE.                            |
|                                   | */                                |
|                                   | static error_t                    |
|                                   | parse_opt (int key, char *arg, st |
|                                   | ruct argp_state *state)           |
|                                   | {                                 |
|                                   |   struct arguments *arguments = s |
|                                   | tate->input;                      |
|                                   |                                   |
|                                   |   switch (key)                    |
|                                   |     {                             |
|                                   |     case 'v':                     |
|                                   |       arguments->verbose = 1;     |
|                                   |       break;                      |
|                                   |     case 'i':                     |
|                                   |       arguments->infile = arg;    |
|                                   |       break;                      |
|                                   |     case 'o':                     |
|                                   |       arguments->outfile = arg;   |
|                                   |       break;                      |
|                                   |     case ARGP_KEY_ARG:            |
|                                   |       if (state->arg_num >= 1)    |
|                                   |     {                             |
|                                   |       argp_usage(state);          |
|                                   |     }                             |
|                                   |       arguments->args[state->arg_ |
|                                   | num] = arg;                       |
|                                   |       break;                      |
|                                   |     case ARGP_KEY_END:            |
|                                   |       if (state->arg_num < 1)     |
|                                   |     {                             |
|                                   |       argp_usage (state);         |
|                                   |     }                             |
|                                   |       break;                      |
|                                   |     default:                      |
|                                   |       return ARGP_ERR_UNKNOWN;    |
|                                   |     }                             |
|                                   |   return 0;                       |
|                                   | }                                 |
|                                   |                                   |
|                                   |                                   |
|                                   | /*                                |
|                                   |   ARGS_DOC. Field 3 in ARGP.      |
|                                   |   A description of the non-option |
|                                   |  command-line arguments           |
|                                   |   that we accept.                 |
|                                   | */                                |
|                                   | static char args_doc[] = "ARG";   |
|                                   |                                   |
|                                   |                                   |
|                                   | /*                                |
|                                   |   DOC.  Field 4 in ARGP.          |
|                                   |   Program documentation.          |
|                                   | */                                |
|                                   | static char doc[] =               |
|                                   | "bigex -- Add ARG new names to an |
|                                   |  address book file.\vThe largest  |
|                                   | code example in the GNU C Tutoria |
|                                   | l.";                              |
|                                   |                                   |
|                                   |                                   |
|                                   | /*                                |
|                                   |   The ARGP structure itself.      |
|                                   | */                                |
|                                   | static struct argp argp = {option |
|                                   | s, parse_opt, args_doc, doc};     |
|                                   |                                   |
|                                   |                                   |
|                                   | struct personal_data *            |
|                                   | new_empty_node()                  |
|                                   | {                                 |
|                                   |   struct personal_data *new_node; |
|                                   |                                   |
|                                   |   new_node =  (struct personal_da |
|                                   | ta*)                              |
|                                   |     malloc (sizeof (struct person |
|                                   | al_data));                        |
|                                   |                                   |
|                                   |   strcpy (new_node->name, "");    |
|                                   |   strcpy (new_node->address, ""); |
|                                   |   new_node->next = NULL;          |
|                                   |                                   |
|                                   |   return new_node;                |
|                                   | }                                 |
|                                   |                                   |
|                                   |                                   |
|                                   | struct personal_data *            |
|                                   | create_node()                     |
|                                   | {                                 |
|                                   |   int bytes_read;                 |
|                                   |   int nbytes;                     |
|                                   |                                   |
|                                   |   struct personal_data *current_n |
|                                   | ode;                              |
|                                   |   char *name;                     |
|                                   |   char *address;                  |
|                                   |                                   |
|                                   |   current_node = new_empty_node() |
|                                   | ;                                 |
|                                   |                                   |
|                                   |   puts ("Name?");                 |
|                                   |   nbytes = NAME_LEN;              |
|                                   |   name = (char *) malloc (nbytes  |
|                                   | + 1);                             |
|                                   |   bytes_read = getline (&name, &n |
|                                   | bytes, stdin);                    |
|                                   |   if (bytes_read == -1)           |
|                                   |     {                             |
|                                   |       puts ("ERROR!");            |
|                                   |     }                             |
|                                   |   else                            |
|                                   |     {                             |
|                                   |       strncpy (current_node->name |
|                                   | , name, NAME_LEN);                |
|                                   |       free (name);                |
|                                   |     }                             |
|                                   |                                   |
|                                   |   puts ("Address?");              |
|                                   |   nbytes = ADDR_LEN;              |
|                                   |   address = (char *) malloc (nbyt |
|                                   | es + 1);                          |
|                                   |   bytes_read = getline (&address, |
|                                   |  &nbytes, stdin);                 |
|                                   |   if (bytes_read == -1)           |
|                                   |     {                             |
|                                   |       puts ("ERROR!");            |
|                                   |     }                             |
|                                   |   else                            |
|                                   |     {                             |
|                                   |       strncpy (current_node->addr |
|                                   | ess, address, ADDR_LEN);          |
|                                   |       free (address);             |
|                                   |     }                             |
|                                   |                                   |
|                                   |   printf("\n");                   |
|                                   |   return current_node;            |
|                                   | }                                 |
|                                   |                                   |
|                                   |                                   |
|                                   |                                   |
|                                   | struct personal_data *            |
|                                   | find_end_node (struct personal_da |
|                                   | ta *current_node)                 |
|                                   | {                                 |
|                                   |   if (current_node->next == NULL) |
|                                   |     {                             |
|                                   |       return current_node;        |
|                                   |     }                             |
|                                   |   else                            |
|                                   |     {                             |
|                                   |       return find_end_node (curre |
|                                   | nt_node->next);                   |
|                                   |     }                             |
|                                   | }                                 |
|                                   |                                   |
|                                   |                                   |
|                                   | int                               |
|                                   | list_length (struct personal_data |
|                                   |  *root)                           |
|                                   | {                                 |
|                                   |   struct personal_data *current_n |
|                                   | ode;                              |
|                                   |   int count = 0;                  |
|                                   |                                   |
|                                   |   current_node = root;            |
|                                   |                                   |
|                                   |   while (current_node->next != NU |
|                                   | LL)                               |
|                                   |     {                             |
|                                   |       current_node = current_node |
|                                   | ->next;                           |
|                                   |       count++;                    |
|                                   |     }                             |
|                                   |   return count;                   |
|                                   | }                                 |
|                                   |                                   |
|                                   |                                   |
|                                   | struct personal_data *            |
|                                   | find_node (struct personal_data * |
|                                   | root,                             |
|                                   |        int node_wanted)           |
|                                   | {                                 |
|                                   |   struct personal_data *current_n |
|                                   | ode;                              |
|                                   |   int index = 0;                  |
|                                   |                                   |
|                                   |   current_node = root;            |
|                                   |                                   |
|                                   |   while ((index < node_wanted) && |
|                                   |  (current_node->next != NULL))    |
|                                   |     {                             |
|                                   |       current_node = current_node |
|                                   | ->next;                           |
|                                   |       index++;                    |
|                                   |     }                             |
|                                   |   return current_node;            |
|                                   | }                                 |
|                                   |                                   |
|                                   |                                   |
|                                   |                                   |
|                                   | delete_node (struct personal_data |
|                                   |  *root,                           |
|                                   |          int location)            |
|                                   | {                                 |
|                                   |   struct personal_data *previous_ |
|                                   | node;                             |
|                                   |   struct personal_data *current_n |
|                                   | ode;                              |
|                                   |                                   |
|                                   |   previous_node = find_node (root |
|                                   | , location - 1);                  |
|                                   |   current_node = find_node (root, |
|                                   |  location);                       |
|                                   |   previous_node->next = current_n |
|                                   | ode->next;                        |
|                                   | }                                 |
|                                   |                                   |
|                                   |                                   |
|                                   |                                   |
|                                   | insert_node (struct personal_data |
|                                   |  *root,                           |
|                                   |          struct personal_data *ne |
|                                   | w_node,                           |
|                                   |          int location)            |
|                                   | {                                 |
|                                   |   struct personal_data *temp_ptr; |
|                                   |   struct personal_data *previous_ |
|                                   | node;                             |
|                                   |                                   |
|                                   |   previous_node = find_node (root |
|                                   | , location - 1);                  |
|                                   |   temp_ptr = previous_node->next; |
|                                   |                                   |
|                                   |   previous_node->next = new_node; |
|                                   |   new_node->next = temp_ptr;      |
|                                   | }                                 |
|                                   |                                   |
|                                   |                                   |
|                                   | swap_nodes (struct personal_data  |
|                                   | *root, int a, int b)              |
|                                   | {                                 |
|                                   |   int temp;                       |
|                                   |   struct personal_data *node_a;   |
|                                   |   struct personal_data *node_b;   |
|                                   |   struct personal_data *temp_node |
|                                   | ;                                 |
|                                   |                                   |
|                                   |   if (a > b)                      |
|                                   |     {                             |
|                                   |       temp = a;                   |
|                                   |       a = b;                      |
|                                   |       b = temp;                   |
|                                   |     }                             |
|                                   |                                   |
|                                   |   node_b = find_node (root, b);   |
|                                   |   delete_node (root, b);          |
|                                   |                                   |
|                                   |   node_a = find_node (root, a);   |
|                                   |   delete_node (root, a);          |
|                                   |                                   |
|                                   |   insert_node (root, node_b, a);  |
|                                   |   insert_node (root, node_a, b);  |
|                                   | }                                 |
|                                   |                                   |
|                                   |                                   |
|                                   | sort_list (struct personal_data * |
|                                   | root)                             |
|                                   | {                                 |
|                                   |   int i, j, list_len, diff;       |
|                                   |                                   |
|                                   |   list_len = list_length (root);  |
|                                   |   for (i=2; i<=list_len; i++)     |
|                                   |     {                             |
|                                   |       j = i;                      |
|                                   |       while (strcmp ( (find_node( |
|                                   | root, j))->name,                  |
|                                   |               (find_node(root, j- |
|                                   | 1))->name) < 0)                   |
|                                   |     {                             |
|                                   |       swap_nodes (root, j, j-1);  |
|                                   |       j--;                        |
|                                   |     }                             |
|                                   |     }                             |
|                                   | }                                 |
|                                   |                                   |
|                                   |                                   |
|                                   | print_node (struct personal_data  |
|                                   | *current_node,                    |
|                                   |         FILE *save_stream)        |
|                                   | {                                 |
|                                   |   fprintf (save_stream, "%s%s",   |
|                                   |        current_node->name,        |
|                                   |        current_node->address);    |
|                                   | }                                 |
|                                   |                                   |
|                                   |                                   |
|                                   | print_list (struct personal_data  |
|                                   | *current_node,                    |
|                                   |         FILE *save_stream)        |
|                                   | {                                 |
|                                   |   print_node (current_node, save_ |
|                                   | stream);                          |
|                                   |                                   |
|                                   |   if (current_node->next != NULL) |
|                                   |     {                             |
|                                   |       print_list (current_node->n |
|                                   | ext, save_stream);                |
|                                   |     }                             |
|                                   | }                                 |
|                                   |                                   |
|                                   |                                   |
|                                   |                                   |
|                                   |                                   |
|                                   | struct personal_data *            |
|                                   | read_node (FILE *instream)        |
|                                   | {                                 |
|                                   |   int bytes_read;                 |
|                                   |   int nbytes;                     |
|                                   |                                   |
|                                   |   struct personal_data *current_n |
|                                   | ode;                              |
|                                   |   char *name;                     |
|                                   |   char *address;                  |
|                                   |   char *blankline;                |
|                                   |   int read_err = 0;               |
|                                   |                                   |
|                                   |   current_node = new_empty_node() |
|                                   | ;                                 |
|                                   |                                   |
|                                   |   nbytes = NAME_LEN;              |
|                                   |   name = (char *) malloc (nbytes  |
|                                   | + 1);                             |
|                                   |   bytes_read = getline (&name, &n |
|                                   | bytes, instream);                 |
|                                   |   if (bytes_read == -1)           |
|                                   |     {                             |
|                                   |       read_err = 1;               |
|                                   |     }                             |
|                                   |   else                            |
|                                   |     {                             |
|                                   |       puts (name);                |
|                                   |       strncpy (current_node->name |
|                                   | , name, NAME_LEN);                |
|                                   |       free (name);                |
|                                   |     }                             |
|                                   |                                   |
|                                   |   nbytes = ADDR_LEN;              |
|                                   |   address = (char *) malloc (nbyt |
|                                   | es + 1);                          |
|                                   |   bytes_read = getline (&address, |
|                                   |  &nbytes, instream);              |
|                                   |   if (bytes_read == -1)           |
|                                   |     {                             |
|                                   |       read_err = 1;               |
|                                   |     }                             |
|                                   |   else                            |
|                                   |     {                             |
|                                   |       puts (address);             |
|                                   |       strncpy (current_node->addr |
|                                   | ess, address, ADDR_LEN);          |
|                                   |       free (address);             |
|                                   |     }                             |
|                                   |                                   |
|                                   |   if (read_err)                   |
|                                   |     {                             |
|                                   |       return NULL;                |
|                                   |     }                             |
|                                   |   else                            |
|                                   |     {                             |
|                                   |       return current_node;        |
|                                   |     }                             |
|                                   | }                                 |
|                                   |                                   |
|                                   |                                   |
|                                   | struct personal_data *            |
|                                   | read_file (char *infile)          |
|                                   | {                                 |
|                                   |   FILE *input_stream = NULL;      |
|                                   |   struct personal_data *root;     |
|                                   |   struct personal_data *end_node; |
|                                   |   struct personal_data *current_n |
|                                   | ode;                              |
|                                   |                                   |
|                                   |   root = new_empty_node();        |
|                                   |   end_node = root;                |
|                                   |                                   |
|                                   |   input_stream = fopen (infile, " |
|                                   | r");                              |
|                                   |   if (input_stream)               |
|                                   |     {                             |
|                                   |       while (current_node = read_ |
|                                   | node (input_stream))              |
|                                   |     {                             |
|                                   |       end_node->next = current_no |
|                                   | de;                               |
|                                   |       end_node = current_node;    |
|                                   |       end_node->next = NULL;      |
|                                   |     }                             |
|                                   |     }                             |
|                                   |   return root;                    |
|                                   | }                                 |
|                                   |                                   |
|                                   |                                   |
|                                   |                                   |
|                                   | /*                                |
|                                   |   The main function.              |
|                                   |   Notice how now the only functio |
|                                   | n call needed to process          |
|                                   |   all command-line options and ar |
|                                   | guments nicely                    |
|                                   |   is argp_parse.                  |
|                                   | */                                |
|                                   | int                               |
|                                   | main (int argc, char **argv)      |
|                                   | {                                 |
|                                   |   struct arguments arguments;     |
|                                   |   struct personal_data *root;     |
|                                   |   struct personal_data *end_node; |
|                                   |   struct personal_data *current_n |
|                                   | ode;                              |
|                                   |   int i, newnum;                  |
|                                   |   FILE *save_stream;              |
|                                   |                                   |
|                                   |                                   |
|                                   |   /* Set argument defaults */     |
|                                   |   arguments.infile = NULL;        |
|                                   |   arguments.outfile = NULL;       |
|                                   |   arguments.verbose = 0;          |
|                                   |                                   |
|                                   |   /* Where the magic happens */   |
|                                   |   argp_parse (&argp, argc, argv,  |
|                                   | 0, 0, &arguments);                |
|                                   |                                   |
|                                   |   if (arguments.infile)           |
|                                   |     {                             |
|                                   |       root = read_file (arguments |
|                                   | .infile);                         |
|                                   |       end_node = find_end_node (r |
|                                   | oot);                             |
|                                   |     }                             |
|                                   |   else                            |
|                                   |     {                             |
|                                   |       root = new_empty_node();    |
|                                   |       end_node = root;            |
|                                   |     }                             |
|                                   |                                   |
|                                   |   /* Where do we send output? */  |
|                                   |   if (arguments.outfile)          |
|                                   |     save_stream = fopen (argument |
|                                   | s.outfile, "w");                  |
|                                   |   else                            |
|                                   |     save_stream = stdout;         |
|                                   |                                   |
|                                   |   newnum = atoi (arguments.args[0 |
|                                   | ]);                               |
|                                   |                                   |
|                                   |   for (i = 1; i <= newnum; i++)   |
|                                   |     {                             |
|                                   |       current_node = create_node( |
|                                   | );                                |
|                                   |       end_node->next = current_no |
|                                   | de;                               |
|                                   |       end_node = current_node;    |
|                                   |       end_node->next = NULL;      |
|                                   |     }                             |
|                                   |                                   |
|                                   |   sort_list (root);               |
|                                   |   print_list (root->next, save_st |
|                                   | ream);                            |
|                                   |                                   |
|                                   |   /* Close stream; skip error-che |
|                                   | cking for brevity of example */   |
|                                   |   fclose (save_stream);           |
|                                   |                                   |
|                                   |   /* If in verbose mode, print so |
|                                   | ng stanza */                      |
|                                   |   if (arguments.verbose)          |
|                                   |     {};                           |
|                                   |                                   |
|                                   |   return 0;                       |
|                                   | }                                 |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

------------------------------------------------------------------------

[]{#A-note-from-the-original-author}

  ----------------------------------------------------------------- ---------------------------------------------------------------- --- ------------------------------------------------------------------------------- ----------------------------- ------------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Example-programs "Previous section in reading order")\]   \[[\>](#Reserved-words-in-C "Next section in reading order")\]       \[[\<\<](#Example-programs "Beginning of this chapter or previous chapter")\]   \[[Up](#Top "Up section")\]   \[[\>\>](#Reserved-words-in-C "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ----------------------------------------------------------------- ---------------------------------------------------------------- --- ------------------------------------------------------------------------------- ----------------------------- ------------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#A-note-from-the-original-author-1}

A. A note from the original author {#a.-a-note-from-the-original-author .appendix}
==================================

This book began life in 1987 as one of the early books on C programming.
I wrote it during a summer vacation from University, in England in 1987.
It was published by Dabs Press, a small publishing house which
specialized in books for microcomputers, particularly Acorn's classic
BBC micro. With the arrival of the Amiga, I was able to obtain a C
compiler. I had had my eye on C for some time, and I felt at the time,
that it was the best language I had seen to date for system programming.
The publisher and I decided that C would become the 'BASIC' of the
16-bit microcomputer world, which it did. C took off, and the book sold
very well for a number of years. As the contract expired, the book was
lost in my files, until I met Richard Stallman and he asked me if I
would give the tutorial to GNU. I agreed to recover the original files
from diskettes and partly re-work them, to remove the emphasis from
micro-computers and over to GNU. The result of that work was the first
version of the tutorial. Having handed over the merchandise, I agreed
that it would be a good thing for others to update and improve the
tutorial. My only requirement was that I would be allowed to explain a
few changes for which I would not want to be blamed. I cannot insist
that such changes will not be made, but I can at least distance myself
from them. They are fairly picky and even silly things, but for one
reason or another, they mean a lot to me. The first has to do with
grammar. The grammar which is written and printed in books today is
often incorrect. Many colloquialisms and vernacular perversions of
grammar are printed and believed to be correct. I am fairly sure that no
such errors are mine! The other thing has to do with the style and
formatting of C code. The placement of curly braces is something about
which I agree with only a handful of people on the planet. Kernighan and
Ritchie's original placement of curly braces is so horrendous that I
would go so far as to call it \"wrong\", logically and aesthetically.
The GNU indentation, which positions braces of the same level in
straight vertical alignment, is much better, but in my opinion it gets
its indentation wrong. I would indent 3 positions before the first
brace, and keep the text within braces aligned with the braces
themselves, rather than indenting within the braces, as GNU does. That,
in my personal opinion, makes it easier to identify text and braces
belonging together, and leads to optimal clarity. I also insist that
curly braces be used around single statements, in loops and tests, even
when not strictly required by the language. Finally, having grown up in
England and lived in Norway, which have contradictory punctuation rules,
I am utterly confused about punctuation and have probably made many
errors. With that little spiel said, I now pass the torch to future
authors and wish everyone luck. I am happy to see an old summer job not
go to waste.

Mark Burgess, Oslo March 2001

------------------------------------------------------------------------

[]{#Reserved-words-in-C}

  -------------------------------------------------------------------------------- -------------------------------------------------------------------- --- ---------------------------------------------------------------------------------------------- ----------------------------- ----------------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#A-note-from-the-original-author "Previous section in reading order")\]   \[[\>](#Precedence-of-operators "Next section in reading order")\]       \[[\<\<](#A-note-from-the-original-author "Beginning of this chapter or previous chapter")\]   \[[Up](#Top "Up section")\]   \[[\>\>](#Precedence-of-operators "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  -------------------------------------------------------------------------------- -------------------------------------------------------------------- --- ---------------------------------------------------------------------------------------------- ----------------------------- ----------------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Reserved-words-in-C-1}

B. Reserved words in C {#b.-reserved-words-in-c .appendix}
======================

[]{#index-Reserved-words-in-C} []{#index-C_002c-reserved-words-in}

Blah blah blah.

Here is a list of all the reserved words in C. The set of reserved words
above is used to build up the basic instructions of C; you can not use
them in programs your write

Please note that this list is somewhat misleading. Many more words are
out of bounds. This is because most of the facilities which C offers are
in libraries that are included in programs. Once a library has been
included in a program, its functions are defined and you cannot use
their names yourself.

C requires all of these reserved words to be in lower case. (This does
mean that, typed in upper case, the reserved words could be used as
variable names, but this is not recommended.)

(A \"d\" by the word implies that it is used as part of a declaration.)

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | auto d                   if       |
|                                   |      break                        |
|                                   |  int d                            |
|                                   |      case                         |
|                                   |  long d                           |
|                                   |      char d                   reg |
|                                   | ister d                           |
|                                   |      continue                     |
|                                   |  return                           |
|                                   |      default                      |
|                                   |  short d                          |
|                                   |      do                           |
|                                   |  sizeof                           |
|                                   |      double d                 sta |
|                                   | tic d                             |
|                                   |      else                         |
|                                   |  struct                           |
|                                   |      entry                        |
|                                   |  switch                           |
|                                   |      extern d                 typ |
|                                   | edef d                            |
|                                   |      float d                  uni |
|                                   | on d                              |
|                                   |      for                          |
|                                   |  unsigned d                       |
|                                   |      goto                         |
|                                   |  while                            |
|                                   |                                   |
|                                   |      also in modern implementatio |
|                                   | ns:                               |
|                                   |                                   |
|                                   |      enum d                       |
|                                   |      void d                       |
|                                   |                                   |
|                                   |      const d                      |
|                                   |      signed d                     |
|                                   |      volatile d                   |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

------------------------------------------------------------------------

[]{#Precedence-of-operators}

  -------------------------------------------------------------------- --------------------------------------------------------------- --- ---------------------------------------------------------------------------------- ----------------------------- ------------------------------------------------ --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Reserved-words-in-C "Previous section in reading order")\]   \[[\>](#Special-characters "Next section in reading order")\]       \[[\<\<](#Reserved-words-in-C "Beginning of this chapter or previous chapter")\]   \[[Up](#Top "Up section")\]   \[[\>\>](#Special-characters "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  -------------------------------------------------------------------- --------------------------------------------------------------- --- ---------------------------------------------------------------------------------- ----------------------------- ------------------------------------------------ --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Precedence-of-operators-1}

C. Precedence of operators {#c.-precedence-of-operators .appendix}
==========================

[]{#index-Operators_002c-precedence-of}
[]{#index-Precedence-of-operators}

The highest priority operators are listed first.

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | Operator         Operation        |
|                                   |               Evaluated           |
|                                   |                                   |
|                                   |     ()              parentheses   |
|                                   |                  left to right    |
|                                   |     []              square bracke |
|                                   | ts               left to right    |
|                                   |                                   |
|                                   |     ++              increment     |
|                                   |                  right to left    |
|                                   |     --              decrement     |
|                                   |                  right to left    |
|                                   |   (type)            cast operator |
|                                   |                  right to left    |
|                                   |     *               the contents  |
|                                   | of               right to left    |
|                                   |     &               the address o |
|                                   | f                right to left    |
|                                   |     -               unary minus   |
|                                   |                  right to left    |
|                                   |     ~               one's complem |
|                                   | ent              right to left    |
|                                   |     !               logical NOT   |
|                                   |                  right to left    |
|                                   |                                   |
|                                   |     *               multiply      |
|                                   |                  left to right    |
|                                   |     /               divide        |
|                                   |                  left to right    |
|                                   |     %               remainder (MO |
|                                   | D)               left to right    |
|                                   |                                   |
|                                   |     +               add           |
|                                   |                  left to right    |
|                                   |     -               subtract      |
|                                   |                  left to right    |
|                                   |                                   |
|                                   |     >>              shift right   |
|                                   |                  left to right    |
|                                   |     <<              shift left    |
|                                   |                  left to right    |
|                                   |                                   |
|                                   |     >               is greater th |
|                                   | an               left to right    |
|                                   |     >=              greater than  |
|                                   | or equal to      left to right    |
|                                   |     <=              less than or  |
|                                   | equal to         left to right    |
|                                   |     <               less than     |
|                                   |                  left to right    |
|                                   |                                   |
|                                   |     ==              is equal to   |
|                                   |                  left to right    |
|                                   |     !=              is not equal  |
|                                   | to               left to right    |
|                                   |                                   |
|                                   |     &               bitwise AND   |
|                                   |                  left to right    |
|                                   |     ^               bitwise exclu |
|                                   | sive OR          left to right    |
|                                   |     |               bitwsie inclu |
|                                   | dive OR          left to right    |
|                                   |     &&              logical AND   |
|                                   |                  left to right    |
|                                   |     ||              logical OR    |
|                                   |                  left to right    |
|                                   |                                   |
|                                   |     =               assign        |
|                                   |                  right to left    |
|                                   |     +=              add assign    |
|                                   |                  right to left    |
|                                   |     -=              subtract assi |
|                                   | gn               right to left    |
|                                   |     *=              multiply assi |
|                                   | gn               right to left    |
|                                   |     /=              divide assign |
|                                   |                  right to left    |
|                                   |     %=              remainder ass |
|                                   | ign              right to left    |
|                                   |     >>=             right shift a |
|                                   | ssign            right to left    |
|                                   |     <<=             left shift as |
|                                   | sign             right to left    |
|                                   |     &=              AND assign    |
|                                   |                  right to left    |
|                                   |     ^=              exclusive OR  |
|                                   | assign           right to left    |
|                                   |     |=              inclusive OR  |
|                                   | assign           right to left    |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

------------------------------------------------------------------------

[]{#Special-characters}

  ------------------------------------------------------------------------ ----------------------------------------------------------------------- --- -------------------------------------------------------------------------------------- ----------------------------- -------------------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Precedence-of-operators "Previous section in reading order")\]   \[[\>](#Character-conversion-table "Next section in reading order")\]       \[[\<\<](#Precedence-of-operators "Beginning of this chapter or previous chapter")\]   \[[Up](#Top "Up section")\]   \[[\>\>](#Character-conversion-table "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ------------------------------------------------------------------------ ----------------------------------------------------------------------- --- -------------------------------------------------------------------------------------- ----------------------------- -------------------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Special-characters-1}

D. Special characters {#d.-special-characters .appendix}
=====================

[]{#index-Special-characters} []{#index-Characters_002c-special}

Control characters are invisible on the screen. They have special
purposes usually to do with cursor movement and are written into an
ordinary string or character by typing a backslash character \\ followed
by some other character. These characters are listed below.

A character can be any ASCII character, printable or not printable from
values -128 to 127. (But only 0 to 127 are used.) Control characters
i.e. non printable characters are put into programs by using a backslash
`\` and a special character or number. The characters and their meanings
are:

 '\\b'

:   backspace BS

 '\\f'

:   form feed FF (also clear screen)

 '\\n'

:   new line NL (like pressing return)

 '\\r'

:   carriage return CR (cursor to start of line)

 '\\t'

:   horizontal tab HT

 '\\v'

:   vertical tab (not all versions)

 '\\x'

:   ???

 '\\\"'

:   double quotes (not all versions)

 '\\\''

:   single quote character '

 '\\\\'

:   backslash character \\

 '\\ddd'

:   character ddd where ddd is an ASCII code given in octal or base 8.
    (See Appendix C)

Here is a code example that prints special characters:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | /******************************** |
|                                   | *******************/              |
|                                   | /*                                |
|                                   |                   */              |
|                                   | /* Special Characters             |
|                                   |                   */              |
|                                   | /*                                |
|                                   |                   */              |
|                                   | /******************************** |
|                                   | *******************/              |
|                                   |                                   |
|                                   | #include <stdio.h>                |
|                                   |                                   |
|                                   | main ()                           |
|                                   |                                   |
|                                   | {                                 |
|                                   | printf ("Beep! \7 \n");           |
|                                   | printf ("ch = \'a\' \n");         |
|                                   | printf (" <- Start of this line!! |
|                                   |  \r");                            |
|                                   | }                                 |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

The output of this program is:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | Beep!  (and the BELL sound)       |
|                                   | ch = 'a'                          |
|                                   |  <- Start of this line!!          |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

and the text cursor is left where the arrow points.

------------------------------------------------------------------------

[]{#Character-conversion-table}

  ------------------------------------------------------------------- -------------------------------------------------------------- --- --------------------------------------------------------------------------------- ----------------------------- ----------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Special-characters "Previous section in reading order")\]   \[[\>](#A-word-about-goto "Next section in reading order")\]       \[[\<\<](#Special-characters "Beginning of this chapter or previous chapter")\]   \[[Up](#Top "Up section")\]   \[[\>\>](#A-word-about-goto "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ------------------------------------------------------------------- -------------------------------------------------------------- --- --------------------------------------------------------------------------------- ----------------------------- ----------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Character-conversion-table-1}

E. Character conversion table {#e.-character-conversion-table .appendix}
=============================

[]{#index-Character-conversion-table}
[]{#index-Conversion-table_002c-character}

This table lists the decimal, octal, and hexadecimal numbers for
characters 0 -- 127.

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | Decimal  Octal  Hexadecimal  Char |
|                                   | acter                             |
|                                   |                                   |
|                                   |   0       0          0         CT |
|                                   | RL-@                              |
|                                   |   1       1          1         CT |
|                                   | RL-A                              |
|                                   |   2       2          2         CT |
|                                   | RL-B                              |
|                                   |   3       3          3         CT |
|                                   | RL-C                              |
|                                   |   4       4          4         CT |
|                                   | RL-D                              |
|                                   |   5       5          5         CT |
|                                   | RL-E                              |
|                                   | ```                               |
|                                   |                                   |
|                                   | ``` {.smallexample}               |
|                                   |   6       6          6         CT |
|                                   | RL-F                              |
|                                   |   7       7          7         CT |
|                                   | RL-G                              |
|                                   |   8      10          8         CT |
|                                   | RL-H                              |
|                                   |   9      11          9         CT |
|                                   | RL-I                              |
|                                   |  10      12          A         CT |
|                                   | RL-J                              |
|                                   |  11      13          B         CT |
|                                   | RL-K                              |
|                                   |  12      14          C         CT |
|                                   | RL-L                              |
|                                   |  13      15          D         CT |
|                                   | RL-M                              |
|                                   |  14      16          E         CT |
|                                   | RL-N                              |
|                                   |  15      17          F         CT |
|                                   | RL-O                              |
|                                   |  16      20         10         CT |
|                                   | RL-P                              |
|                                   |  17      21         11         CT |
|                                   | RL-Q                              |
|                                   |  18      22         12         CT |
|                                   | RL-R                              |
|                                   |  19      23         13         CT |
|                                   | RL-S                              |
|                                   |  20      24         14         CT |
|                                   | RL-T                              |
|                                   |  21      25         15         CT |
|                                   | RL-U                              |
|                                   |  22      26         16         CT |
|                                   | RL-V                              |
|                                   |  23      27         17         CT |
|                                   | RL-W                              |
|                                   |  24      30         18         CT |
|                                   | RL-X                              |
|                                   |  25      31         19         CT |
|                                   | RL-Y                              |
|                                   |  26      32         1A         CT |
|                                   | RL-Z                              |
|                                   |  27      33         1B         CT |
|                                   | RL-[                              |
|                                   |  28      34         1C         CT |
|                                   | RL-\                              |
|                                   |  29      35         1D         CT |
|                                   | RL-]                              |
|                                   |  30      36         1E         CT |
|                                   | RL-^                              |
|                                   |  31      37         1F         CT |
|                                   | RL-_                              |
|                                   |  32      40         20            |
|                                   |  33      41         21         !  |
|                                   |  34      42         22         "  |
|                                   |  35      43         23         #  |
|                                   |  36      44         24         $  |
|                                   |  37      45         25         %  |
|                                   |  38      46         26         &  |
|                                   |  39      47         27         '  |
|                                   |  40      50         28         (  |
|                                   |  41      51         29         )  |
|                                   |  42      52         2A         *  |
|                                   |  43      53         2B         +  |
|                                   |  44      54         2C         ,  |
|                                   |  45      55         2D         -  |
|                                   |  46      56         2E         .  |
|                                   |  47      57         2F         /  |
|                                   |  48      60         30         0  |
|                                   |  49      61         31         1  |
|                                   |  50      62         32         2  |
|                                   |  51      63         33         3  |
|                                   |  52      64         34         4  |
|                                   |  53      65         35         5  |
|                                   |  54      66         36         6  |
|                                   |  55      67         37         7  |
|                                   |  56      70         38         8  |
|                                   |  57      71         39         9  |
|                                   |  58      72         3A         :  |
|                                   |  59      73         3B         ;  |
|                                   |  60      74         3C         <  |
|                                   |  61      75         3D         =  |
|                                   |  62      76         3E         >  |
|                                   |  63      77         3F         ?  |
|                                   |  64     100         40         @  |
|                                   |  65     101         41         A  |
|                                   |  66     102         42         B  |
|                                   |  67     103         43         C  |
|                                   |  68     104         44         D  |
|                                   |  69     105         45         E  |
|                                   |  70     106         46         F  |
|                                   |  71     107         47         G  |
|                                   |  72     110         48         H  |
|                                   |  73     111         49         I  |
|                                   |  74     112         4A         J  |
|                                   |  75     113         4B         K  |
|                                   |  76     114         4C         L  |
|                                   |  77     115         4D         M  |
|                                   |  78     116         4E         N  |
|                                   |  79     117         4F         O  |
|                                   |  80     120         50         P  |
|                                   |  81     121         51         Q  |
|                                   |  82     122         52         R  |
|                                   |  83     123         53         S  |
|                                   |  84     124         54         T  |
|                                   |  85     125         55         U  |
|                                   |  86     126         56         V  |
|                                   |  87     127         57         W  |
|                                   |  88     130         58         X  |
|                                   |  89     131         59         Y  |
|                                   |  90     132         5A         Z  |
|                                   |  91     133         5B         [  |
|                                   |  92     134         5C         \  |
|                                   |  93     135         5D         ]  |
|                                   |  94     136         5E         ^  |
|                                   |  95     137         5F         _  |
|                                   |  96     140         60         `  |
|                                   |  97     141         61         a  |
|                                   |  98     142         62         b  |
|                                   |  99     143         63         c  |
|                                   | 100     144         64         d  |
|                                   | 101     145         65         e  |
|                                   | 102     146         66         f  |
|                                   | 103     147         67         g  |
|                                   | 104     150         68         h  |
|                                   | 105     151         69         i  |
|                                   | 106     152         6A         j  |
|                                   | 107     153         6B         k  |
|                                   | 108     154         6C         l  |
|                                   | 109     155         6D         m  |
|                                   | 110     156         6E         n  |
|                                   | 111     157         6F         o  |
|                                   | 112     160         70         p  |
|                                   | 113     161         71         q  |
|                                   | 114     162         72         r  |
|                                   | 115     163         73         s  |
|                                   | 116     164         74         t  |
|                                   | 117     165         75         u  |
|                                   | 118     166         76         v  |
|                                   | 119     167         77         w  |
|                                   | 120     170         78         x  |
|                                   | 121     171         79         y  |
|                                   | 122     172         7A         z  |
|                                   | 123     173         7B         {  |
|                                   | 124     174         7C         |  |
|                                   | 125     175         7D         }  |
|                                   | 126     176         7E         ~  |
|                                   | 127     177         7F         DE |
|                                   | L                                 |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

------------------------------------------------------------------------

[]{#A-word-about-goto}

  --------------------------------------------------------------------------- ----------------------------------------------------------------- --- ----------------------------------------------------------------------------------------- ----------------------------- -------------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Character-conversion-table "Previous section in reading order")\]   \[[\>](#Answers-to-questions "Next section in reading order")\]       \[[\<\<](#Character-conversion-table "Beginning of this chapter or previous chapter")\]   \[[Up](#Top "Up section")\]   \[[\>\>](#Answers-to-questions "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  --------------------------------------------------------------------------- ----------------------------------------------------------------- --- ----------------------------------------------------------------------------------------- ----------------------------- -------------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#A-word-about-goto-1}

F. A word about `goto` {#f.-a-word-about-goto .appendix}
======================

[]{#index-goto-command}

This word is redundant in C and encourages poor programming style. For
this reason it has been ignored in this book. For completeness, and for
those who insist on using it (may their programs recover gracefully) the
form of the goto statement is as follows:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | goto label;                       |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

`label` is an identifier which occurs somewhere else in the given
function and is defined as a label by using the colon:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | label : printf ("Ugh!  You used a |
|                                   |  goto!");                         |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

------------------------------------------------------------------------

[]{#Answers-to-questions}

  ------------------------------------------------------------------ --------------------------------------------------------- --- -------------------------------------------------------------------------------- ----------------------------- ------------------------------------------ --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#A-word-about-goto "Previous section in reading order")\]   \[[\>](#Bibliography "Next section in reading order")\]       \[[\<\<](#A-word-about-goto "Beginning of this chapter or previous chapter")\]   \[[Up](#Top "Up section")\]   \[[\>\>](#Bibliography "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ------------------------------------------------------------------ --------------------------------------------------------- --- -------------------------------------------------------------------------------- ----------------------------- ------------------------------------------ --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Answers-to-questions-1}

G. Answers to questions {#g.-answers-to-questions .appendix}
=======================

Blah blah blah.

------------------------------------------------------------------------

[]{#Bibliography}

  --------------------------------------------------------------------- ----------------------------------------------------- --- ----------------------------------------------------------------------------------- ----------------------------- -------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Answers-to-questions "Previous section in reading order")\]   \[[\>](#Glossary "Next section in reading order")\]       \[[\<\<](#Answers-to-questions "Beginning of this chapter or previous chapter")\]   \[[Up](#Top "Up section")\]   \[[\>\>](#Glossary "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  --------------------------------------------------------------------- ----------------------------------------------------- --- ----------------------------------------------------------------------------------- ----------------------------- -------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Bibliography-1}

Bibliography {#bibliography .unnumbered}
============

Blah blah blah.

------------------------------------------------------------------------

[]{#Glossary}

  ------------------------------------------------------------- ------------------------------------------------------- --- --------------------------------------------------------------------------- ----------------------------- ---------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Bibliography "Previous section in reading order")\]   \[[\>](#Code-index "Next section in reading order")\]       \[[\<\<](#Bibliography "Beginning of this chapter or previous chapter")\]   \[[Up](#Top "Up section")\]   \[[\>\>](#Code-index "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ------------------------------------------------------------- ------------------------------------------------------- --- --------------------------------------------------------------------------- ----------------------------- ---------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Glossary-1}

Glossary {#glossary .unnumbered}
========

Blah blah blah.

------------------------------------------------------------------------

[]{#Code-index}

  --------------------------------------------------------- ---------------------------------------------------------- --- ----------------------------------------------------------------------- ----------------------------- ------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Glossary "Previous section in reading order")\]   \[[\>](#Concept-index "Next section in reading order")\]       \[[\<\<](#Glossary "Beginning of this chapter or previous chapter")\]   \[[Up](#Top "Up section")\]   \[[\>\>](#Concept-index "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  --------------------------------------------------------- ---------------------------------------------------------- --- ----------------------------------------------------------------------- ----------------------------- ------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Code-index-1}

Code index {#code-index .unnumbered}
==========

  ------------ -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  Jump to:     [**\#**](#Code-index-1_fn_symbol-1){.summary-letter}   [**%**](#Code-index-1_fn_symbol-2){.summary-letter}   [**&**](#Code-index-1_fn_symbol-3){.summary-letter}   [**\'**](#Code-index-1_fn_symbol-4){.summary-letter}   [**\***](#Code-index-1_fn_symbol-5){.summary-letter}   [**+**](#Code-index-1_fn_symbol-6){.summary-letter}   [**,**](#Code-index-1_fn_symbol-7){.summary-letter}   [**-**](#Code-index-1_fn_symbol-8){.summary-letter}   [**.**](#Code-index-1_fn_symbol-9){.summary-letter}   [**/**](#Code-index-1_fn_symbol-10){.summary-letter}   [**0**](#Code-index-1_fn_symbol-11){.summary-letter}   [**\<**](#Code-index-1_fn_symbol-12){.summary-letter}   [**=**](#Code-index-1_fn_symbol-13){.summary-letter}   [**\>**](#Code-index-1_fn_symbol-14){.summary-letter}   [**?**](#Code-index-1_fn_symbol-15){.summary-letter}   [**\[**](#Code-index-1_fn_symbol-16){.summary-letter}   [**\^**](#Code-index-1_fn_symbol-17){.summary-letter}   [**\|**](#Code-index-1_fn_symbol-18){.summary-letter}   [**\~**](#Code-index-1_fn_symbol-19){.summary-letter}  \
               [**A**](#Code-index-1_fn_letter-A){.summary-letter}   [**B**](#Code-index-1_fn_letter-B){.summary-letter}   [**C**](#Code-index-1_fn_letter-C){.summary-letter}   [**D**](#Code-index-1_fn_letter-D){.summary-letter}   [**E**](#Code-index-1_fn_letter-E){.summary-letter}   [**F**](#Code-index-1_fn_letter-F){.summary-letter}   [**G**](#Code-index-1_fn_letter-G){.summary-letter}   [**H**](#Code-index-1_fn_letter-H){.summary-letter}   [**I**](#Code-index-1_fn_letter-I){.summary-letter}   [**K**](#Code-index-1_fn_letter-K){.summary-letter}   [**L**](#Code-index-1_fn_letter-L){.summary-letter}   [**M**](#Code-index-1_fn_letter-M){.summary-letter}   [**N**](#Code-index-1_fn_letter-N){.summary-letter}   [**O**](#Code-index-1_fn_letter-O){.summary-letter}   [**P**](#Code-index-1_fn_letter-P){.summary-letter}   [**Q**](#Code-index-1_fn_letter-Q){.summary-letter}   [**R**](#Code-index-1_fn_letter-R){.summary-letter}   [**S**](#Code-index-1_fn_letter-S){.summary-letter}   [**T**](#Code-index-1_fn_letter-T){.summary-letter}   [**U**](#Code-index-1_fn_letter-U){.summary-letter}   [**V**](#Code-index-1_fn_letter-V){.summary-letter}   [**W**](#Code-index-1_fn_letter-W){.summary-letter}   [**X**](#Code-index-1_fn_letter-X){.summary-letter}   [**Z**](#Code-index-1_fn_letter-Z){.summary-letter}  

  ------------ -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Index Entry

Section

------------------------------------------------------------------------

[\#]{#Code-index-1_fn_symbol-1}

[`# output conversion specifier modifier`](#index-_0023-output-conversion-specifier-modifier)

[16.2.2.2 Formatted output conversion
specifiers](#Formatted-output-conversion-specifiers)

[`#define preprocessor directive`](#index-_0023define-preprocessor-directive)

[12.2 Macros](#Macros)

[`#else preprocessor directive`](#index-_0023else-preprocessor-directive)

[12.1 A few directives](#A-few-directives)

[`#error preprocessor directive`](#index-_0023error-preprocessor-directive)

[12.1 A few directives](#A-few-directives)

[`#if preprocessor directive`](#index-_0023if-preprocessor-directive)

[12.1 A few directives](#A-few-directives)

[`#ifdef preprocessor directive`](#index-_0023ifdef-preprocessor-directive)

[12.2 Macros](#Macros)

[`#ifndef preprocessor directive`](#index-_0023ifndef-preprocessor-directive)

[12.2 Macros](#Macros)

[`#include preprocessor directive`](#index-_0023include-preprocessor-directive)

[12.1 A few directives](#A-few-directives)

[`#line preprocessor directive`](#index-_0023line-preprocessor-directive)

[12.1 A few directives](#A-few-directives)

[`#undef preprocessor directive`](#index-_0023undef-preprocessor-directive)

[12.2 Macros](#Macros)

------------------------------------------------------------------------

[%]{#Code-index-1_fn_symbol-2}

[`% input conversion specifier`](#index-_0025-input-conversion-specifier)

[16.2.8.2 Formatted input conversion
specifiers](#Formatted-input-conversion-specifiers)

[`% integer remainder operator`](#index-_0025-integer-remainder-operator)

[7.2 Expressions and values](#Expressions-and-values)

[`% mod operator`](#index-_0025-mod-operator)

[7.2 Expressions and values](#Expressions-and-values)

[`% modulo operator`](#index-_0025-modulo-operator)

[7.2 Expressions and values](#Expressions-and-values)

[`% output conversion specifier`](#index-_0025-output-conversion-specifier)

[16.2.2.2 Formatted output conversion
specifiers](#Formatted-output-conversion-specifiers)

------------------------------------------------------------------------

[&]{#Code-index-1_fn_symbol-3}

[`& bitwise operator`](#index-_0026-bitwise-operator)

[18.3.1 Bitwise operators](#Bitwise-operators)

[`& bitwise operator truth table`](#index-_0026-bitwise-operator-truth-table)

[18.3.3.2 Bitwise AND](#Bitwise-AND)

[`& pointer operator`](#index-_0026-pointer-operator)

[9.1 Pointer operators](#Pointer-operators)

[`&= bitwise operator`](#index-_0026_003d-bitwise-operator)

[18.3.1 Bitwise operators](#Bitwise-operators)

------------------------------------------------------------------------

[\']{#Code-index-1_fn_symbol-4}

[`' input conversion specifier modifier`](#index-_0027-input-conversion-specifier-modifier)

[16.2.8.2 Formatted input conversion
specifiers](#Formatted-input-conversion-specifiers)

[`' output conversion specifier modifier`](#index-_0027-output-conversion-specifier-modifier)

[16.2.2.2 Formatted output conversion
specifiers](#Formatted-output-conversion-specifiers)

------------------------------------------------------------------------

[\*]{#Code-index-1_fn_symbol-5}

[`* input conversion specifier modifier`](#index-_002a-input-conversion-specifier-modifier)

[16.2.8.2 Formatted input conversion
specifiers](#Formatted-input-conversion-specifiers)

[`* multiplication operator`](#index-_002a-multiplication-operator)

[7.2 Expressions and values](#Expressions-and-values)

[`* operator`](#index-_002a-operator)

[7. Expressions and operators](#Expressions-and-operators)

[`* pointer operator`](#index-_002a-pointer-operator)

[9.1 Pointer operators](#Pointer-operators)

[`*= operator`](#index-_002a_003d-operator)

[7.7 More Special Assignments](#More-Special-Assignments)

------------------------------------------------------------------------

[+]{#Code-index-1_fn_symbol-6}

[`+ addition operator`](#index-_002b-addition-operator)

[7.2 Expressions and values](#Expressions-and-values)

[`+ operator`](#index-_002b-operator)

[7. Expressions and operators](#Expressions-and-operators)

[`+ output conversion specifier modifier`](#index-_002b-output-conversion-specifier-modifier)

[16.2.2.2 Formatted output conversion
specifiers](#Formatted-output-conversion-specifiers)

[`+ unary plus operator`](#index-_002b-unary-plus-operator)

[7.2 Expressions and values](#Expressions-and-values)

[`++ increment operator`](#index-_002b_002b-increment-operator)

[7.6 Special Assignment Operators `++` and
`--`](#Special-Assignment-Operators-_002b_002b-_002d_002d)

[`++ increment operator`](#index-_002b_002b-increment-operator-1)

[18.1.2 Postfix and prefix `++` and
`--`](#Postfix-and-prefix-_002b_002b-and-_002d_002d)

[`++ operator`](#index-_002b_002b-operator)

[18.1 Hidden operators and values](#Hidden-operators-and-values)

[`++ postfix operator`](#index-_002b_002b-postfix-operator)

[18.1.2 Postfix and prefix `++` and
`--`](#Postfix-and-prefix-_002b_002b-and-_002d_002d)

[`++ prefix operator`](#index-_002b_002b-prefix-operator)

[18.1.2 Postfix and prefix `++` and
`--`](#Postfix-and-prefix-_002b_002b-and-_002d_002d)

[`+= operator`](#index-_002b_003d-operator)

[7.7 More Special Assignments](#More-Special-Assignments)

[`+= operator`](#index-_002b_003d-operator-1)

[18.1 Hidden operators and values](#Hidden-operators-and-values)

------------------------------------------------------------------------

[,]{#Code-index-1_fn_symbol-7}

[`, operator`](#index-_002c-operator)

[18.2 The comma operator](#The-comma-operator)

------------------------------------------------------------------------

[-]{#Code-index-1_fn_symbol-8}

[`-- decrement operator`](#index-_002d_002d-decrement-operator)

[7.6 Special Assignment Operators `++` and
`--`](#Special-Assignment-Operators-_002b_002b-_002d_002d)

[`-- decrement operator`](#index-_002d_002d-decrement-operator-1)

[18.1.2 Postfix and prefix `++` and
`--`](#Postfix-and-prefix-_002b_002b-and-_002d_002d)

[`- operator`](#index-_002d-operator)

[7. Expressions and operators](#Expressions-and-operators)

[`-- operator`](#index-_002d_002d-operator)

[18.1 Hidden operators and values](#Hidden-operators-and-values)

[`- output conversion specifier modifier`](#index-_002d-output-conversion-specifier-modifier)

[16.2.2.2 Formatted output conversion
specifiers](#Formatted-output-conversion-specifiers)

[`-- postfix operator`](#index-_002d_002d-postfix-operator)

[18.1.2 Postfix and prefix `++` and
`--`](#Postfix-and-prefix-_002b_002b-and-_002d_002d)

[`-- prefix operator`](#index-_002d_002d-prefix-operator)

[18.1.2 Postfix and prefix `++` and
`--`](#Postfix-and-prefix-_002b_002b-and-_002d_002d)

[`- subtraction operator`](#index-_002d-subtraction-operator)

[7.2 Expressions and values](#Expressions-and-values)

[`- unary minus operator`](#index-_002d-unary-minus-operator)

[7.2 Expressions and values](#Expressions-and-values)

[`-= operator`](#index-_002d_003d-operator)

[7.7 More Special Assignments](#More-Special-Assignments)

[`-= operator`](#index-_002d_003d-operator-1)

[18.1 Hidden operators and values](#Hidden-operators-and-values)

[`-> dot operator of structures`](#index-_002d_003e-dot-operator-of-structures)

[20.1.2 Using structures](#Using-structures)

[`-> member operator`](#index-_002d_003e-member-operator)

[20.2 Memory allocation](#Memory-allocation)

[`-c option of GCC`](#index-_002dc-option-of-GCC)

[17.6 Building a library](#Building-a-library)

[`-fPIC option of GCC`](#index-_002dfPIC-option-of-GCC)

[17.6 Building a library](#Building-a-library)

[`-fpic option of GCC`](#index-_002dfpic-option-of-GCC)

[17.6 Building a library](#Building-a-library)

[`-I option of GCC`](#index-_002dI-option-of-GCC)

[13.3 Common library functions](#Common-library-functions)

[`-I option of GCC`](#index-_002dI-option-of-GCC-1)

[17.6 Building a library](#Building-a-library)

[`-l option of GCC`](#index-_002dl-option-of-GCC)

[17.6 Building a library](#Building-a-library)

[`-L option of GCC`](#index-_002dL-option-of-GCC)

[17.6 Building a library](#Building-a-library)

[`--static option of GCC`](#index-_002d_002dstatic-option-of-GCC)

[17.6 Building a library](#Building-a-library)

------------------------------------------------------------------------

[.]{#Code-index-1_fn_symbol-9}

[`. dot operator of structures`](#index-_002e-dot-operator-of-structures)

[20.1.2 Using structures](#Using-structures)

[`.a file suffix`](#index-_002ea-file-suffix)

[2.3 File names](#File-names)

[`.a file suffix`](#index-_002ea-file-suffix-1)

[13.2 Kinds of library](#Kinds-of-library)

[`.c file suffix`](#index-_002ec-file-suffix)

[2.3 File names](#File-names)

[`.h file suffix`](#index-_002eh-file-suffix)

[2.3 File names](#File-names)

[`.o file suffix`](#index-_002eo-file-suffix)

[2.3 File names](#File-names)

[`.so file suffix`](#index-_002eso-file-suffix)

[2.3 File names](#File-names)

[`.so file suffix`](#index-_002eso-file-suffix-1)

[13.2 Kinds of library](#Kinds-of-library)

------------------------------------------------------------------------

[/]{#Code-index-1_fn_symbol-10}

[`/ div operator`](#index-_002f-div-operator)

[7.2 Expressions and values](#Expressions-and-values)

[`/ division operator`](#index-_002f-division-operator)

[7.2 Expressions and values](#Expressions-and-values)

[`/ integer division operator`](#index-_002f-integer-division-operator)

[7.2 Expressions and values](#Expressions-and-values)

[`/usr/include directory`](#index-_002fusr_002finclude-directory)

[13.1 Header files](#Header-files)

[`/usr/include directory`](#index-_002fusr_002finclude-directory-1)

[13.3 Common library functions](#Common-library-functions)

[`/usr/include/linux directory`](#index-_002fusr_002finclude_002flinux-directory)

[13.3 Common library functions](#Common-library-functions)

------------------------------------------------------------------------

[0]{#Code-index-1_fn_symbol-11}

[`0 output conversion specifier modifier`](#index-0-output-conversion-specifier-modifier)

[16.2.2.2 Formatted output conversion
specifiers](#Formatted-output-conversion-specifiers)

[`0 return code`](#index-0-return-code)

[17.2.1 `argp` description](#argp-description)

------------------------------------------------------------------------

[\<]{#Code-index-1_fn_symbol-12}

[`< less-than operator`](#index-_003c-less_002dthan-operator)

[7. Expressions and operators](#Expressions-and-operators)

[`<< bitwise operator`](#index-_003c_003c-bitwise-operator)

[18.3.1 Bitwise operators](#Bitwise-operators)

[`<<= bitwise operator`](#index-_003c_003c_003d-bitwise-operator)

[18.3.1 Bitwise operators](#Bitwise-operators)

------------------------------------------------------------------------

[=]{#Code-index-1_fn_symbol-13}

[`= (equals sign)`](#index-_003d-_0028equals-sign_0029)

[2.4 Errors](#Errors)

[`= assignment operator`](#index-_003d-assignment-operator)

[7.1 The assignment operator](#The-assignment-operator)

[`= confused with ==`](#index-_003d-confused-with-_003d_003d)

[7.1.1 Important note about
assignment](#Important-note-about-assignment)

[`= confused with ==`](#index-_003d-confused-with-_003d_003d-1)

[7.8 Comparisons and logic](#Comparisons-and-logic)

[`= confused with ==`](#index-_003d-confused-with-_003d_003d-2)

[23.3.1 Confusion of `=` and `==`](#Confusion-of-_003d-and-_003d_003d)

[`= operator`](#index-_003d-operator)

[18.1 Hidden operators and values](#Hidden-operators-and-values)

[`== confused with =`](#index-_003d_003d-confused-with-_003d)

[7.1.1 Important note about
assignment](#Important-note-about-assignment)

[`== confused with =`](#index-_003d_003d-confused-with-_003d-1)

[7.8 Comparisons and logic](#Comparisons-and-logic)

[`== confused with =`](#index-_003d_003d-confused-with-_003d-2)

[23.3.1 Confusion of `=` and `==`](#Confusion-of-_003d-and-_003d_003d)

------------------------------------------------------------------------

[\>]{#Code-index-1_fn_symbol-14}

[`> greater-than operator`](#index-_003e-greater_002dthan-operator)

[7. Expressions and operators](#Expressions-and-operators)

[`>> bitwise operator`](#index-_003e_003e-bitwise-operator)

[18.3.1 Bitwise operators](#Bitwise-operators)

[`>>= bitwise operator`](#index-_003e_003e_003d-bitwise-operator)

[18.3.1 Bitwise operators](#Bitwise-operators)

------------------------------------------------------------------------

[?]{#Code-index-1_fn_symbol-15}

[`? operator`](#index-_003f-operator)

[10. Decisions](#Decisions)

[`? operator`](#index-_003f-operator-1)

[10.4 The `?`...`:`... operator](#The-question-mark-operator)

------------------------------------------------------------------------

[\[]{#Code-index-1_fn_symbol-16}

[`[ input conversion specifier`](#index-_005b-input-conversion-specifier)

[16.2.8.2 Formatted input conversion
specifiers](#Formatted-input-conversion-specifiers)

------------------------------------------------------------------------

[\^]{#Code-index-1_fn_symbol-17}

[`^ bitwise operator`](#index-_005e-bitwise-operator)

[18.3.1 Bitwise operators](#Bitwise-operators)

[`^ bitwise operator truth table`](#index-_005e-bitwise-operator-truth-table)

[18.3.3.4 Bitwise exclusive OR
(XOR/EOR)](#Bitwise-exclusive-OR-_0028XOR_002fEOR_0029)

[`^= bitwise operator`](#index-_005e_003d-bitwise-operator)

[18.3.1 Bitwise operators](#Bitwise-operators)

------------------------------------------------------------------------

[\|]{#Code-index-1_fn_symbol-18}

[`| (pipe symbol)`](#index-_007c-_0028pipe-symbol_0029)

[16.4 Programming with pipes](#Programming-with-pipes)

[`| bitwise operator`](#index-_007c-bitwise-operator)

[18.3.1 Bitwise operators](#Bitwise-operators)

[`| bitwise operator truth table`](#index-_007c-bitwise-operator-truth-table)

[18.3.3.3 Bitwise inclusive OR](#Bitwise-inclusive-OR)

[`|= bitwise operator`](#index-_007c_003d-bitwise-operator)

[18.3.1 Bitwise operators](#Bitwise-operators)

------------------------------------------------------------------------

[\~]{#Code-index-1_fn_symbol-19}

[`~ bitwise operator`](#index-_007e-bitwise-operator)

[18.3.1 Bitwise operators](#Bitwise-operators)

[`~ bitwise operator truth table`](#index-_007e-bitwise-operator-truth-table)

[18.3.3.1 Bitwise NOT](#Bitwise-NOT)

------------------------------------------------------------------------

[A]{#Code-index-1_fn_letter-A}

[`a input conversion specifier modifier`](#index-a-input-conversion-specifier-modifier)

[16.2.8.2 Formatted input conversion
specifiers](#Formatted-input-conversion-specifiers)

[`a.out`](#index-a_002eout)

[2.2 The compiler](#The-compiler)

[`abs function`](#index-abs-function)

[13.4 Mathematical functions](#Mathematical-functions)

[`acos function`](#index-acos-function)

[13.4 Mathematical functions](#Mathematical-functions)

[`ar program`](#index-ar-program)

[17.6 Building a library](#Building-a-library)

[`ARG field`](#index-ARG-field)

[17.2.1 `argp` description](#argp-description)

[`ARG parser function argument`](#index-ARG-parser-function-argument)

[17.2.1 `argp` description](#argp-description)

[`argc variable`](#index-argc-variable-1)

[17.1 `argc` and `argv`](#argc-and-argv)

[`argp function`](#index-argp-function)

[17.2 Processing command-line
options](#Processing-command_002dline-options)

[`argp function`](#index-argp-function-1)

[17.2.1 `argp` description](#argp-description)

[`argp function`](#index-argp-function-2)

[17.2.1 `argp` description](#argp-description)

[`ARGP structure`](#index-ARGP-structure)

[17.2.1 `argp` description](#argp-description)

[`ARGP structure`](#index-ARGP-structure-1)

[17.2.1 `argp` description](#argp-description)

[`ARGP_ERR_UNKNOWN return code`](#index-ARGP_005fERR_005fUNKNOWN-return-code)

[17.2.1 `argp` description](#argp-description)

[`ARGP_KEY_ARG key`](#index-ARGP_005fKEY_005fARG-key)

[17.2.1 `argp` description](#argp-description)

[`ARGP_KEY_END key`](#index-ARGP_005fKEY_005fEND-key)

[17.2.1 `argp` description](#argp-description)

[`argp_option structure`](#index-argp_005foption-structure)

[17.2.1 `argp` description](#argp-description)

[`argp_option structure fields`](#index-argp_005foption-structure-fields)

[17.2.1 `argp` description](#argp-description)

[`argp_parse function`](#index-argp_005fparse-function)

[17.2.1 `argp` description](#argp-description)

[`argp_usage function`](#index-argp_005fusage-function)

[17.2.1 `argp` description](#argp-description)

[`ARGS_DOC field`](#index-ARGS_005fDOC-field)

[17.2.1 `argp` description](#argp-description)

[`arguments structure`](#index-arguments-structure)

[17.2.1 `argp` description](#argp-description)

[`argv array`](#index-argv-array)

[17.3 Environment variables](#Environment-variables)

[`argv variable`](#index-argv-variable-1)

[17.1 `argc` and `argv`](#argc-and-argv)

[`arg_num field`](#index-arg_005fnum-field)

[17.2.1 `argp` description](#argp-description)

[`asin function`](#index-asin-function)

[13.4 Mathematical functions](#Mathematical-functions)

[`asprintf function`](#index-asprintf-function)

[16.2.4 `asprintf`](#asprintf)

[`atan function`](#index-atan-function)

[13.4 Mathematical functions](#Mathematical-functions)

[`atan2 function`](#index-atan2-function)

[13.4 Mathematical functions](#Mathematical-functions)

[`atof function`](#index-atof-function)

[15.4 String library functions](#String-library-functions)

[`atoi function`](#index-atoi-function)

[15.4 String library functions](#String-library-functions)

[`atol function`](#index-atol-function)

[15.4 String library functions](#String-library-functions)

[`auto storage class specifier`](#index-auto-storage-class-specifier)

[5.5.3 Other storage classes](#Other-storage-classes)

------------------------------------------------------------------------

[B]{#Code-index-1_fn_letter-B}

[`bdflush daemon`](#index-bdflush-daemon)

[16.1.5 Stream buffering](#Stream-buffering)

[`break command`](#index-break-command)

[10.5 The `switch` statement](#The-switch-statement)

[`break command`](#index-break-command-1)

[11.5.1 Terminating loops with `break`](#Terminating-loops-with-break)

------------------------------------------------------------------------

[C]{#Code-index-1_fn_letter-C}

[`c input conversion specifier`](#index-c-input-conversion-specifier)

[16.2.8.2 Formatted input conversion
specifiers](#Formatted-input-conversion-specifiers)

[`c output conversion specifier`](#index-c-output-conversion-specifier)

[16.2.2.2 Formatted output conversion
specifiers](#Formatted-output-conversion-specifiers)

[`cast operator`](#index-cast-operator)

[5.4 The cast operator](#The-cast-operator)

[`cast operator`](#index-cast-operator-1)

[5.4.1 Cast operator demo](#Cast-operator-demo)

[`ceil function`](#index-ceil-function)

[13.4 Mathematical functions](#Mathematical-functions)

[`char type`](#index-char-type)

[5.1 Integer variables](#Integer-variables)

[`char type`](#index-char-type-1)

[5.1 Integer variables](#Integer-variables)

[`char type`](#index-char-type-2)

[5.1.1 The `char` type](#The-char-type)

[`char type`](#index-char-type-3)

[15.1 Conventions and declarations](#Conventions-and-declarations)

[`clean makefile target`](#index-clean-makefile-target-1)

[17.5.7 Rules for cleaning the
directory](#Rules-for-cleaning-the-directory)

[`clearerr function`](#index-clearerr-function)

[16.1.6 End-of-file and error
functions](#End_002dof_002dfile-and-error-functions)

[`close function`](#index-close-function)

[16.5.3 Closing files at a low level](#Closing-files-at-a-low-level)

[`close function`](#index-close-function-1)

[16.5.3 Closing files at a low level](#Closing-files-at-a-low-level)

[`const type`](#index-const-type)

[19. More data types](#More-data-types)

[`const type`](#index-const-type-1)

[19.4 Constants](#Constants)

[`const type`](#index-const-type-2)

[19.4.1 `const`](#const)

[`cos function`](#index-cos-function)

[13.4 Mathematical functions](#Mathematical-functions)

[`cosh function`](#index-cosh-function)

[13.4 Mathematical functions](#Mathematical-functions)

[`creat function`](#index-creat-function)

[16.5.2.1 File creation](#File-creation)

[`ctype.h header file`](#index-ctype_002eh-header-file)

[13.3 Common library functions](#Common-library-functions)

[`ctype.h header file`](#index-ctype_002eh-header-file-1)

[13.3.1 Character handling](#Character-handling)

------------------------------------------------------------------------

[D]{#Code-index-1_fn_letter-D}

[`d input conversion specifier`](#index-d-input-conversion-specifier)

[16.2.8.2 Formatted input conversion
specifiers](#Formatted-input-conversion-specifiers)

[`d output conversion specifier`](#index-d-output-conversion-specifier)

[16.2.2.2 Formatted output conversion
specifiers](#Formatted-output-conversion-specifiers)

[`do … while command`](#index-do-_2026-while-command)

[11. Loops](#Loops)

[`DOC field`](#index-DOC-field-1)

[17.2.1 `argp` description](#argp-description)

[`double type`](#index-double-type)

[5.1.2 Floating point variables](#Floating-point-variables)

[`double type`](#index-double-type-1)

[5.1.2 Floating point variables](#Floating-point-variables)

[`double type`](#index-double-type-2)

[5.1.2 Floating point variables](#Floating-point-variables)

[`double type`](#index-double-type-3)

[5.1.2 Floating point variables](#Floating-point-variables)

------------------------------------------------------------------------

[E]{#Code-index-1_fn_letter-E}

[`E input conversion specifier`](#index-E-input-conversion-specifier)

[16.2.8.2 Formatted input conversion
specifiers](#Formatted-input-conversion-specifiers)

[`E output conversion specifier`](#index-E-output-conversion-specifier)

[16.2.2.2 Formatted output conversion
specifiers](#Formatted-output-conversion-specifiers)

[`e output conversion specifier`](#index-e-output-conversion-specifier)

[16.2.2.2 Formatted output conversion
specifiers](#Formatted-output-conversion-specifiers)

[`EACCES file name error`](#index-EACCES-file-name-error)

[16.5.1 Usual file name errors](#Usual-file-name-errors)

[`EACCES file name error`](#index-EACCES-file-name-error-1)

[16.5.2 Opening files at a low level](#Opening-files-at-a-low-level)

[`EACCES file name error`](#index-EACCES-file-name-error-2)

[16.5.7 Deleting files at a low level](#Deleting-files-at-a-low-level)

[`EACCES file name error`](#index-EACCES-file-name-error-3)

[16.5.8 Renaming files at a low level](#Renaming-files-at-a-low-level)

[`EBADF file name error`](#index-EBADF-file-name-error)

[16.5.3 Closing files at a low level](#Closing-files-at-a-low-level)

[`EBADF file name error`](#index-EBADF-file-name-error-1)

[16.5.4 Reading files at a low level](#Reading-files-at-a-low-level)

[`EBADF file name error`](#index-EBADF-file-name-error-2)

[16.5.5 Writing files at a low level](#Writing-files-at-a-low-level)

[`EBADF file name error`](#index-EBADF-file-name-error-3)

[16.5.5 Writing files at a low level](#Writing-files-at-a-low-level)

[`EBADF file name error`](#index-EBADF-file-name-error-4)

[16.5.6 Finding file positions at a low
level](#Finding-file-positions-at-a-low-level)

[`EBUSY file name error`](#index-EBUSY-file-name-error)

[16.5.7 Deleting files at a low level](#Deleting-files-at-a-low-level)

[`EBUSY file name error`](#index-EBUSY-file-name-error-1)

[16.5.8 Renaming files at a low level](#Renaming-files-at-a-low-level)

[`EEXIST file name error`](#index-EEXIST-file-name-error)

[16.5.2 Opening files at a low level](#Opening-files-at-a-low-level)

[`EFBIG file name error`](#index-EFBIG-file-name-error)

[16.5.5 Writing files at a low level](#Writing-files-at-a-low-level)

[`EINTR file name error`](#index-EINTR-file-name-error)

[16.5.5 Writing files at a low level](#Writing-files-at-a-low-level)

[`EINVAL error code`](#index-EINVAL-error-code)

[17.2.1 `argp` description](#argp-description)

[`EINVAL file name error`](#index-EINVAL-file-name-error)

[16.5.5 Writing files at a low level](#Writing-files-at-a-low-level)

[`EINVAL file name error`](#index-EINVAL-file-name-error-1)

[16.5.6 Finding file positions at a low
level](#Finding-file-positions-at-a-low-level)

[`EINVAL file name error`](#index-EINVAL-file-name-error-2)

[16.5.8 Renaming files at a low level](#Renaming-files-at-a-low-level)

[`EIO file name error`](#index-EIO-file-name-error)

[16.5.4 Reading files at a low level](#Reading-files-at-a-low-level)

[`EIO file name error`](#index-EIO-file-name-error-1)

[16.5.5 Writing files at a low level](#Writing-files-at-a-low-level)

[`EISDIR file name error`](#index-EISDIR-file-name-error)

[16.5.2 Opening files at a low level](#Opening-files-at-a-low-level)

[`EISDIR file name error`](#index-EISDIR-file-name-error-1)

[16.5.8 Renaming files at a low level](#Renaming-files-at-a-low-level)

[`ELOOP file name error`](#index-ELOOP-file-name-error)

[16.5.1 Usual file name errors](#Usual-file-name-errors)

[`else command`](#index-else-command)

[10. Decisions](#Decisions)

[`EMFILE file name error`](#index-EMFILE-file-name-error)

[16.5.2 Opening files at a low level](#Opening-files-at-a-low-level)

[`EMLINK file name error`](#index-EMLINK-file-name-error)

[16.5.8 Renaming files at a low level](#Renaming-files-at-a-low-level)

[`ENAMETOOLONG file name error`](#index-ENAMETOOLONG-file-name-error)

[16.5.1 Usual file name errors](#Usual-file-name-errors)

[`ENOENT file name error`](#index-ENOENT-file-name-error)

[16.5.1 Usual file name errors](#Usual-file-name-errors)

[`ENOENT file name error`](#index-ENOENT-file-name-error-1)

[16.5.2 Opening files at a low level](#Opening-files-at-a-low-level)

[`ENOENT file name error`](#index-ENOENT-file-name-error-2)

[16.5.7 Deleting files at a low level](#Deleting-files-at-a-low-level)

[`ENOENT file name error`](#index-ENOENT-file-name-error-3)

[16.5.8 Renaming files at a low level](#Renaming-files-at-a-low-level)

[`ENOMEM error code`](#index-ENOMEM-error-code)

[17.2.1 `argp` description](#argp-description)

[`ENOSPC file name error`](#index-ENOSPC-file-name-error)

[16.5.2 Opening files at a low level](#Opening-files-at-a-low-level)

[`ENOSPC file name error`](#index-ENOSPC-file-name-error-1)

[16.5.5 Writing files at a low level](#Writing-files-at-a-low-level)

[`ENOSPC file name error`](#index-ENOSPC-file-name-error-2)

[16.5.8 Renaming files at a low level](#Renaming-files-at-a-low-level)

[`ENOTDIR file name error`](#index-ENOTDIR-file-name-error)

[16.5.1 Usual file name errors](#Usual-file-name-errors)

[`ENOTEMPTY file name error`](#index-ENOTEMPTY-file-name-error)

[16.5.7 Deleting files at a low level](#Deleting-files-at-a-low-level)

[`ENOTEMPTY file name error`](#index-ENOTEMPTY-file-name-error-1)

[16.5.8 Renaming files at a low level](#Renaming-files-at-a-low-level)

[`enum type`](#index-enum-type)

[19. More data types](#More-data-types)

[`enum type`](#index-enum-type-1)

[19.1 `enum`](#enum)

[`envp array`](#index-envp-array-1)

[17.3 Environment variables](#Environment-variables)

[`EOF character`](#index-EOF-character)

[16.3.5 `ungetc()`](#ungetc)

[`EPERM file name error`](#index-EPERM-file-name-error)

[16.5.7 Deleting files at a low level](#Deleting-files-at-a-low-level)

[`EROFS file name error`](#index-EROFS-file-name-error)

[16.5.2 Opening files at a low level](#Opening-files-at-a-low-level)

[`EROFS file name error`](#index-EROFS-file-name-error-1)

[16.5.7 Deleting files at a low level](#Deleting-files-at-a-low-level)

[`EROFS file name error`](#index-EROFS-file-name-error-2)

[16.5.8 Renaming files at a low level](#Renaming-files-at-a-low-level)

[`errno system variable`](#index-errno-system-variable)

[16.5.2 Opening files at a low level](#Opening-files-at-a-low-level)

[`errno system variable`](#index-errno-system-variable-1)

[16.5.3 Closing files at a low level](#Closing-files-at-a-low-level)

[`errno system variable`](#index-errno-system-variable-4)

[16.5.7 Deleting files at a low level](#Deleting-files-at-a-low-level)

[`errno system variable`](#index-errno-system-variable-5)

[16.5.8 Renaming files at a low level](#Renaming-files-at-a-low-level)

[`errno system variable`](#index-errno-system-variable-6)

[17.2.1 `argp` description](#argp-description)

[`error_t function`](#index-error_005ft-function)

[17.2.1 `argp` description](#argp-description)

[`ESPIPE file name error`](#index-ESPIPE-file-name-error)

[16.5.6 Finding file positions at a low
level](#Finding-file-positions-at-a-low-level)

[`EXDEV file name error`](#index-EXDEV-file-name-error)

[16.5.8 Renaming files at a low level](#Renaming-files-at-a-low-level)

[`exit command`](#index-exit-command)

[4.5 The `exit` function](#The-exit-function)

[`exit command`](#index-exit-command-1)

[4.5 The `exit` function](#The-exit-function)

[`exp function`](#index-exp-function)

[13.4 Mathematical functions](#Mathematical-functions)

[`extern storage class specifier`](#index-extern-storage-class-specifier)

[5.5.1 External variables](#External-variables)

------------------------------------------------------------------------

[F]{#Code-index-1_fn_letter-F}

[`f input conversion specifier`](#index-f-input-conversion-specifier)

[16.2.8.2 Formatted input conversion
specifiers](#Formatted-input-conversion-specifiers)

[`f output conversion specifier`](#index-f-output-conversion-specifier)

[16.2.2.2 Formatted output conversion
specifiers](#Formatted-output-conversion-specifiers)

[`fabs function`](#index-fabs-function)

[13.4 Mathematical functions](#Mathematical-functions)

[`FALSE macro`](#index-FALSE-macro)

[7.8 Comparisons and logic](#Comparisons-and-logic)

[`fclose command`](#index-fclose-command)

[16.1.2 Closing a file](#Closing-a-file)

[`fclose function`](#index-fclose-function)

[16.5.3 Closing files at a low level](#Closing-files-at-a-low-level)

[`feof function`](#index-feof-function)

[16.1.6 End-of-file and error
functions](#End_002dof_002dfile-and-error-functions)

[`ferror function`](#index-ferror-function)

[16.1.6 End-of-file and error
functions](#End_002dof_002dfile-and-error-functions)

[`fetestexcept function`](#index-fetestexcept-function)

[23.4 Mathematical errors](#Mathematical-errors)

[`FE_ALL_EXCEPT function`](#index-FE_005fALL_005fEXCEPT-function)

[23.4 Mathematical errors](#Mathematical-errors)

[`FE_DIVBYZERO floating-point exception`](#index-FE_005fDIVBYZERO-floating_002dpoint-exception)

[23.4 Mathematical errors](#Mathematical-errors)

[`FE_INEXACT floating-point exception`](#index-FE_005fINEXACT-floating_002dpoint-exception)

[23.4 Mathematical errors](#Mathematical-errors)

[`FE_INVALID floating-point exception`](#index-FE_005fINVALID-floating_002dpoint-exception)

[23.4 Mathematical errors](#Mathematical-errors)

[`FE_OVERFLOW floating-point exception`](#index-FE_005fOVERFLOW-floating_002dpoint-exception)

[23.4 Mathematical errors](#Mathematical-errors)

[`FE_UNDERFLOW floating-point exception`](#index-FE_005fUNDERFLOW-floating_002dpoint-exception)

[23.4 Mathematical errors](#Mathematical-errors)

[`fflush function`](#index-fflush-function)

[16.1.5 Stream buffering](#Stream-buffering)

[`fflush function`](#index-fflush-function-1)

[23.3.5 Uncoordinated output](#Uncoordinated-output)

[`fgetc function`](#index-fgetc-function)

[16.3.3 `getc` and `fgetc`](#getc-and-fgetc)

[`fgets function`](#index-fgets-function)

[16.2 String output and input](#String-output-and-input)

[`fgets function`](#index-fgets-function-1)

[16.2.7.2 `fgets`](#fgets)

[`fgets function`](#index-fgets-function-2)

[16.2.7.2 `fgets`](#fgets)

[`file status flag`](#index-file-status-flag)

[16.5.2 Opening files at a low level](#Opening-files-at-a-low-level)

[`FLAGS field`](#index-FLAGS-field)

[17.2.1 `argp` description](#argp-description)

[`float type`](#index-float-type)

[5.1.2 Floating point variables](#Floating-point-variables)

[`float type`](#index-float-type-1)

[5.1.2 Floating point variables](#Floating-point-variables)

[`float type`](#index-float-type-2)

[5.1.2 Floating point variables](#Floating-point-variables)

[`floor function`](#index-floor-function)

[13.4 Mathematical functions](#Mathematical-functions)

[`fopen command`](#index-fopen-command)

[16. Input and output](#Input-and-output)

[`fopen command`](#index-fopen-command-1)

[16.1.1 Opening a file](#Opening-a-file)

[`fopen command`](#index-fopen-command-2)

[16.1.1 Opening a file](#Opening-a-file)

[`for command`](#index-for-command)

[11. Loops](#Loops)

[`for command`](#index-for-command-1)

[11.3 `for`](#for)

[`for command`](#index-for-command-2)

[11.4 The flexibility of `for`](#The-flexibility-of-for)

[`for command`](#index-for-command-3)

[14.2 Arrays and `for` loops](#Arrays-and-for-loops)

[`fprintf function`](#index-fprintf-function)

[16.2.3 `fprintf`](#fprintf)

[`fputc function`](#index-fputc-function)

[16.3.4 `putc` and `fputc`](#putc-and-fputc)

[`fputs function`](#index-fputs-function)

[16.2 String output and input](#String-output-and-input)

[`fputs function`](#index-fputs-function-1)

[16.2.1.2 `fputs`](#fputs)

[`fread function`](#index-fread-function)

[16.1.3 Block input and output](#Block-input-and-output)

[`fread function`](#index-fread-function-1)

[16.1.3 Block input and output](#Block-input-and-output)

[`fread function`](#index-fread-function-2)

[16.1.3 Block input and output](#Block-input-and-output)

[`fread function`](#index-fread-function-3)

[16.1.3 Block input and output](#Block-input-and-output)

[`free function`](#index-free-function)

[20.2 Memory allocation](#Memory-allocation)

[`fscanf function`](#index-fscanf-function)

[16.2.10 `fscanf`](#fscanf)

[`fseek function`](#index-fseek-function)

[16.1.4 File position](#File-position)

[`fseek function`](#index-fseek-function-1)

[16.3.5 `ungetc()`](#ungetc)

[`fsync function`](#index-fsync-function)

[16.5.5 Writing files at a low level](#Writing-files-at-a-low-level)

[`fsync function`](#index-fsync-function-1)

[16.5.5 Writing files at a low level](#Writing-files-at-a-low-level)

[`ftell function`](#index-ftell-function)

[16.1.4 File position](#File-position)

[`fwrite function`](#index-fwrite-function)

[16.1.3 Block input and output](#Block-input-and-output)

[`fwrite function`](#index-fwrite-function-1)

[16.1.3 Block input and output](#Block-input-and-output)

[`fwrite function`](#index-fwrite-function-2)

[16.1.3 Block input and output](#Block-input-and-output)

[`fwrite function`](#index-fwrite-function-3)

[16.1.3 Block input and output](#Block-input-and-output)

------------------------------------------------------------------------

[G]{#Code-index-1_fn_letter-G}

[`g input conversion specifier`](#index-g-input-conversion-specifier)

[16.2.8.2 Formatted input conversion
specifiers](#Formatted-input-conversion-specifiers)

[`G input conversion specifier`](#index-G-input-conversion-specifier)

[16.2.8.2 Formatted input conversion
specifiers](#Formatted-input-conversion-specifiers)

[`gcc`](#index-gcc)

[2.2 The compiler](#The-compiler)

[`gcc`](#index-gcc-1)

[17.1 `argc` and `argv`](#argc-and-argv)

[`gcc`](#index-gcc-2)

[17.4 Compiling multiple files](#Compiling-multiple-files)

[`getc function`](#index-getc-function)

[16.3.3 `getc` and `fgetc`](#getc-and-fgetc)

[`getchar function`](#index-getchar-function)

[16.3.1 `getchar`](#getchar)

[`getdelim function`](#index-getdelim-function)

[16.2 String output and input](#String-output-and-input)

[`getdelim function`](#index-getdelim-function-1)

[16.2.6.2 `getdelim`](#getdelim)

[`getenv function`](#index-getenv-function)

[17.3 Environment variables](#Environment-variables)

[`getline function`](#index-getline-function)

[16.2 String output and input](#String-output-and-input)

[`getline function`](#index-getline-function-1)

[16.2.6.1 `getline`](#getline)

[`getline function`](#index-getline-function-2)

[16.2.6.1 `getline`](#getline)

[`getopt function`](#index-getopt-function)

[17.2 Processing command-line
options](#Processing-command_002dline-options)

[`gets function`](#index-gets-function)

[16.2 String output and input](#String-output-and-input)

[`gets function`](#index-gets-function-1)

[16.2.7.1 `gets`](#gets)

[`glibc library`](#index-glibc-library)

[13. Libraries](#Libraries)

[`glibc library`](#index-glibc-library-1)

[13.1 Header files](#Header-files)

[`glibc library`](#index-glibc-library-2)

[13.3.1 Character handling](#Character-handling)

[`goto command`](#index-goto-command)

[F. A word about `goto`](#A-word-about-goto)

[`grep command`](#index-grep-command)

[16.4 Programming with pipes](#Programming-with-pipes)

------------------------------------------------------------------------

[H]{#Code-index-1_fn_letter-H}

[`h input conversion specifier modifier`](#index-h-input-conversion-specifier-modifier)

[16.2.8.2 Formatted input conversion
specifiers](#Formatted-input-conversion-specifiers)

------------------------------------------------------------------------

[I]{#Code-index-1_fn_letter-I}

[`i input conversion specifier`](#index-i-input-conversion-specifier)

[16.2.8.2 Formatted input conversion
specifiers](#Formatted-input-conversion-specifiers)

[`i output conversion specifier`](#index-i-output-conversion-specifier)

[16.2.2.2 Formatted output conversion
specifiers](#Formatted-output-conversion-specifiers)

[`if command`](#index-if-command)

[10. Decisions](#Decisions)

[`if command`](#index-if-command-1)

[10.1 `if`](#if)

[`if command`](#index-if-command-2)

[10.3 Nested `if` statements](#Nested-if-statements)

[`INFINITY macro`](#index-INFINITY-macro)

[23.4 Mathematical errors](#Mathematical-errors)

[`input conversion specifier`](#index-input-conversion-specifier)

[16.2.8.2 Formatted input conversion
specifiers](#Formatted-input-conversion-specifiers)

[`input field`](#index-input-field)

[17.2.1 `argp` description](#argp-description)

[`int type`](#index-int-type)

[5.1 Integer variables](#Integer-variables)

[`int type`](#index-int-type-1)

[5.1 Integer variables](#Integer-variables)

[`isalnum function`](#index-isalnum-function)

[13.3.1 Character handling](#Character-handling)

[`isalpha function`](#index-isalpha-function)

[13.3.1 Character handling](#Character-handling)

[`isascii function`](#index-isascii-function)

[13.3.1 Character handling](#Character-handling)

[`iscntrl function`](#index-iscntrl-function)

[13.3.1 Character handling](#Character-handling)

[`isdigit function`](#index-isdigit-function)

[13.3.1 Character handling](#Character-handling)

[`isgraph function`](#index-isgraph-function)

[13.3.1 Character handling](#Character-handling)

[`islower function`](#index-islower-function)

[13.3.1 Character handling](#Character-handling)

[`isprint function`](#index-isprint-function)

[13.3.1 Character handling](#Character-handling)

[`ispunct function`](#index-ispunct-function)

[13.3.1 Character handling](#Character-handling)

[`isspace function`](#index-isspace-function)

[13.3.1 Character handling](#Character-handling)

[`isupper function`](#index-isupper-function)

[13.3.1 Character handling](#Character-handling)

[`isxdigit function`](#index-isxdigit-function)

[13.3.1 Character handling](#Character-handling)

------------------------------------------------------------------------

[K]{#Code-index-1_fn_letter-K}

[`KEY field`](#index-KEY-field)

[17.2.1 `argp` description](#argp-description)

[`KEY parser function argument`](#index-KEY-parser-function-argument)

[17.2.1 `argp` description](#argp-description)

------------------------------------------------------------------------

[L]{#Code-index-1_fn_letter-L}

[`l input conversion specifier modifier`](#index-l-input-conversion-specifier-modifier)

[16.2.8.2 Formatted input conversion
specifiers](#Formatted-input-conversion-specifiers)

[`L input conversion specifier modifier`](#index-L-input-conversion-specifier-modifier)

[16.2.8.2 Formatted input conversion
specifiers](#Formatted-input-conversion-specifiers)

[`L output conversion specifier modifier`](#index-L-output-conversion-specifier-modifier)

[16.2.2.2 Formatted output conversion
specifiers](#Formatted-output-conversion-specifiers)

[`l output conversion specifier modifier`](#index-l-output-conversion-specifier-modifier)

[16.2.2.2 Formatted output conversion
specifiers](#Formatted-output-conversion-specifiers)

[`LD_LIBRARY_PATH shell variable`](#index-LD_005fLIBRARY_005fPATH-shell-variable)

[17.6 Building a library](#Building-a-library)

[`limits.h header file`](#index-limits_002eh-header-file)

[13.4 Mathematical functions](#Mathematical-functions)

[`ll input conversion specifier modifier`](#index-ll-input-conversion-specifier-modifier)

[16.2.8.2 Formatted input conversion
specifiers](#Formatted-input-conversion-specifiers)

[`ll output conversion specifier modifier`](#index-ll-output-conversion-specifier-modifier)

[16.2.2.2 Formatted output conversion
specifiers](#Formatted-output-conversion-specifiers)

[`log function`](#index-log-function)

[13.4 Mathematical functions](#Mathematical-functions)

[`log10 function`](#index-log10-function)

[13.4 Mathematical functions](#Mathematical-functions)

[`long double type`](#index-long-double-type)

[5.1.2 Floating point variables](#Floating-point-variables)

[`long double type`](#index-long-double-type-1)

[5.1.2 Floating point variables](#Floating-point-variables)

[`long float type`](#index-long-float-type)

[5.1.2 Floating point variables](#Floating-point-variables)

[`long float type`](#index-long-float-type-1)

[5.1.2 Floating point variables](#Floating-point-variables)

[`long float type`](#index-long-float-type-2)

[5.1.2 Floating point variables](#Floating-point-variables)

[`long long type`](#index-long-long-type)

[5.1 Integer variables](#Integer-variables)

[`long long type`](#index-long-long-type-1)

[5.1 Integer variables](#Integer-variables)

[`long type`](#index-long-type)

[5.1 Integer variables](#Integer-variables)

[`long type`](#index-long-type-1)

[5.1 Integer variables](#Integer-variables)

[`lseek function`](#index-lseek-function)

[16.5.6 Finding file positions at a low
level](#Finding-file-positions-at-a-low-level)

------------------------------------------------------------------------

[M]{#Code-index-1_fn_letter-M}

[`m output conversion specifier`](#index-m-output-conversion-specifier)

[16.2.2.2 Formatted output conversion
specifiers](#Formatted-output-conversion-specifiers)

[`m output conversion specifier`](#index-m-output-conversion-specifier-1)

[16.5.1 Usual file name errors](#Usual-file-name-errors)

[`make program`](#index-make-program)

[17.5 Writing a makefile](#Writing-a-makefile)

[`malloc function`](#index-malloc-function)

[20.2 Memory allocation](#Memory-allocation)

[`malloc function`](#index-malloc-function-1)

[20.2 Memory allocation](#Memory-allocation)

[`math.h header file`](#index-math_002eh-header-file)

[13.1 Header files](#Header-files)

[`math.h header file`](#index-math_002eh-header-file-1)

[13.3 Common library functions](#Common-library-functions)

[`math.h header file`](#index-math_002eh-header-file-2)

[13.4 Mathematical functions](#Mathematical-functions)

[`math.h system header file`](#index-math_002eh-system-header-file)

[8.3 Actual parameters and formal
parameters](#Actual-parameters-and-formal-parameters)

------------------------------------------------------------------------

[N]{#Code-index-1_fn_letter-N}

[`NAME field`](#index-NAME-field)

[17.2.1 `argp` description](#argp-description)

[`NAN macro`](#index-NAN-macro)

[23.4 Mathematical errors](#Mathematical-errors)

[`NULL pointer`](#index-NULL-pointer)

[20.4.4.2 Initializing your data
structure](#Initializing-your-data-structure)

------------------------------------------------------------------------

[O]{#Code-index-1_fn_letter-O}

[`obj makefile variable`](#index-obj-makefile-variable)

[17.5.4 Variables simplify makefiles](#Variables-simplify-makefiles)

[`OBJ makefile variable`](#index-OBJ-makefile-variable)

[17.5.4 Variables simplify makefiles](#Variables-simplify-makefiles)

[`objects`](#index-objects)

[17.5.4 Variables simplify makefiles](#Variables-simplify-makefiles)

[`OBJECTS makefile variable`](#index-OBJECTS-makefile-variable)

[17.5.4 Variables simplify makefiles](#Variables-simplify-makefiles)

[`OBJS makefile variable`](#index-OBJS-makefile-variable)

[17.5.4 Variables simplify makefiles](#Variables-simplify-makefiles)

[`objs makefile variable`](#index-objs-makefile-variable)

[17.5.4 Variables simplify makefiles](#Variables-simplify-makefiles)

[`off_t type`](#index-off_005ft-type)

[16.5.6 Finding file positions at a low
level](#Finding-file-positions-at-a-low-level)

[`open command`](#index-open-command)

[16. Input and output](#Input-and-output)

[`open function`](#index-open-function)

[16.5.2 Opening files at a low level](#Opening-files-at-a-low-level)

[`open function`](#index-open-function-1)

[16.5.2.1 File creation](#File-creation)

[`open function`](#index-open-function-2)

[16.5.3 Closing files at a low level](#Closing-files-at-a-low-level)

[`OPTIONS field`](#index-OPTIONS-field)

[17.2.1 `argp` description](#argp-description)

[`OPTION_ALIAS option flag`](#index-OPTION_005fALIAS-option-flag)

[17.2.1 `argp` description](#argp-description)

[`OPTION_ARG_OPTIONAL option flag`](#index-OPTION_005fARG_005fOPTIONAL-option-flag)

[17.2.1 `argp` description](#argp-description)

[`OPTION_HIDDEN option flag`](#index-OPTION_005fHIDDEN-option-flag)

[17.2.1 `argp` description](#argp-description)

[`O_APPEND file status flag`](#index-O_005fAPPEND-file-status-flag)

[16.5.2 Opening files at a low level](#Opening-files-at-a-low-level)

[`O_CREAT file status flag`](#index-O_005fCREAT-file-status-flag)

[16.5.2 Opening files at a low level](#Opening-files-at-a-low-level)

[`O_EXCL file status flag`](#index-O_005fEXCL-file-status-flag)

[16.5.2 Opening files at a low level](#Opening-files-at-a-low-level)

[`O_EXEC file status flag`](#index-O_005fEXEC-file-status-flag)

[16.5.2 Opening files at a low level](#Opening-files-at-a-low-level)

[`O_RDONLY file status flag`](#index-O_005fRDONLY-file-status-flag)

[16.5.2 Opening files at a low level](#Opening-files-at-a-low-level)

[`O_RDWR file status flag`](#index-O_005fRDWR-file-status-flag)

[16.5.2 Opening files at a low level](#Opening-files-at-a-low-level)

[`O_TRUNC file status flag`](#index-O_005fTRUNC-file-status-flag)

[16.5.2 Opening files at a low level](#Opening-files-at-a-low-level)

[`O_WRITE file status flag`](#index-O_005fWRITE-file-status-flag)

[16.5.2 Opening files at a low level](#Opening-files-at-a-low-level)

[`O_WRONLY file status flag`](#index-O_005fWRONLY-file-status-flag)

[16.5.2 Opening files at a low level](#Opening-files-at-a-low-level)

------------------------------------------------------------------------

[P]{#Code-index-1_fn_letter-P}

[`PARSER field`](#index-PARSER-field)

[17.2.1 `argp` description](#argp-description)

[`pclose function`](#index-pclose-function)

[16.4 Programming with pipes](#Programming-with-pipes)

[`popen function`](#index-popen-function)

[16.4 Programming with pipes](#Programming-with-pipes)

[`pow function`](#index-pow-function)

[13.4 Mathematical functions](#Mathematical-functions)

[`printf`](#index-printf)

[4.2 Function examples](#Function-examples)

[`printf function`](#index-printf-function)

[16.2.2.1 `printf`](#printf)

[`printf function`](#index-printf-function-1)

[16.2.2.2 Formatted output conversion
specifiers](#Formatted-output-conversion-specifiers)

[`ps command`](#index-ps-command)

[16.4 Programming with pipes](#Programming-with-pipes)

[`putc function`](#index-putc-function)

[16.3.4 `putc` and `fputc`](#putc-and-fputc)

[`putchar function`](#index-putchar-function)

[16.3.2 `putchar`](#putchar)

[`puts function`](#index-puts-function)

[16.2 String output and input](#String-output-and-input)

[`puts function`](#index-puts-function-1)

[16.2.1.1 `puts`](#puts)

------------------------------------------------------------------------

[Q]{#Code-index-1_fn_letter-Q}

[`q input conversion specifier modifier`](#index-q-input-conversion-specifier-modifier)

[16.2.8.2 Formatted input conversion
specifiers](#Formatted-input-conversion-specifiers)

[`q output conversion specifier modifier`](#index-q-output-conversion-specifier-modifier)

[16.2.2.2 Formatted output conversion
specifiers](#Formatted-output-conversion-specifiers)

------------------------------------------------------------------------

[R]{#Code-index-1_fn_letter-R}

[`read function`](#index-read-function)

[16.5.4 Reading files at a low level](#Reading-files-at-a-low-level)

[`read function`](#index-read-function-1)

[16.5.5 Writing files at a low level](#Writing-files-at-a-low-level)

[`realloc function`](#index-realloc-function)

[20.2 Memory allocation](#Memory-allocation)

[`realloc function`](#index-realloc-function-1)

[20.2 Memory allocation](#Memory-allocation)

[`register storage class specifier`](#index-register-storage-class-specifier)

[5.5.3 Other storage classes](#Other-storage-classes)

[`rename function`](#index-rename-function)

[16.5.8 Renaming files at a low level](#Renaming-files-at-a-low-level)

[`return command`](#index-return-command)

[4.5 The `exit` function](#The-exit-function)

[`return command`](#index-return-command-1)

[10.6 Example Listing](#Example-15)

[`return command`](#index-return-command-2)

[11.5.2 Terminating loops with `return`](#Terminating-loops-with-return)

[`rewind function`](#index-rewind-function)

[16.3.5 `ungetc()`](#ungetc)

[`rewind macro`](#index-rewind-macro)

[16.1.4 File position](#File-position)

[`rm program`](#index-rm-program)

[17.5.2 A simple makefile](#A-simple-makefile)

[`rmdir function`](#index-rmdir-function)

[16.5.7 Deleting files at a low level](#Deleting-files-at-a-low-level)

------------------------------------------------------------------------

[S]{#Code-index-1_fn_letter-S}

[`s input conversion specifier`](#index-s-input-conversion-specifier)

[16.2.8.2 Formatted input conversion
specifiers](#Formatted-input-conversion-specifiers)

[`s output conversion specifier`](#index-s-output-conversion-specifier)

[16.2.2.2 Formatted output conversion
specifiers](#Formatted-output-conversion-specifiers)

[`scanf function`](#index-scanf-function)

[9. Pointers](#Pointers)

[`scanf function`](#index-scanf-function-1)

[16.2.9.1 `scanf`](#scanf)

[`scanf function`](#index-scanf-function-2)

[16.2.9.2 String overflows with scanf](#String-overflows-with-scanf)

[`SEEK_CUR constant`](#index-SEEK_005fCUR-constant)

[16.5.6 Finding file positions at a low
level](#Finding-file-positions-at-a-low-level)

[`SEEK_END constant`](#index-SEEK_005fEND-constant)

[16.5.6 Finding file positions at a low
level](#Finding-file-positions-at-a-low-level)

[`SEEK_SET constant`](#index-SEEK_005fSET-constant)

[16.5.6 Finding file positions at a low
level](#Finding-file-positions-at-a-low-level)

[`short type`](#index-short-type)

[5.1 Integer variables](#Integer-variables)

[`short type`](#index-short-type-1)

[5.1 Integer variables](#Integer-variables)

[`sin function`](#index-sin-function)

[13.1 Header files](#Header-files)

[`sin function`](#index-sin-function-1)

[13.4 Mathematical functions](#Mathematical-functions)

[`sinh function`](#index-sinh-function)

[13.4 Mathematical functions](#Mathematical-functions)

[`sizeof function`](#index-sizeof-function)

[20.2 Memory allocation](#Memory-allocation)

[`size_t type`](#index-size_005ft-type)

[16.1.3 Block input and output](#Block-input-and-output)

[`size_t type`](#index-size_005ft-type-1)

[16.1.3 Block input and output](#Block-input-and-output)

[`SPACE output conversion specifier modifier`](#index-SPACE-output-conversion-specifier-modifier)

[16.2.2.2 Formatted output conversion
specifiers](#Formatted-output-conversion-specifiers)

[`sprintf function`](#index-sprintf-function)

[16.2.5 Deprecated formatted string output
functions](#Deprecated-formatted-string-output-functions)

[`sprintf function`](#index-sprintf-function-1)

[16.2.5.1 `sprintf`](#sprintf)

[`sqrt function`](#index-sqrt-function)

[8.3 Actual parameters and formal
parameters](#Actual-parameters-and-formal-parameters)

[`sqrt function`](#index-sqrt-function-1)

[13.4 Mathematical functions](#Mathematical-functions)

[`sscanf function`](#index-sscanf-function)

[16.2.8.1 `sscanf`](#sscanf)

[`sscanf function`](#index-sscanf-function-1)

[16.2.8.1 `sscanf`](#sscanf)

[`STATE parser function argument`](#index-STATE-parser-function-argument)

[17.2.1 `argp` description](#argp-description)

[`static storage class specifier`](#index-static-storage-class-specifier)

[5.5.2 Static variables](#Static-variables)

[`stdarg.h system header file`](#index-stdarg_002eh-system-header-file)

[8.4 Variadic functions](#Variadic-functions)

[`stdin device`](#index-stdin-device)

[16.1.5 Stream buffering](#Stream-buffering)

[`stdio.h header file`](#index-stdio_002eh-header-file)

[13.1 Header files](#Header-files)

[`stdlib.h header file`](#index-stdlib_002eh-header-file)

[15.4 String library functions](#String-library-functions)

[`stdout device`](#index-stdout-device)

[16.1.5 Stream buffering](#Stream-buffering)

[`strcat function`](#index-strcat-function)

[15.4 String library functions](#String-library-functions)

[`strcmp function`](#index-strcmp-function)

[15.4 String library functions](#String-library-functions)

[`strcpy function`](#index-strcpy-function)

[15.4 String library functions](#String-library-functions)

[`string.h header file`](#index-string_002eh-header-file)

[13.3 Common library functions](#Common-library-functions)

[`string.h header file`](#index-string_002eh-header-file-1)

[15.4 String library functions](#String-library-functions)

[`strlen function`](#index-strlen-function)

[15.4 String library functions](#String-library-functions)

[`strncat function`](#index-strncat-function)

[15.4 String library functions](#String-library-functions)

[`strncmp function`](#index-strncmp-function)

[15.4 String library functions](#String-library-functions)

[`strncpy function`](#index-strncpy-function)

[15.4 String library functions](#String-library-functions)

[`strstr function`](#index-strstr-function)

[15.4 String library functions](#String-library-functions)

[`struct type`](#index-struct-type)

[19. More data types](#More-data-types)

[`struct type`](#index-struct-type-1)

[19.5 `struct` and `union`](#struct-and-union)

[`struct type`](#index-struct-type-2)

[20.1 `struct`](#struct)

[`switch command`](#index-switch-command)

[10. Decisions](#Decisions)

[`switch command`](#index-switch-command-1)

[10.5 The `switch` statement](#The-switch-statement)

------------------------------------------------------------------------

[T]{#Code-index-1_fn_letter-T}

[`tan function`](#index-tan-function)

[13.4 Mathematical functions](#Mathematical-functions)

[`tanh function`](#index-tanh-function)

[13.4 Mathematical functions](#Mathematical-functions)

[`tgmath.h header file`](#index-tgmath_002eh-header-file)

[13.4 Mathematical functions](#Mathematical-functions)

[`toascii function`](#index-toascii-function)

[13.3.1 Character handling](#Character-handling)

[`tolower function`](#index-tolower-function)

[13.3.1 Character handling](#Character-handling)

[`toupper function`](#index-toupper-function)

[13.3.1 Character handling](#Character-handling)

[`TRUE macro`](#index-TRUE-macro)

[7.8 Comparisons and logic](#Comparisons-and-logic)

[`typedef command`](#index-typedef-command)

[19.6 `typedef`](#typedef)

------------------------------------------------------------------------

[U]{#Code-index-1_fn_letter-U}

[`u output conversion specifier`](#index-u-output-conversion-specifier)

[16.2.2.2 Formatted output conversion
specifiers](#Formatted-output-conversion-specifiers)

[`ungetc function`](#index-ungetc-function)

[16.3.5 `ungetc()`](#ungetc)

[`union type`](#index-union-type)

[19. More data types](#More-data-types)

[`union type`](#index-union-type-1)

[19.5 `struct` and `union`](#struct-and-union)

[`union type`](#index-union-type-2)

[20.3 `union`](#union)

[`unlink function`](#index-unlink-function)

[16.5.7 Deleting files at a low level](#Deleting-files-at-a-low-level)

[`unsigned char type`](#index-unsigned-char-type)

[5.1 Integer variables](#Integer-variables)

[`unsigned char type`](#index-unsigned-char-type-1)

[5.1.1 The `char` type](#The-char-type)

[`unsigned int type`](#index-unsigned-int-type)

[5.1 Integer variables](#Integer-variables)

[`unsigned long long type`](#index-unsigned-long-long-type)

[5.1 Integer variables](#Integer-variables)

[`unsigned long type`](#index-unsigned-long-type)

[5.1 Integer variables](#Integer-variables)

[`unsigned short type`](#index-unsigned-short-type)

[5.1 Integer variables](#Integer-variables)

------------------------------------------------------------------------

[V]{#Code-index-1_fn_letter-V}

[`void type`](#index-void-type)

[19. More data types](#More-data-types)

[`void type`](#index-void-type-1)

[19.2 `void`](#void)

[`volatile type`](#index-volatile-type)

[19. More data types](#More-data-types)

[`volatile type`](#index-volatile-type-1)

[19.3 `volatile`](#volatile)

------------------------------------------------------------------------

[W]{#Code-index-1_fn_letter-W}

[`while command`](#index-while-command)

[11. Loops](#Loops)

[`write function`](#index-write-function)

[16.5.5 Writing files at a low level](#Writing-files-at-a-low-level)

[`write function`](#index-write-function-1)

[16.5.5 Writing files at a low level](#Writing-files-at-a-low-level)

------------------------------------------------------------------------

[X]{#Code-index-1_fn_letter-X}

[`x input conversion specifier`](#index-x-input-conversion-specifier)

[16.2.8.2 Formatted input conversion
specifiers](#Formatted-input-conversion-specifiers)

[`X input conversion specifier`](#index-X-input-conversion-specifier)

[16.2.8.2 Formatted input conversion
specifiers](#Formatted-input-conversion-specifiers)

[`x output conversion specifier`](#index-x-output-conversion-specifier)

[16.2.2.2 Formatted output conversion
specifiers](#Formatted-output-conversion-specifiers)

[`X output conversion specifier`](#index-X-output-conversion-specifier)

[16.2.2.2 Formatted output conversion
specifiers](#Formatted-output-conversion-specifiers)

------------------------------------------------------------------------

[Z]{#Code-index-1_fn_letter-Z}

[`z input conversion specifier modifier`](#index-z-input-conversion-specifier-modifier)

[16.2.8.2 Formatted input conversion
specifiers](#Formatted-input-conversion-specifiers)

[`Z output conversion specifier modifier`](#index-Z-output-conversion-specifier-modifier)

[16.2.2.2 Formatted output conversion
specifiers](#Formatted-output-conversion-specifiers)

[`z output conversion specifier modifier`](#index-z-output-conversion-specifier-modifier)

[16.2.2.2 Formatted output conversion
specifiers](#Formatted-output-conversion-specifiers)

------------------------------------------------------------------------

  ------------ -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  Jump to:     [**\#**](#Code-index-1_fn_symbol-1){.summary-letter}   [**%**](#Code-index-1_fn_symbol-2){.summary-letter}   [**&**](#Code-index-1_fn_symbol-3){.summary-letter}   [**\'**](#Code-index-1_fn_symbol-4){.summary-letter}   [**\***](#Code-index-1_fn_symbol-5){.summary-letter}   [**+**](#Code-index-1_fn_symbol-6){.summary-letter}   [**,**](#Code-index-1_fn_symbol-7){.summary-letter}   [**-**](#Code-index-1_fn_symbol-8){.summary-letter}   [**.**](#Code-index-1_fn_symbol-9){.summary-letter}   [**/**](#Code-index-1_fn_symbol-10){.summary-letter}   [**0**](#Code-index-1_fn_symbol-11){.summary-letter}   [**\<**](#Code-index-1_fn_symbol-12){.summary-letter}   [**=**](#Code-index-1_fn_symbol-13){.summary-letter}   [**\>**](#Code-index-1_fn_symbol-14){.summary-letter}   [**?**](#Code-index-1_fn_symbol-15){.summary-letter}   [**\[**](#Code-index-1_fn_symbol-16){.summary-letter}   [**\^**](#Code-index-1_fn_symbol-17){.summary-letter}   [**\|**](#Code-index-1_fn_symbol-18){.summary-letter}   [**\~**](#Code-index-1_fn_symbol-19){.summary-letter}  \
               [**A**](#Code-index-1_fn_letter-A){.summary-letter}   [**B**](#Code-index-1_fn_letter-B){.summary-letter}   [**C**](#Code-index-1_fn_letter-C){.summary-letter}   [**D**](#Code-index-1_fn_letter-D){.summary-letter}   [**E**](#Code-index-1_fn_letter-E){.summary-letter}   [**F**](#Code-index-1_fn_letter-F){.summary-letter}   [**G**](#Code-index-1_fn_letter-G){.summary-letter}   [**H**](#Code-index-1_fn_letter-H){.summary-letter}   [**I**](#Code-index-1_fn_letter-I){.summary-letter}   [**K**](#Code-index-1_fn_letter-K){.summary-letter}   [**L**](#Code-index-1_fn_letter-L){.summary-letter}   [**M**](#Code-index-1_fn_letter-M){.summary-letter}   [**N**](#Code-index-1_fn_letter-N){.summary-letter}   [**O**](#Code-index-1_fn_letter-O){.summary-letter}   [**P**](#Code-index-1_fn_letter-P){.summary-letter}   [**Q**](#Code-index-1_fn_letter-Q){.summary-letter}   [**R**](#Code-index-1_fn_letter-R){.summary-letter}   [**S**](#Code-index-1_fn_letter-S){.summary-letter}   [**T**](#Code-index-1_fn_letter-T){.summary-letter}   [**U**](#Code-index-1_fn_letter-U){.summary-letter}   [**V**](#Code-index-1_fn_letter-V){.summary-letter}   [**W**](#Code-index-1_fn_letter-W){.summary-letter}   [**X**](#Code-index-1_fn_letter-X){.summary-letter}   [**Z**](#Code-index-1_fn_letter-Z){.summary-letter}  

  ------------ -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

------------------------------------------------------------------------

[]{#Concept-index}

  ----------------------------------------------------------- ------------------------------------------------------------ --- ------------------------------------------------------------------------- ----------------------------- --------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Code-index "Previous section in reading order")\]   \[[\>](#Bits-and-pieces "Next section in reading order")\]       \[[\<\<](#Code-index "Beginning of this chapter or previous chapter")\]   \[[Up](#Top "Up section")\]   \[[\>\>](#Bits-and-pieces "Next chapter")\]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ----------------------------------------------------------- ------------------------------------------------------------ --- ------------------------------------------------------------------------- ----------------------------- --------------------------------------------- --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Concept-index-1}

Concept index {#concept-index .unnumbered}
=============

  ------------ ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  Jump to:     [**.**](#Concept-index-1_cp_symbol-1){.summary-letter}   [**\\**](#Concept-index-1_cp_symbol-2){.summary-letter}  \
               [**A**](#Concept-index-1_cp_letter-A){.summary-letter}   [**B**](#Concept-index-1_cp_letter-B){.summary-letter}   [**C**](#Concept-index-1_cp_letter-C){.summary-letter}   [**D**](#Concept-index-1_cp_letter-D){.summary-letter}   [**E**](#Concept-index-1_cp_letter-E){.summary-letter}   [**F**](#Concept-index-1_cp_letter-F){.summary-letter}   [**G**](#Concept-index-1_cp_letter-G){.summary-letter}   [**H**](#Concept-index-1_cp_letter-H){.summary-letter}   [**I**](#Concept-index-1_cp_letter-I){.summary-letter}   [**J**](#Concept-index-1_cp_letter-J){.summary-letter}   [**K**](#Concept-index-1_cp_letter-K){.summary-letter}   [**L**](#Concept-index-1_cp_letter-L){.summary-letter}   [**M**](#Concept-index-1_cp_letter-M){.summary-letter}   [**N**](#Concept-index-1_cp_letter-N){.summary-letter}   [**O**](#Concept-index-1_cp_letter-O){.summary-letter}   [**P**](#Concept-index-1_cp_letter-P){.summary-letter}   [**Q**](#Concept-index-1_cp_letter-Q){.summary-letter}   [**R**](#Concept-index-1_cp_letter-R){.summary-letter}   [**S**](#Concept-index-1_cp_letter-S){.summary-letter}   [**T**](#Concept-index-1_cp_letter-T){.summary-letter}   [**U**](#Concept-index-1_cp_letter-U){.summary-letter}   [**V**](#Concept-index-1_cp_letter-V){.summary-letter}   [**W**](#Concept-index-1_cp_letter-W){.summary-letter}   [**X**](#Concept-index-1_cp_letter-X){.summary-letter}   [**Z**](#Concept-index-1_cp_letter-Z){.summary-letter}  

  ------------ ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Index Entry

Section

------------------------------------------------------------------------

[.]{#Concept-index-1_cp_symbol-1}

['./' (dot-slash) prefix in
shell](#index-_002e_002f-_0028dot_002dslash_0029-prefix-in-shell)

[2.1 Basic ideas about C](#Basic-ideas)

------------------------------------------------------------------------

[\\]{#Concept-index-1_cp_symbol-2}

[`\` (backslash), for makefile continuation
lines](#index-_005c-_0028backslash_0029_002c-for-makefile-continuation-lines)

[17.5.2 A simple makefile](#A-simple-makefile)

------------------------------------------------------------------------

[A]{#Concept-index-1_cp_letter-A}

[Actual parameters](#index-Actual-parameters)

[8.3 Actual parameters and formal
parameters](#Actual-parameters-and-formal-parameters)

[Actual parameters, passing as
pointers](#index-Actual-parameters_002c-passing-as-pointers)

[9.4.1 Passing pointers correctly](#Passing-pointers-correctly)

[Addition operator](#index-Addition-operator)

[7. Expressions and operators](#Expressions-and-operators)

[Addresses, memory](#index-Addresses_002c-memory)

[9. Pointers](#Pointers)

[Advantages of the C language](#index-Advantages-of-the-C-language)

[1.1 The advantages of C](#Advantages-of-C)

[Allocation of memory](#index-Allocation-of-memory)

[20.2 Memory allocation](#Memory-allocation)

[AND assignment](#index-AND-assignment)

[18.3.1 Bitwise operators](#Bitwise-operators)

[AND, bitwise, truth table](#index-AND_002c-bitwise_002c-truth-table)

[18.3.3.2 Bitwise AND](#Bitwise-AND)

[Annotating programs](#index-Annotating-programs)

[3.2 Comments](#Comments)

[ANSI Standard C](#index-ANSI-Standard-C)

[3.1 A word about style](#A-word-about-style)

[ANSI Standard C](#index-ANSI-Standard-C-1)

[3.3 Example 1](#Example-comment)

[ANSI Standard C](#index-ANSI-Standard-C-2)

[4. Functions](#Functions)

[`argc`, example of](#index-argc_002c-example-of)

[17.1 `argc` and `argv`](#argc-and-argv)

[`argp`, example of](#index-argp_002c-example-of)

[17.2.1 `argp` description](#argp-description)

[Argument count variable](#index-Argument-count-variable)

[17.1 `argc` and `argv`](#argc-and-argv)

[Argument vector](#index-Argument-vector)

[17.1 `argc` and `argv`](#argc-and-argv)

[Argument vector](#index-Argument-vector-1)

[17.1 `argc` and `argv`](#argc-and-argv)

[`argv`, example of](#index-argv_002c-example-of)

[17.1 `argc` and `argv`](#argc-and-argv)

[Arithmetic operators](#index-Arithmetic-operators)

[7.2 Expressions and values](#Expressions-and-values)

[Arithmetic operators](#index-Arithmetic-operators-1)

[7.7 More Special Assignments](#More-Special-Assignments)

[Array bounds](#index-Array-bounds)

[14.1 Array bounds](#Array-bounds)

[Array out of bounds errors](#index-Array-out-of-bounds-errors)

[23.3.4 Array out of bounds](#Array-out-of-bounds)

[Arrays](#index-Arrays)

[14. Arrays](#Arrays)

[Arrays and `for` loops](#index-Arrays-and-for-loops)

[14.2 Arrays and `for` loops](#Arrays-and-for-loops)

[Arrays and hidden operators](#index-Arrays-and-hidden-operators)

[18.1.3 Arrays and hidden operators](#Arrays-and-hidden-operators)

[Arrays and nested loops](#index-Arrays-and-nested-loops)

[14.4 Arrays and nested loops](#Arrays-and-nested-loops)

[Arrays and pointers, equivalence
of](#index-Arrays-and-pointers_002c-equivalence-of)

[14.6 Arrays as Parameters](#Arrays-as-Parameters)

[Arrays as parameters](#index-Arrays-as-parameters)

[14.6 Arrays as Parameters](#Arrays-as-Parameters)

[Arrays of strings](#index-Arrays-of-strings)

[15.3 String arrays](#String-arrays)

[Arrays of structures](#index-Arrays-of-structures)

[20.1.3 Arrays of structures](#Arrays-of-structures)

[Arrays, bounds of](#index-Arrays_002c-bounds-of)

[14.1 Array bounds](#Array-bounds)

[Arrays, defining](#index-Arrays_002c-defining)

[14. Arrays](#Arrays)

[Arrays, initializing](#index-Arrays_002c-initializing)

[14.2 Arrays and `for` loops](#Arrays-and-for-loops)

[Arrays, initializing](#index-Arrays_002c-initializing-1)

[14.4 Arrays and nested loops](#Arrays-and-nested-loops)

[Arrays, initializing](#index-Arrays_002c-initializing-2)

[14.5 Initializing arrays](#Initializing-arrays)

[Arrays, multidimensional](#index-Arrays_002c-multidimensional)

[11.6 Nested loops](#Nested-loops)

[Arrays, multidimensional](#index-Arrays_002c-multidimensional-1)

[14. Arrays](#Arrays)

[Arrays, multidimensional](#index-Arrays_002c-multidimensional-2)

[14.3 Multidimensional arrays](#Multidimensional-arrays)

[Arrays, multidimensional,
initializing](#index-Arrays_002c-multidimensional_002c-initializing)

[14.4 Arrays and nested loops](#Arrays-and-nested-loops)

[Arrays, one-based](#index-Arrays_002c-one_002dbased)

[14. Arrays](#Arrays)

[Arrays, out of bounds](#index-Arrays_002c-out-of-bounds)

[23.3.4 Array out of bounds](#Array-out-of-bounds)

[Arrays, reading from streams](#index-Arrays_002c-reading-from-streams)

[16.1.3 Block input and output](#Block-input-and-output)

[Arrays, reading from
streams](#index-Arrays_002c-reading-from-streams-1)

[16.1.3 Block input and output](#Block-input-and-output)

[Arrays, writing to streams](#index-Arrays_002c-writing-to-streams)

[16.1.3 Block input and output](#Block-input-and-output)

[Arrays, writing to streams](#index-Arrays_002c-writing-to-streams-1)

[16.1.3 Block input and output](#Block-input-and-output)

[Arrays, zero-based nature
of](#index-Arrays_002c-zero_002dbased-nature-of)

[14. Arrays](#Arrays)

[Assignment](#index-Assignment)

[2.4 Errors](#Errors)

[Assignment operator](#index-Assignment-operator)

[7.1 The assignment operator](#The-assignment-operator)

[Assignment operator, confused with equality
operator](#index-Assignment-operator_002c-confused-with-equality-operator)

[7.1.1 Important note about
assignment](#Important-note-about-assignment)

[Assignment operator, confused with equality
operator](#index-Assignment-operator_002c-confused-with-equality-operator-1)

[7.8 Comparisons and logic](#Comparisons-and-logic)

[Assignment, example of](#index-Assignment_002c-example-of)

[2.4 Errors](#Errors)

[Assignments, hidden](#index-Assignments_002c-hidden)

[18.1.1 Hidden assignments](#Hidden-assignments)

[Automobile as metaphor for
computer](#index-Automobile-as-metaphor-for-computer)

[1. Introduction](#Introduction)

------------------------------------------------------------------------

[B]{#Concept-index-1_cp_letter-B}

[backslash (`\`), for makefile continuation
lines](#index-backslash-_0028_005c_0029_002c-for-makefile-continuation-lines)

[17.5.2 A simple makefile](#A-simple-makefile)

[Binary digits](#index-Binary-digits)

[18.3 Machine-level operators](#Machine_002dlevel-operators)

[Binary trees](#index-Binary-trees)

[20.4.3.2 Binary trees](#Binary-trees)

[Bit masks](#index-Bit-masks)

[18.3.3 Truth tables and bit masks](#Truth-tables-and-bit-masks)

[Bit masks](#index-Bit-masks-1)

[18.3.3.5 Masks](#Masks)

[Bit strings](#index-Bit-strings)

[18.3 Machine-level operators](#Machine_002dlevel-operators)

[Bit-shift left assignment](#index-Bit_002dshift-left-assignment)

[18.3.1 Bitwise operators](#Bitwise-operators)

[Bit-shift left operator](#index-Bit_002dshift-left-operator)

[18.3.1 Bitwise operators](#Bitwise-operators)

[Bit-shift right assignment](#index-Bit_002dshift-right-assignment)

[18.3.1 Bitwise operators](#Bitwise-operators)

[Bit-shift right operator](#index-Bit_002dshift-right-operator)

[18.3.1 Bitwise operators](#Bitwise-operators)

[Bits](#index-Bits)

[18.3 Machine-level operators](#Machine_002dlevel-operators)

[Bitwise AND](#index-Bitwise-AND)

[18.3.1 Bitwise operators](#Bitwise-operators)

[Bitwise AND, truth table](#index-Bitwise-AND_002c-truth-table)

[18.3.3.2 Bitwise AND](#Bitwise-AND)

[Bitwise exclusive OR](#index-Bitwise-exclusive-OR)

[18.3.1 Bitwise operators](#Bitwise-operators)

[Bitwise exclusive OR, truth
table](#index-Bitwise-exclusive-OR_002c-truth-table)

[18.3.3.4 Bitwise exclusive OR
(XOR/EOR)](#Bitwise-exclusive-OR-_0028XOR_002fEOR_0029)

[Bitwise inclusive OR](#index-Bitwise-inclusive-OR)

[18.3.1 Bitwise operators](#Bitwise-operators)

[Bitwise inclusive OR, truth
table](#index-Bitwise-inclusive-OR_002c-truth-table)

[18.3.3.3 Bitwise inclusive OR](#Bitwise-inclusive-OR)

[Bitwise NOT](#index-Bitwise-NOT)

[18.3.1 Bitwise operators](#Bitwise-operators)

[Bitwise NOT, truth table](#index-Bitwise-NOT_002c-truth-table)

[18.3.3.1 Bitwise NOT](#Bitwise-NOT)

[Bitwise operators](#index-Bitwise-operators)

[18.3.1 Bitwise operators](#Bitwise-operators)

[Black boxes](#index-Black-boxes)

[1. Introduction](#Introduction)

[Black boxes, disadvantages
of](#index-Black-boxes_002c-disadvantages-of)

[1.1 The advantages of C](#Advantages-of-C)

[Block input](#index-Block-input)

[16.1.3 Block input and output](#Block-input-and-output)

[Block output](#index-Block-output)

[16.1.3 Block input and output](#Block-input-and-output)

[Blocks, code](#index-Blocks_002c-code)

[6.2 Local Variables](#Local-variables)

[Bookmark, file position compared
to](#index-Bookmark_002c-file-position-compared-to)

[16.1.4 File position](#File-position)

[Boolean values](#index-Boolean-values)

[7. Expressions and operators](#Expressions-and-operators)

[Boolean values](#index-Boolean-values-1)

[7.8 Comparisons and logic](#Comparisons-and-logic)

[Bounds of arrays](#index-Bounds-of-arrays)

[14.1 Array bounds](#Array-bounds)

[Boxes, black](#index-Boxes_002c-black)

[1. Introduction](#Introduction)

[`break`, terminating loops
with](#index-break_002c-terminating-loops-with)

[11.5.1 Terminating loops with `break`](#Terminating-loops-with-break)

[Breaking out of `switch`
statement](#index-Breaking-out-of-switch-statement)

[10.5 The `switch` statement](#The-switch-statement)

[Breaking out of `switch`
statement](#index-Breaking-out-of-switch-statement-1)

[10.6 Example Listing](#Example-15)

[Buffering, full](#index-Buffering_002c-full)

[16.1.5 Stream buffering](#Stream-buffering)

[Buffering, line](#index-Buffering_002c-line)

[16.1.5 Stream buffering](#Stream-buffering)

[Buffering, no](#index-Buffering_002c-no)

[16.1.5 Stream buffering](#Stream-buffering)

[Buffering, stream](#index-Buffering_002c-stream)

[16.1.5 Stream buffering](#Stream-buffering)

[Buffers](#index-Buffers)

[16.1.5 Stream buffering](#Stream-buffering)

[Buffers, flushing](#index-Buffers_002c-flushing)

[23.3.5 Uncoordinated output](#Uncoordinated-output)

[Bugs](#index-Bugs)

[2.4 Errors](#Errors)

[Bugs, compile-time](#index-Bugs_002c-compile_002dtime)

[2.4 Errors](#Errors)

[Building block, function as](#index-Building-block_002c-function-as)

[3. The form of a C program](#The-form-of-a-C-program)

[Building libraries](#index-Building-libraries)

[17.6 Building a library](#Building-a-library)

[Buildings as metaphor for
functions](#index-Buildings-as-metaphor-for-functions)

[6. Scope](#Scope)

[Bytes](#index-Bytes)

[18.3 Machine-level operators](#Machine_002dlevel-operators)

------------------------------------------------------------------------

[C]{#Concept-index-1_cp_letter-C}

[C language and peripherals](#index-C-language-and-peripherals)

[1.1 The advantages of C](#Advantages-of-C)

[C language as high-level
language](#index-C-language-as-high_002dlevel-language)

[1. Introduction](#Introduction)

[C language as standard](#index-C-language-as-standard)

[Preface](#Preface)

[C language, advantages of](#index-C-language_002c-advantages-of)

[1.1 The advantages of C](#Advantages-of-C)

[C language, case-sensitivity
of](#index-C-language_002c-case_002dsensitivity-of)

[2.4.1 Typographical errors](#Typographical-errors)

[C language, concealed
difficulties](#index-C-language_002c-concealed-difficulties)

[1.1 The advantages of C](#Advantages-of-C)

[C language, flexibility of](#index-C-language_002c-flexibility-of)

[1.1 The advantages of C](#Advantages-of-C)

[C language, power of](#index-C-language_002c-power-of)

[Preface](#Preface)

[C language, power of](#index-C-language_002c-power-of-1)

[1.1 The advantages of C](#Advantages-of-C)

[C language, succinctness of](#index-C-language_002c-succinctness-of)

[1.1 The advantages of C](#Advantages-of-C)

[C language, unforgiving
nature](#index-C-language_002c-unforgiving-nature)

[Preface](#Preface)

[C language, why it is useful](#index-C-language_002c-why-it-is-useful)

[Preface](#Preface)

[C program, simplest](#index-C-program_002c-simplest)

[3. The form of a C program](#The-form-of-a-C-program)

[C, ANSI Standard](#index-C_002c-ANSI-Standard)

[3.1 A word about style](#A-word-about-style)

[C, ANSI Standard](#index-C_002c-ANSI-Standard-1)

[3.3 Example 1](#Example-comment)

[C, ANSI Standard](#index-C_002c-ANSI-Standard-2)

[4. Functions](#Functions)

[C, reserved words in](#index-C_002c-reserved-words-in)

[B. Reserved words in C](#Reserved-words-in-C)

[Car as metaphor for computer](#index-Car-as-metaphor-for-computer)

[1. Introduction](#Introduction)

[Case-sensitivity of C
language](#index-Case_002dsensitivity-of-C-language)

[2.4.1 Typographical errors](#Typographical-errors)

[Cast operator](#index-Cast-operator)

[7. Expressions and operators](#Expressions-and-operators)

[Cast operator](#index-Cast-operator-1)

[9.2 Pointer types](#Pointer-types)

[Casting pointer types](#index-Casting-pointer-types)

[9.2 Pointer types](#Pointer-types)

[Casting types](#index-Casting-types)

[5.4 The cast operator](#The-cast-operator)

[Casting types, example](#index-Casting-types_002c-example)

[5.4.1 Cast operator demo](#Cast-operator-demo)

[Character conversion table](#index-Character-conversion-table)

[E. Character conversion table](#Character-conversion-table)

[Character functions, example
of](#index-Character-functions_002c-example-of)

[13.3.1 Character handling](#Character-handling)

[Character handling](#index-Character-handling)

[13.3.1 Character handling](#Character-handling)

[Characters, confused with
strings](#index-Characters_002c-confused-with-strings)

[15.1 Conventions and declarations](#Conventions-and-declarations)

[Characters, special](#index-Characters_002c-special)

[D. Special characters](#Special-characters)

[Chess, GNU](#index-Chess_002c-GNU)

[14.3 Multidimensional arrays](#Multidimensional-arrays)

[Chessboard, represented by
array](#index-Chessboard_002c-represented-by-array)

[14.3 Multidimensional arrays](#Multidimensional-arrays)

[Classes, storage](#index-Classes_002c-storage)

[5.5 Storage classes](#Storage-classes)

[Classes, storage](#index-Classes_002c-storage-1)

[5.5.3 Other storage classes](#Other-storage-classes)

[`clean` makefile target](#index-clean-makefile-target)

[17.5.2 A simple makefile](#A-simple-makefile)

[cleaning up](#index-cleaning-up)

[17.5.7 Rules for cleaning the
directory](#Rules-for-cleaning-the-directory)

[`close`, example of](#index-close_002c-example-of)

[16.5.3 Closing files at a low level](#Closing-files-at-a-low-level)

[Closing files](#index-Closing-files)

[16.1.2 Closing a file](#Closing-a-file)

[Closing files at a low level](#index-Closing-files-at-a-low-level)

[16.5.3 Closing files at a low level](#Closing-files-at-a-low-level)

[Code blocks](#index-Code-blocks)

[6.2 Local Variables](#Local-variables)

[Code, object](#index-Code_002c-object)

[2.2 The compiler](#The-compiler)

[Code, source](#index-Code_002c-source)

[2.2 The compiler](#The-compiler)

[Combining rules by
prerequisite](#index-Combining-rules-by-prerequisite)

[17.5.6 Combining rules by
prerequisite](#Combining-rules-by-prerequisite)

[Comma operator](#index-Comma-operator)

[18.2 The comma operator](#The-comma-operator)

[Command shell](#index-Command-shell)

[2. Using a compiler](#Using-a-compiler)

[Command shell](#index-Command-shell-1)

[2.1 Basic ideas about C](#Basic-ideas)

[Command-line options](#index-Command_002dline-options)

[17.2 Processing command-line
options](#Processing-command_002dline-options)

[Commands, deducing from implicit makefile
rules](#index-Commands_002c-deducing-from-implicit-makefile-rules)

[17.5.5 Letting make deduce commands](#Letting-make-deduce-commands)

[Comment characters](#index-Comment-characters)

[3. The form of a C program](#The-form-of-a-C-program)

[Comment characters](#index-Comment-characters-1)

[3.2 Comments](#Comments)

[Comments](#index-Comments)

[3. The form of a C program](#The-form-of-a-C-program)

[Comments](#index-Comments-1)

[3.2 Comments](#Comments)

[Comments, example](#index-Comments_002c-example)

[3.2 Comments](#Comments)

[Comments, style guidelines
for](#index-Comments_002c-style-guidelines-for)

[22.2 Comments and style](#Comments-and-style)

[Common library functions](#index-Common-library-functions)

[13.3 Common library functions](#Common-library-functions)

[Communication via parameters](#index-Communication-via-parameters)

[6.3 Communication via parameters](#Communication-via-parameters)

[Comparison operators](#index-Comparison-operators)

[7. Expressions and operators](#Expressions-and-operators)

[Comparison operators](#index-Comparison-operators-1)

[7.8 Comparisons and logic](#Comparisons-and-logic)

[Comparison operators](#index-Comparison-operators-2)

[7.9 Logical operators](#Logical-operators)

[Compile-time bugs](#index-Compile_002dtime-bugs)

[2.4 Errors](#Errors)

[Compile-time errors](#index-Compile_002dtime-errors)

[2.4 Errors](#Errors)

[Compile-time errors](#index-Compile_002dtime-errors-1)

[2.4 Errors](#Errors)

[Compile-time errors](#index-Compile_002dtime-errors-2)

[23.1 Compile-time errors](#Compile_002dtime-errors)

[Compiler](#index-Compiler)

[2. Using a compiler](#Using-a-compiler)

[Compiler](#index-Compiler-1)

[2.1 Basic ideas about C](#Basic-ideas)

[Compiler](#index-Compiler-2)

[2.2 The compiler](#The-compiler)

[Compiler](#index-Compiler-3)

[2.2 The compiler](#The-compiler)

[Compiler passes](#index-Compiler-passes)

[2.2 The compiler](#The-compiler)

[Compiling libraries](#index-Compiling-libraries)

[17.6 Building a library](#Building-a-library)

[Compiling multiple files](#index-Compiling-multiple-files)

[17.4 Compiling multiple files](#Compiling-multiple-files)

[Complex data structures](#index-Complex-data-structures)

[20.4 Complex data structures](#Complex-data-structures)

[Complex data structures](#index-Complex-data-structures-1)

[20.4.2 Dynamic data structures, Pointers and Dynamic
Memory](#Dynamic-data-structures)

[Compound decisions](#index-Compound-decisions)

[10.3 Nested `if` statements](#Nested-if-statements)

[Computer crash](#index-Computer-crash)

[2.4 Errors](#Errors)

[Concealed difficulties of C
language](#index-Concealed-difficulties-of-C-language)

[1.1 The advantages of C](#Advantages-of-C)

[Constant expressions](#index-Constant-expressions)

[19.4.2 Constant expressions](#Constant-expressions)

[Constants](#index-Constants)

[19.4 Constants](#Constants)

[Constants, string](#index-Constants_002c-string)

[15.2 Initializing strings](#Initializing-strings)

[Continuation lines in
makefiles](#index-Continuation-lines-in-makefiles)

[17.5.2 A simple makefile](#A-simple-makefile)

[`continue`, optimizing loops
with](#index-continue_002c-optimizing-loops-with)

[11.5.3 Speeding loops with `continue`](#Speeding-loops-with-continue)

[`continue`, speeding loops
with](#index-continue_002c-speeding-loops-with)

[11.5.3 Speeding loops with `continue`](#Speeding-loops-with-continue)

[Controlled recursion with data
structures](#index-Controlled-recursion-with-data-structures)

[21.3 Controlled recursion with data
structures](#Controlled-recursion-with-data-structures)

[Conventions, file name](#index-Conventions_002c-file-name)

[2.3 File names](#File-names)

[Conversion specifiers, formatted
input](#index-Conversion-specifiers_002c-formatted-input)

[16.2.8.1 `sscanf`](#sscanf)

[Conversion specifiers, formatted
input](#index-Conversion-specifiers_002c-formatted-input-1)

[16.2.8.2 Formatted input conversion
specifiers](#Formatted-input-conversion-specifiers)

[Conversion specifiers, formatted
output](#index-Conversion-specifiers_002c-formatted-output)

[16.2.2.2 Formatted output conversion
specifiers](#Formatted-output-conversion-specifiers)

[Conversion specifiers, formatted output,
modifiers](#index-Conversion-specifiers_002c-formatted-output_002c-modifiers)

[16.2.2.2 Formatted output conversion
specifiers](#Formatted-output-conversion-specifiers)

[Conversion specifiers, formatted output,
modifiers](#index-Conversion-specifiers_002c-formatted-output_002c-modifiers-1)

[16.2.2.2 Formatted output conversion
specifiers](#Formatted-output-conversion-specifiers)

[Conversion specifiers, formatted output, table
of](#index-Conversion-specifiers_002c-formatted-output_002c-table-of)

[16.2.2.2 Formatted output conversion
specifiers](#Formatted-output-conversion-specifiers)

[Conversion table, character](#index-Conversion-table_002c-character)

[E. Character conversion table](#Character-conversion-table)

[Crash, computer](#index-Crash_002c-computer)

[2.4 Errors](#Errors)

[Creating shared libraries](#index-Creating-shared-libraries)

[17.6 Building a library](#Building-a-library)

[Creating static libraries](#index-Creating-static-libraries)

[17.6 Building a library](#Building-a-library)

[Creation of files](#index-Creation-of-files)

[16.5.2.1 File creation](#File-creation)

[Curly brackets as walls](#index-Curly-brackets-as-walls)

[6. Scope](#Scope)

------------------------------------------------------------------------

[D]{#Concept-index-1_cp_letter-D}

[Daemons](#index-Daemons)

[16.1.5 Stream buffering](#Stream-buffering)

[Data structure diagrams](#index-Data-structure-diagrams)

[20.4.1 Data structure diagrams](#Data-structure-diagrams)

[Data structures](#index-Data-structures)

[20. Data structures](#Data-structures)

[Data structures with controlled
recursion](#index-Data-structures-with-controlled-recursion)

[21.3 Controlled recursion with data
structures](#Controlled-recursion-with-data-structures)

[Data structures, as distinguished from
structures](#index-Data-structures_002c-as-distinguished-from-structures)

[20. Data structures](#Data-structures)

[Data structures, complex](#index-Data-structures_002c-complex)

[20.4 Complex data structures](#Complex-data-structures)

[Data structures, complex](#index-Data-structures_002c-complex-1)

[20.4.2 Dynamic data structures, Pointers and Dynamic
Memory](#Dynamic-data-structures)

[Data structures, dynamic](#index-Data-structures_002c-dynamic)

[20.4.2 Dynamic data structures, Pointers and Dynamic
Memory](#Dynamic-data-structures)

[Data structures,
initializing](#index-Data-structures_002c-initializing)

[20.4.4.2 Initializing your data
structure](#Initializing-your-data-structure)

[Data structures, recursive](#index-Data-structures_002c-recursive)

[21.3 Controlled recursion with data
structures](#Controlled-recursion-with-data-structures)

[Data structures, setting up](#index-Data-structures_002c-setting-up)

[20.4.4 Setting up a data structure](#Setting-up-a-data-structure)

[Data types](#index-Data-types)

[19. More data types](#More-data-types)

[Data, dynamic](#index-Data_002c-dynamic)

[20.2 Memory allocation](#Memory-allocation)

[Debugging](#index-Debugging)

[23. Debugging](#Debugging)

[Decisions](#index-Decisions)

[10. Decisions](#Decisions)

[Decisions, compound](#index-Decisions_002c-compound)

[10.3 Nested `if` statements](#Nested-if-statements)

[Declaration, variable](#index-Declaration_002c-variable)

[2.4.2 Type errors](#Type-errors)

[Declarations, style guidelines
for](#index-Declarations_002c-style-guidelines-for)

[22.4 Declarations and initialization](#Declarations-and-initialization)

[Declarations, variable](#index-Declarations_002c-variable)

[4. Functions](#Functions)

[Declaring functions](#index-Declaring-functions)

[4.4 Function prototyping](#Function-prototyping)

[Declaring parameters](#index-Declaring-parameters)

[8. Parameters](#Parameters)

[Declaring structures](#index-Declaring-structures)

[20.1.1 Structure declarations](#Structure-declarations)

[Declaring structures with
`typedef`](#index-Declaring-structures-with-typedef)

[20.1.1.1 Structure declarations using
typedef](#Structure-declarations-using-typedef)

[Declaring unions](#index-Declaring-unions)

[20.3.1 Declaration of unions](#Declaration-of-unions)

[Declaring variables](#index-Declaring-variables)

[5. Variables and declarations](#Variables-and-declarations)

[Declaring variables](#index-Declaring-variables-1)

[5.2 Declarations](#Declarations)

[Deducing commands from implicit makefile
rules](#index-Deducing-commands-from-implicit-makefile-rules)

[17.5.5 Letting make deduce commands](#Letting-make-deduce-commands)

[default makefile goal](#index-default-makefile-goal)

[17.5.3 make in action](#make-in-action)

[Defining your own types](#index-Defining-your-own-types)

[2.4.2 Type errors](#Type-errors)

[Deleting files at a low level](#index-Deleting-files-at-a-low-level)

[16.5.7 Deleting files at a low level](#Deleting-files-at-a-low-level)

[Deprecated formatted string input
functions](#index-Deprecated-formatted-string-input-functions)

[16.2.9 Deprecated formatted string input
functions](#Deprecated-formatted-string-input-functions)

[Deprecated formatted string output
functions](#index-Deprecated-formatted-string-output-functions)

[16.2.5 Deprecated formatted string output
functions](#Deprecated-formatted-string-output-functions)

[Deprecated string input
functions](#index-Deprecated-string-input-functions)

[16.2.7 Deprecated string input
functions](#Deprecated-string-input-functions)

[Descriptors, file](#index-Descriptors_002c-file)

[16. Input and output](#Input-and-output)

[Descriptors, file](#index-Descriptors_002c-file-1)

[16. Input and output](#Input-and-output)

[Detail, levels of](#index-Detail_002c-levels-of)

[1. Introduction](#Introduction)

[Devices](#index-Devices)

[16. Input and output](#Input-and-output)

[Diagrams, data structures](#index-Diagrams_002c-data-structures)

[20.4.1 Data structure diagrams](#Data-structure-diagrams)

[Difference between `while` and
`do`](#index-Difference-between-while-and-do)

[11.2 `do`...`while`](#do_002e_002e_002ewhile)

[Different type argument error](#index-Different-type-argument-error)

[23.2.1 different type arg](#different-type-arg)

[Directives, preprocessor](#index-Directives_002c-preprocessor)

[12. Preprocessor directives](#Preprocessor-directives)

[Directives, preprocessor](#index-Directives_002c-preprocessor-1)

[12.1 A few directives](#A-few-directives)

[Directives, preprocessor](#index-Directives_002c-preprocessor-2)

[12.2 Macros](#Macros)

[Directives, preprocessor,
example](#index-Directives_002c-preprocessor_002c-example)

[12.2 Macros](#Macros)

[Disadvantages of black boxes](#index-Disadvantages-of-black-boxes)

[1.1 The advantages of C](#Advantages-of-C)

[Disk input](#index-Disk-input)

[24. Example programs](#Example-programs)

[Disk output](#index-Disk-output)

[24. Example programs](#Example-programs)

[`do` and `while`, difference
between](#index-do-and-while_002c-difference-between)

[11.2 `do`...`while`](#do_002e_002e_002ewhile)

[Dot-slash ('./') prefix in
shell](#index-Dot_002dslash-_0028_002e_002f_0029-prefix-in-shell)

[2.1 Basic ideas about C](#Basic-ideas)

[Dynamic data](#index-Dynamic-data)

[20.2 Memory allocation](#Memory-allocation)

[Dynamic data structures](#index-Dynamic-data-structures)

[20.4.2 Dynamic data structures, Pointers and Dynamic
Memory](#Dynamic-data-structures)

------------------------------------------------------------------------

[E]{#Concept-index-1_cp_letter-E}

[editor](#index-editor)

[17.5 Writing a makefile](#Writing-a-makefile)

[Emacs Info reader](#index-Emacs-Info-reader)

[Preface](#Preface)

[End-of-file functions](#index-End_002dof_002dfile-functions)

[16.1.6 End-of-file and error
functions](#End_002dof_002dfile-and-error-functions)

[End-of-file indicator](#index-End_002dof_002dfile-indicator)

[16.1.6 End-of-file and error
functions](#End_002dof_002dfile-and-error-functions)

[End-of-file indicator,
resetting](#index-End_002dof_002dfile-indicator_002c-resetting)

[16.1.6 End-of-file and error
functions](#End_002dof_002dfile-and-error-functions)

[Environment variables](#index-Environment-variables)

[17.3 Environment variables](#Environment-variables)

[EOR, truth table](#index-EOR_002c-truth-table)

[18.3.3.4 Bitwise exclusive OR
(XOR/EOR)](#Bitwise-exclusive-OR-_0028XOR_002fEOR_0029)

[Equality operator, confused with assignment
operator](#index-Equality-operator_002c-confused-with-assignment-operator)

[7.1.1 Important note about
assignment](#Important-note-about-assignment)

[Equality operator, confused with assignment
operator](#index-Equality-operator_002c-confused-with-assignment-operator-1)

[7.8 Comparisons and logic](#Comparisons-and-logic)

[Equals sign (`=`)](#index-Equals-sign-_0028_003d_0029)

[2.4 Errors](#Errors)

[Equivalence of pointers and
arrays](#index-Equivalence-of-pointers-and-arrays)

[14.6 Arrays as Parameters](#Arrays-as-Parameters)

[Error cascade](#index-Error-cascade)

[2.4 Errors](#Errors)

[Error functions](#index-Error-functions)

[16.1.6 End-of-file and error
functions](#End_002dof_002dfile-and-error-functions)

[Error indicator](#index-Error-indicator)

[16.1.6 End-of-file and error
functions](#End_002dof_002dfile-and-error-functions)

[Error indicator, resetting](#index-Error-indicator_002c-resetting)

[16.1.6 End-of-file and error
functions](#End_002dof_002dfile-and-error-functions)

[Errors](#index-Errors)

[2.4 Errors](#Errors)

[Errors, compile time](#index-Errors_002c-compile-time)

[23.1 Compile-time errors](#Compile_002dtime-errors)

[Errors, compile-time](#index-Errors_002c-compile_002dtime)

[2.4 Errors](#Errors)

[Errors, compile-time](#index-Errors_002c-compile_002dtime-1)

[2.4 Errors](#Errors)

[Errors, methematical](#index-Errors_002c-methematical)

[23.4 Mathematical errors](#Mathematical-errors)

[Errors, run-time](#index-Errors_002c-run_002dtime)

[2.4 Errors](#Errors)

[Errors, syntax](#index-Errors_002c-syntax)

[2.4 Errors](#Errors)

[Errors, type](#index-Errors_002c-type)

[2.4 Errors](#Errors)

[Errors, type](#index-Errors_002c-type-1)

[2.4.2 Type errors](#Type-errors)

[Errors, typographical](#index-Errors_002c-typographical)

[2.4.1 Typographical errors](#Typographical-errors)

[Example function](#index-Example-function)

[4.2 Function examples](#Function-examples)

[Example program, substantial](#index-Example-program_002c-substantial)

[24. Example programs](#Example-programs)

[Exceptions, floating-point](#index-Exceptions_002c-floating_002dpoint)

[23.4 Mathematical errors](#Mathematical-errors)

[Exclusive OR assignment](#index-Exclusive-OR-assignment)

[18.3.1 Bitwise operators](#Bitwise-operators)

[Exclusive OR, bitwise, truth
table](#index-Exclusive-OR_002c-bitwise_002c-truth-table)

[18.3.3.4 Bitwise exclusive OR
(XOR/EOR)](#Bitwise-exclusive-OR-_0028XOR_002fEOR_0029)

[Executable file](#index-Executable-file)

[2.3 File names](#File-names)

[Executable file](#index-Executable-file-1)

[2.4 Errors](#Errors)

[Executable file, running](#index-Executable-file_002c-running)

[2.1 Basic ideas about C](#Basic-ideas)

[Expressions](#index-Expressions)

[7.3 Expressions](#Expressions)

[Expressions, constant](#index-Expressions_002c-constant)

[19.4.2 Constant expressions](#Constant-expressions)

[External variables](#index-External-variables)

[5.5.1 External variables](#External-variables)

------------------------------------------------------------------------

[F]{#Concept-index-1_cp_letter-F}

[False Boolean value](#index-False-Boolean-value)

[7.8 Comparisons and logic](#Comparisons-and-logic)

[`fclose` command, example of](#index-fclose-command_002c-example-of)

[16.1.2 Closing a file](#Closing-a-file)

[FDL](#index-FDL)

[Preface](#Preface)

[File creation](#index-File-creation)

[16.5.2.1 File creation](#File-creation)

[File descriptors](#index-File-descriptors)

[16. Input and output](#Input-and-output)

[File descriptors](#index-File-descriptors-1)

[16. Input and output](#Input-and-output)

[File descriptors](#index-File-descriptors-2)

[16.5 Low-level file routines](#Low_002dlevel-file-routines)

[File functions, low-level](#index-File-functions_002c-low_002dlevel)

[16.5 Low-level file routines](#Low_002dlevel-file-routines)

[File name conventions](#index-File-name-conventions)

[2.3 File names](#File-names)

[File name errors, usual](#index-File-name-errors_002c-usual)

[16.5.1 Usual file name errors](#Usual-file-name-errors)

[File operations,
high-level](#index-File-operations_002c-high_002dlevel)

[16. Input and output](#Input-and-output)

[File operations, low-level](#index-File-operations_002c-low_002dlevel)

[16. Input and output](#Input-and-output)

[File position](#index-File-position)

[16.1.4 File position](#File-position)

[File position indicator](#index-File-position-indicator)

[16.3.5 `ungetc()`](#ungetc)

[File position, compared to
bookmark](#index-File-position_002c-compared-to-bookmark)

[16.1.4 File position](#File-position)

[File routines, high-level](#index-File-routines_002c-high_002dlevel)

[16.1 High-level file routines](#High_002dlevel-file-routines)

[File, executable](#index-File_002c-executable)

[2.3 File names](#File-names)

[File, executable](#index-File_002c-executable-1)

[2.4 Errors](#Errors)

[File, header](#index-File_002c-header)

[2.3 File names](#File-names)

[File, library](#index-File_002c-library)

[2.3 File names](#File-names)

[File, object](#index-File_002c-object)

[2.2 The compiler](#The-compiler)

[File, object](#index-File_002c-object-1)

[2.3 File names](#File-names)

[File, object code](#index-File_002c-object-code)

[2.2 The compiler](#The-compiler)

[File, source code](#index-File_002c-source-code)

[2.3 File names](#File-names)

[Files, closing](#index-Files_002c-closing)

[16.1.2 Closing a file](#Closing-a-file)

[Files, header](#index-Files_002c-header)

[13.1 Header files](#Header-files)

[Files, high-level operations
on](#index-Files_002c-high_002dlevel-operations-on)

[16. Input and output](#Input-and-output)

[Files, low-level operations
on](#index-Files_002c-low_002dlevel-operations-on)

[16. Input and output](#Input-and-output)

[Files, opening](#index-Files_002c-opening)

[16. Input and output](#Input-and-output)

[Files, opening](#index-Files_002c-opening-1)

[16.1.1 Opening a file](#Opening-a-file)

[Files, random-access](#index-Files_002c-random_002daccess)

[16.1.4 File position](#File-position)

[`findex`, example of](#index-findex_002c-example-of)

[16.2.7.2 `fgets`](#fgets)

[Finding file positions at a low
level](#index-Finding-file-positions-at-a-low-level)

[16.5.6 Finding file positions at a low
level](#Finding-file-positions-at-a-low-level)

[Flags](#index-Flags)

[18.3 Machine-level operators](#Machine_002dlevel-operators)

[Flexibility of `for` command](#index-Flexibility-of-for-command)

[11.4 The flexibility of `for`](#The-flexibility-of-for)

[Floating point numbers](#index-Floating-point-numbers)

[5.1.2 Floating point variables](#Floating-point-variables)

[Floating point variables](#index-Floating-point-variables)

[5.1.2 Floating point variables](#Floating-point-variables)

[Floating-point exceptions](#index-Floating_002dpoint-exceptions)

[23.4 Mathematical errors](#Mathematical-errors)

[Flushing buffers](#index-Flushing-buffers)

[23.3.5 Uncoordinated output](#Uncoordinated-output)

[Flushing streams](#index-Flushing-streams)

[16.1.5 Stream buffering](#Stream-buffering)

[`fopen` command, example of](#index-fopen-command_002c-example-of)

[16.1.1 Opening a file](#Opening-a-file)

[`for` command, flexibility of](#index-for-command_002c-flexibility-of)

[11.4 The flexibility of `for`](#The-flexibility-of-for)

[`for` loops and arrays](#index-for-loops-and-arrays)

[14.2 Arrays and `for` loops](#Arrays-and-for-loops)

[`for` loops, nested](#index-for-loops_002c-nested)

[14.4 Arrays and nested loops](#Arrays-and-nested-loops)

[Formal parameters](#index-Formal-parameters)

[8.3 Actual parameters and formal
parameters](#Actual-parameters-and-formal-parameters)

[Format strings, `printf`](#index-Format-strings_002c-printf)

[16.2.2.1 `printf`](#printf)

[Formatted input conversion
specifiers](#index-Formatted-input-conversion-specifiers)

[16.2.8.1 `sscanf`](#sscanf)

[Formatted input conversion
specifiers](#index-Formatted-input-conversion-specifiers-1)

[16.2.8.2 Formatted input conversion
specifiers](#Formatted-input-conversion-specifiers)

[Formatted output conversion
specifiers](#index-Formatted-output-conversion-specifiers)

[16.2.2.2 Formatted output conversion
specifiers](#Formatted-output-conversion-specifiers)

[Formatted output conversion specifiers,
modifiers](#index-Formatted-output-conversion-specifiers_002c-modifiers)

[16.2.2.2 Formatted output conversion
specifiers](#Formatted-output-conversion-specifiers)

[Formatted output conversion specifiers,
modifiers](#index-Formatted-output-conversion-specifiers_002c-modifiers-1)

[16.2.2.2 Formatted output conversion
specifiers](#Formatted-output-conversion-specifiers)

[Formatted output conversion specifiers, table
of](#index-Formatted-output-conversion-specifiers_002c-table-of)

[16.2.2.2 Formatted output conversion
specifiers](#Formatted-output-conversion-specifiers)

[Formatted string input](#index-Formatted-string-input)

[16.2.8 Formatted string input](#Formatted-string-input)

[Formatted string input functions,
deprecated](#index-Formatted-string-input-functions_002c-deprecated)

[16.2.9 Deprecated formatted string input
functions](#Deprecated-formatted-string-input-functions)

[Formatted string output](#index-Formatted-string-output)

[16.2.2 Formatted string output](#Formatted-string-output)

[Formatted string output functions,
deprecated](#index-Formatted-string-output-functions_002c-deprecated)

[16.2.5 Deprecated formatted string output
functions](#Deprecated-formatted-string-output-functions)

[Formatting code, style
guidelines](#index-Formatting-code_002c-style-guidelines)

[22.1 Formatting code](#Formatting-code)

[Free Documentation License](#index-Free-Documentation-License)

[Preface](#Preface)

[Free software](#index-Free-software)

[Preface](#Preface)

[Freedom of style in C language](#index-Freedom-of-style-in-C-language)

[1.1 The advantages of C](#Advantages-of-C)

[`fsync`, example of](#index-fsync_002c-example-of)

[16.5.5 Writing files at a low level](#Writing-files-at-a-low-level)

[Full buffering](#index-Full-buffering)

[16.1.5 Stream buffering](#Stream-buffering)

[Function](#index-Function)

[2.1 Basic ideas about C](#Basic-ideas)

[Function declarations](#index-Function-declarations)

[4.4 Function prototyping](#Function-prototyping)

[Function names](#index-Function-names)

[4.1 Function names](#Function-names)

[Function names, characters available
for](#index-Function-names_002c-characters-available-for)

[4.1 Function names](#Function-names)

[Function names, style guidelines
for](#index-Function-names_002c-style-guidelines-for)

[22.3 Variable and function names](#Variable-and-function-names)

[Function prototypes](#index-Function-prototypes)

[4.4 Function prototyping](#Function-prototyping)

[Function prototypes, parameters
in](#index-Function-prototypes_002c-parameters-in)

[8.1 Parameters in function
prototypes](#Parameters-in-function-prototypes)

[Function prototypes, reasons for
using](#index-Function-prototypes_002c-reasons-for-using)

[4.4 Function prototyping](#Function-prototyping)

[Function values](#index-Function-values)

[4.3 Functions with values](#Functions-with-values)

[Function, as building block](#index-Function_002c-as-building-block)

[3. The form of a C program](#The-form-of-a-C-program)

[Function, example](#index-Function_002c-example)

[4.2 Function examples](#Function-examples)

[Function, `main`](#index-Function_002c-main)

[3. The form of a C program](#The-form-of-a-C-program)

[Functions](#index-Functions)

[4. Functions](#Functions)

[Functions, as buildings](#index-Functions_002c-as-buildings)

[6. Scope](#Scope)

[Functions, common library](#index-Functions_002c-common-library)

[13.3 Common library functions](#Common-library-functions)

[Functions, declaring](#index-Functions_002c-declaring)

[4.4 Function prototyping](#Function-prototyping)

[Functions, macro](#index-Functions_002c-macro)

[12.2.1 Macro functions](#Macro-functions)

[Functions, macro, caveats](#index-Functions_002c-macro_002c-caveats)

[12.2.1 Macro functions](#Macro-functions)

[Functions, macro, example](#index-Functions_002c-macro_002c-example)

[12.2.1 Macro functions](#Macro-functions)

[Functions, macro, example](#index-Functions_002c-macro_002c-example-1)

[12.3 Extended macro example](#Extended-macro-example)

[Functions, mathematical](#index-Functions_002c-mathematical)

[13.4 Mathematical functions](#Mathematical-functions)

[Functions, names of](#index-Functions_002c-names-of)

[4.1 Function names](#Function-names)

[Functions, prototyping](#index-Functions_002c-prototyping)

[4.4 Function prototyping](#Function-prototyping)

[Functions, return values](#index-Functions_002c-return-values)

[4.3 Functions with values](#Functions-with-values)

[Functions, returning values
from](#index-Functions_002c-returning-values-from)

[4.3 Functions with values](#Functions-with-values)

[Functions, string library](#index-Functions_002c-string-library)

[15.4 String library functions](#String-library-functions)

[Functions, variadic](#index-Functions_002c-variadic)

[8.4 Variadic functions](#Variadic-functions)

[Functions, with values](#index-Functions_002c-with-values)

[4.3 Functions with values](#Functions-with-values)

------------------------------------------------------------------------

[G]{#Concept-index-1_cp_letter-G}

[GCC](#index-GCC)

[2.2 The compiler](#The-compiler)

[GDB, introduction to](#index-GDB_002c-introduction-to)

[23.5 Introduction to GDB](#Introduction-to-GDB)

[general-purpose programming](#index-general_002dpurpose-programming)

[1.1 The advantages of C](#Advantages-of-C)

[`getline`, example of](#index-getline_002c-example-of)

[16.2.6.1 `getline`](#getline)

[Global scope](#index-Global-scope)

[6. Scope](#Scope)

[Global variables](#index-Global-variables)

[6.1 Global Variables](#Global-variables)

[Global variables and recursion](#index-Global-variables-and-recursion)

[23.3.6 Global variables and recursion](#Global-variables-and-recursion)

[Global variables, style guidelines
for](#index-Global-variables_002c-style-guidelines-for)

[22.5 Global variables and style](#Global-variables-and-style)

[GNU C Compiler](#index-GNU-C-Compiler)

[2.2 The compiler](#The-compiler)

[GNU C Library](#index-GNU-C-Library)

[16. Input and output](#Input-and-output)

[GNU Chess](#index-GNU-Chess)

[14.3 Multidimensional arrays](#Multidimensional-arrays)

[GNU Compiler Collection](#index-GNU-Compiler-Collection)

[2.2 The compiler](#The-compiler)

[GNU FDL](#index-GNU-FDL)

[Preface](#Preface)

[GNU Free Documentation License](#index-GNU-Free-Documentation-License)

[Preface](#Preface)

[GNU long options](#index-GNU-long-options)

[17.2 Processing command-line
options](#Processing-command_002dline-options)

[GNU long options](#index-GNU-long-options-1)

[24. Example programs](#Example-programs)

[GNU Project](#index-GNU-Project)

[Preface](#Preface)

[GNU shell](#index-GNU-shell)

[2. Using a compiler](#Using-a-compiler)

[GNU shell](#index-GNU-shell-1)

[2.1 Basic ideas about C](#Basic-ideas)

[GNU style guidelines](#index-GNU-style-guidelines)

[3.3 Example 1](#Example-comment)

[GNU system, stability of](#index-GNU-system_002c-stability-of)

[2.4 Errors](#Errors)

[GNU/Linux](#index-GNU_002fLinux)

[Preface](#Preface)

[goal](#index-goal)

[17.5.3 make in action](#make-in-action)

[goal, makefile, default](#index-goal_002c-makefile_002c-default)

[17.5.3 make in action](#make-in-action)

------------------------------------------------------------------------

[H]{#Concept-index-1_cp_letter-H}

[Header file](#index-Header-file)

[2.3 File names](#File-names)

[Header files](#index-Header-files)

[13.1 Header files](#Header-files)

[Header files, for libraries](#index-Header-files_002c-for-libraries)

[17.6 Building a library](#Building-a-library)

[Hidden assignments](#index-Hidden-assignments)

[18.1.1 Hidden assignments](#Hidden-assignments)

[Hidden operators](#index-Hidden-operators)

[18.1 Hidden operators and values](#Hidden-operators-and-values)

[Hidden operators and arrays](#index-Hidden-operators-and-arrays)

[18.1.3 Arrays and hidden operators](#Arrays-and-hidden-operators)

[Hidden operators, style guidelines
for](#index-Hidden-operators_002c-style-guidelines-for)

[22.6 Hidden operators and style](#Hidden-operators-and-style)

[High level, the](#index-High-level_002c-the)

[1. Introduction](#Introduction)

[High-level file operations](#index-High_002dlevel-file-operations)

[16. Input and output](#Input-and-output)

[High-level file routines](#index-High_002dlevel-file-routines)

[16.1 High-level file routines](#High_002dlevel-file-routines)

[High-level language, C language
as](#index-High_002dlevel-language_002c-C-language-as)

[1. Introduction](#Introduction)

------------------------------------------------------------------------

[I]{#Concept-index-1_cp_letter-I}

[`if` statements, nested](#index-if-statements_002c-nested)

[10.3 Nested `if` statements](#Nested-if-statements)

[Implicit makefile rules,
introduction](#index-Implicit-makefile-rules_002c-introduction)

[17.5.5 Letting make deduce commands](#Letting-make-deduce-commands)

[Inclusive OR](#index-Inclusive-OR)

[7.9.1 Inclusive OR](#Inclusive-OR)

[Inclusive OR assignment](#index-Inclusive-OR-assignment)

[18.3.1 Bitwise operators](#Bitwise-operators)

[Inclusive OR, bitwise, truth
table](#index-Inclusive-OR_002c-bitwise_002c-truth-table)

[18.3.3.3 Bitwise inclusive OR](#Bitwise-inclusive-OR)

[Info reader](#index-Info-reader)

[Preface](#Preface)

[Initialization and pointers](#index-Initialization-and-pointers)

[9.3 Pointers and initialization](#Pointers-and-initialization)

[Initialization, style guidelines
for](#index-Initialization_002c-style-guidelines-for)

[22.4 Declarations and initialization](#Declarations-and-initialization)

[Initializing arrays](#index-Initializing-arrays)

[14.2 Arrays and `for` loops](#Arrays-and-for-loops)

[Initializing arrays](#index-Initializing-arrays-1)

[14.4 Arrays and nested loops](#Arrays-and-nested-loops)

[Initializing arrays](#index-Initializing-arrays-2)

[14.5 Initializing arrays](#Initializing-arrays)

[Initializing data structurse](#index-Initializing-data-structurse)

[20.4.4.2 Initializing your data
structure](#Initializing-your-data-structure)

[Initializing multidimensional
arrays](#index-Initializing-multidimensional-arrays)

[14.4 Arrays and nested loops](#Arrays-and-nested-loops)

[Initializing strings](#index-Initializing-strings)

[15.2 Initializing strings](#Initializing-strings)

[Initializing structures](#index-Initializing-structures)

[20.1.6 Initializing structures](#Initializing-structures)

[Initializing variables](#index-Initializing-variables)

[5.3 Initialization](#Initialization)

[Input](#index-Input)

[16. Input and output](#Input-and-output)

[Input and output](#index-Input-and-output)

[16. Input and output](#Input-and-output)

[Input conversion specifiers,
formatted](#index-Input-conversion-specifiers_002c-formatted)

[16.2.8.1 `sscanf`](#sscanf)

[Input conversion specifiers,
formatted](#index-Input-conversion-specifiers_002c-formatted-1)

[16.2.8.2 Formatted input conversion
specifiers](#Formatted-input-conversion-specifiers)

[Input functions, string, deprecated
formatted](#index-Input-functions_002c-string_002c-deprecated-formatted)

[16.2.9 Deprecated formatted string input
functions](#Deprecated-formatted-string-input-functions)

[Input, block](#index-Input_002c-block)

[16.1.3 Block input and output](#Block-input-and-output)

[Input, disk](#index-Input_002c-disk)

[24. Example programs](#Example-programs)

[Input, single-character](#index-Input_002c-single_002dcharacter)

[16.3 Single-character input and
output](#Single_002dcharacter-input-and-output)

[Input, string](#index-Input_002c-string)

[16.2 String output and input](#String-output-and-input)

[Input, string](#index-Input_002c-string-1)

[16.2.6 String input](#String-input)

[Input, string](#index-Input_002c-string-2)

[16.2.7 Deprecated string input
functions](#Deprecated-string-input-functions)

[Input, string formatted](#index-Input_002c-string-formatted)

[16.2.8 Formatted string input](#Formatted-string-input)

[Integer variables](#index-Integer-variables)

[5.1 Integer variables](#Integer-variables)

[Integer variables, sizes of](#index-Integer-variables_002c-sizes-of)

[5.1 Integer variables](#Integer-variables)

[International Obfuscated C Code
Contest](#index-International-Obfuscated-C-Code-Contest)

[8.1 Parameters in function
prototypes](#Parameters-in-function-prototypes)

------------------------------------------------------------------------

[J]{#Concept-index-1_cp_letter-J}

[Jargon](#index-Jargon)

[Preface](#Preface)

------------------------------------------------------------------------

[K]{#Concept-index-1_cp_letter-K}

[Kinds of library](#index-Kinds-of-library)

[13.2 Kinds of library](#Kinds-of-library)

------------------------------------------------------------------------

[L]{#Concept-index-1_cp_letter-L}

[Levels of detail](#index-Levels-of-detail)

[1. Introduction](#Introduction)

[Libraries](#index-Libraries)

[13. Libraries](#Libraries)

[Libraries, compiling](#index-Libraries_002c-compiling)

[17.6 Building a library](#Building-a-library)

[Libraries, linking to your
code](#index-Libraries_002c-linking-to-your-code)

[13. Libraries](#Libraries)

[Libraries, shared](#index-Libraries_002c-shared)

[13.2 Kinds of library](#Kinds-of-library)

[Libraries, shared,
creating](#index-Libraries_002c-shared_002c-creating)

[17.6 Building a library](#Building-a-library)

[Libraries, static](#index-Libraries_002c-static)

[13.2 Kinds of library](#Kinds-of-library)

[Libraries, static,
creating](#index-Libraries_002c-static_002c-creating)

[17.6 Building a library](#Building-a-library)

[Library file](#index-Library-file)

[2.3 File names](#File-names)

[Library functions, common](#index-Library-functions_002c-common)

[13.3 Common library functions](#Common-library-functions)

[Library functions, string](#index-Library-functions_002c-string)

[15.4 String library functions](#String-library-functions)

[Library header files](#index-Library-header-files)

[17.6 Building a library](#Building-a-library)

[Library, kinds of](#index-Library_002c-kinds-of)

[13.2 Kinds of library](#Kinds-of-library)

[Line buffering](#index-Line-buffering)

[16.1.5 Stream buffering](#Stream-buffering)

[Linked lists](#index-Linked-lists)

[20.4.3.1 Linked lists.](#Linked-lists)

[Linked lists](#index-Linked-lists-1)

[24. Example programs](#Example-programs)

[Linker](#index-Linker)

[2.2 The compiler](#The-compiler)

[Linking libraries to your code](#index-Linking-libraries-to-your-code)

[13. Libraries](#Libraries)

[Links](#index-Links)

[20.4.2 Dynamic data structures, Pointers and Dynamic
Memory](#Dynamic-data-structures)

[Links](#index-Links-1)

[20.4.3 Lists and trees](#Lists-and-trees)

[Lists](#index-Lists)

[20.4.3 Lists and trees](#Lists-and-trees)

[Lists, linked](#index-Lists_002c-linked)

[20.4.3.1 Linked lists.](#Linked-lists)

[Lists, linked](#index-Lists_002c-linked-1)

[24. Example programs](#Example-programs)

[Local scope](#index-Local-scope)

[6. Scope](#Scope)

[Local variables](#index-Local-variables)

[6.2 Local Variables](#Local-variables)

[Local variables, scope of](#index-Local-variables_002c-scope-of)

[6.2 Local Variables](#Local-variables)

[Local variables, visibility
of](#index-Local-variables_002c-visibility-of)

[6.2 Local Variables](#Local-variables)

[Logical operators](#index-Logical-operators)

[7.9 Logical operators](#Logical-operators)

[Long options, GNU](#index-Long-options_002c-GNU)

[17.2 Processing command-line
options](#Processing-command_002dline-options)

[Long options, GNU](#index-Long-options_002c-GNU-1)

[24. Example programs](#Example-programs)

[Loops](#index-Loops)

[11. Loops](#Loops)

[Loops, nested](#index-Loops_002c-nested)

[11.6 Nested loops](#Nested-loops)

[Loops, nested](#index-Loops_002c-nested-1)

[14.4 Arrays and nested loops](#Arrays-and-nested-loops)

[Loops, speeding](#index-Loops_002c-speeding)

[11.5 Terminating and speeding loops](#Terminating-and-speeding-loops)

[Loops, terminating](#index-Loops_002c-terminating)

[11.5 Terminating and speeding loops](#Terminating-and-speeding-loops)

[Loops, terminating with
`break`](#index-Loops_002c-terminating-with-break)

[11.5.1 Terminating loops with `break`](#Terminating-loops-with-break)

[Loops, terminating with
`return`](#index-Loops_002c-terminating-with-return)

[11.5.2 Terminating loops with `return`](#Terminating-loops-with-return)

[Low level, closing files at](#index-Low-level_002c-closing-files-at)

[16.5.3 Closing files at a low level](#Closing-files-at-a-low-level)

[Low level, deleting files at](#index-Low-level_002c-deleting-files-at)

[16.5.7 Deleting files at a low level](#Deleting-files-at-a-low-level)

[Low level, finding file positions
at](#index-Low-level_002c-finding-file-positions-at)

[16.5.6 Finding file positions at a low
level](#Finding-file-positions-at-a-low-level)

[Low level, opening files at](#index-Low-level_002c-opening-files-at)

[16.5.2 Opening files at a low level](#Opening-files-at-a-low-level)

[Low level, reading files at](#index-Low-level_002c-reading-files-at)

[16.5.4 Reading files at a low level](#Reading-files-at-a-low-level)

[Low level, renaming files at](#index-Low-level_002c-renaming-files-at)

[16.5.8 Renaming files at a low level](#Renaming-files-at-a-low-level)

[Low level, the](#index-Low-level_002c-the)

[1. Introduction](#Introduction)

[Low level, writing files at](#index-Low-level_002c-writing-files-at)

[16.5.5 Writing files at a low level](#Writing-files-at-a-low-level)

[Low-level file functions](#index-Low_002dlevel-file-functions)

[16.5 Low-level file routines](#Low_002dlevel-file-routines)

[Low-level file operations](#index-Low_002dlevel-file-operations)

[16. Input and output](#Input-and-output)

[Lvalues](#index-Lvalues)

[7.1 The assignment operator](#The-assignment-operator)

------------------------------------------------------------------------

[M]{#Concept-index-1_cp_letter-M}

[Macro functions](#index-Macro-functions)

[12.2.1 Macro functions](#Macro-functions)

[Macro functions, caveats](#index-Macro-functions_002c-caveats)

[12.2.1 Macro functions](#Macro-functions)

[Macro functions, example](#index-Macro-functions_002c-example)

[12.2.1 Macro functions](#Macro-functions)

[Macro functions, example](#index-Macro-functions_002c-example-1)

[12.3 Extended macro example](#Extended-macro-example)

[Macros](#index-Macros)

[12.2 Macros](#Macros)

[main [function]{.roman}](#index-main-function)

[3. The form of a C program](#The-form-of-a-C-program)

[makefile](#index-makefile)

[17.5 Writing a makefile](#Writing-a-makefile)

[Makefile commands, introduction
to](#index-Makefile-commands_002c-introduction-to)

[17.5.1 What a Rule Looks Like](#Rule-Introduction)

[Makefile prerequisites, introduction
to](#index-Makefile-prerequisites_002c-introduction-to)

[17.5.1 What a Rule Looks Like](#Rule-Introduction)

[Makefile rule parts](#index-Makefile-rule-parts)

[17.5.1 What a Rule Looks Like](#Rule-Introduction)

[Makefile rule, introduction
to](#index-Makefile-rule_002c-introduction-to)

[17.5.1 What a Rule Looks Like](#Rule-Introduction)

[Makefile rules, implicit,
introduction](#index-Makefile-rules_002c-implicit_002c-introduction)

[17.5.5 Letting make deduce commands](#Letting-make-deduce-commands)

[Makefile rules, tab characters
in](#index-Makefile-rules_002c-tab-characters-in)

[17.5.1 What a Rule Looks Like](#Rule-Introduction)

[Makefile targets, introduction
to](#index-Makefile-targets_002c-introduction-to)

[17.5.1 What a Rule Looks Like](#Rule-Introduction)

[makefile, processing](#index-makefile_002c-processing)

[17.5.3 make in action](#make-in-action)

[Makefile, simple](#index-Makefile_002c-simple)

[17.5.2 A simple makefile](#A-simple-makefile)

[Makefiles, writing](#index-Makefiles_002c-writing)

[17.5 Writing a makefile](#Writing-a-makefile)

[Masks, bit](#index-Masks_002c-bit)

[18.3.3 Truth tables and bit masks](#Truth-tables-and-bit-masks)

[Masks, bit](#index-Masks_002c-bit-1)

[18.3.3.5 Masks](#Masks)

[Math functions, example of](#index-Math-functions_002c-example-of)

[13.4 Mathematical functions](#Mathematical-functions)

[Mathematical errors](#index-Mathematical-errors)

[23.4 Mathematical errors](#Mathematical-errors)

[Mathematical function](#index-Mathematical-function)

[13.4 Mathematical functions](#Mathematical-functions)

[Mathematical operators](#index-Mathematical-operators)

[7. Expressions and operators](#Expressions-and-operators)

[Member operator of structures](#index-Member-operator-of-structures)

[20.1.2 Using structures](#Using-structures)

[Member operator of structures](#index-Member-operator-of-structures-1)

[20.1.2 Using structures](#Using-structures)

[Members of structures](#index-Members-of-structures)

[20.1 `struct`](#struct)

[Memory addresses](#index-Memory-addresses)

[9. Pointers](#Pointers)

[Memory allocation](#index-Memory-allocation)

[20.2 Memory allocation](#Memory-allocation)

[Memory, random-access](#index-Memory_002c-random_002daccess)

[16.1.4 File position](#File-position)

[Multidimensional arrays](#index-Multidimensional-arrays)

[11.6 Nested loops](#Nested-loops)

[Multidimensional arrays](#index-Multidimensional-arrays-1)

[14.3 Multidimensional arrays](#Multidimensional-arrays)

[Multidimensional arrays,
initializing](#index-Multidimensional-arrays_002c-initializing)

[14.4 Arrays and nested loops](#Arrays-and-nested-loops)

[Multiple files, compiling](#index-Multiple-files_002c-compiling)

[17.4 Compiling multiple files](#Compiling-multiple-files)

[Multiplication operator](#index-Multiplication-operator)

[7. Expressions and operators](#Expressions-and-operators)

------------------------------------------------------------------------

[N]{#Concept-index-1_cp_letter-N}

[Nested `for` loops](#index-Nested-for-loops)

[14.4 Arrays and nested loops](#Arrays-and-nested-loops)

[Nested `if` statements](#index-Nested-if-statements)

[10.3 Nested `if` statements](#Nested-if-statements)

[Nested loops](#index-Nested-loops)

[11.6 Nested loops](#Nested-loops)

[Nested loops](#index-Nested-loops-1)

[14.4 Arrays and nested loops](#Arrays-and-nested-loops)

[Nested loops and arrays](#index-Nested-loops-and-arrays)

[14.4 Arrays and nested loops](#Arrays-and-nested-loops)

[Nested structures](#index-Nested-structures)

[20.1.4 Nested structures](#Nested-structures)

[Newline character, quoting in
makefile](#index-Newline-character_002c-quoting-in-makefile)

[17.5.2 A simple makefile](#A-simple-makefile)

[No buffering](#index-No-buffering)

[16.1.5 Stream buffering](#Stream-buffering)

[Node, root](#index-Node_002c-root)

[20.4.2 Dynamic data structures, Pointers and Dynamic
Memory](#Dynamic-data-structures)

[Nodes](#index-Nodes)

[20.4.2 Dynamic data structures, Pointers and Dynamic
Memory](#Dynamic-data-structures)

[Nodes](#index-Nodes-1)

[20.4.3 Lists and trees](#Lists-and-trees)

[Nodes, root](#index-Nodes_002c-root)

[20.4.4.2 Initializing your data
structure](#Initializing-your-data-structure)

[NOT, bitwise, truth table](#index-NOT_002c-bitwise_002c-truth-table)

[18.3.3.1 Bitwise NOT](#Bitwise-NOT)

[Null pointers](#index-Null-pointers)

[20.4.4.2 Initializing your data
structure](#Initializing-your-data-structure)

[Numbers, floating point](#index-Numbers_002c-floating-point)

[5.1.2 Floating point variables](#Floating-point-variables)

------------------------------------------------------------------------

[O]{#Concept-index-1_cp_letter-O}

[Obfuscated C Code Contest,
International](#index-Obfuscated-C-Code-Contest_002c-International)

[8.1 Parameters in function
prototypes](#Parameters-in-function-prototypes)

[Object code](#index-Object-code)

[2.2 The compiler](#The-compiler)

[Object code file](#index-Object-code-file)

[2.2 The compiler](#The-compiler)

[Object file](#index-Object-file)

[2.2 The compiler](#The-compiler)

[Object file](#index-Object-file-1)

[2.3 File names](#File-names)

[One-based arrays](#index-One_002dbased-arrays)

[14. Arrays](#Arrays)

[`open`, example of](#index-open_002c-example-of)

[16.5.3 Closing files at a low level](#Closing-files-at-a-low-level)

[Opening files](#index-Opening-files)

[16. Input and output](#Input-and-output)

[Opening files](#index-Opening-files-1)

[16.1.1 Opening a file](#Opening-a-file)

[Opening files at a low level](#index-Opening-files-at-a-low-level)

[16.5.2 Opening files at a low level](#Opening-files-at-a-low-level)

[Operating system](#index-Operating-system)

[2. Using a compiler](#Using-a-compiler)

[Operating systems, 64-bit](#index-Operating-systems_002c-64_002dbit)

[5.1 Integer variables](#Integer-variables)

[Operations, order of](#index-Operations_002c-order-of)

[7.4 Parentheses and Priority](#Parentheses-and-Priority)

[Operator precedence](#index-Operator-precedence)

[7.4 Parentheses and Priority](#Parentheses-and-Priority)

[Operator, addition](#index-Operator_002c-addition)

[7. Expressions and operators](#Expressions-and-operators)

[Operator, assignment](#index-Operator_002c-assignment)

[7.1 The assignment operator](#The-assignment-operator)

[Operator, cast](#index-Operator_002c-cast)

[7. Expressions and operators](#Expressions-and-operators)

[Operator, cast](#index-Operator_002c-cast-1)

[9.2 Pointer types](#Pointer-types)

[Operator, comma](#index-Operator_002c-comma)

[18.2 The comma operator](#The-comma-operator)

[Operator, multiplication](#index-Operator_002c-multiplication)

[7. Expressions and operators](#Expressions-and-operators)

[Operator, subtraction](#index-Operator_002c-subtraction)

[7. Expressions and operators](#Expressions-and-operators)

[Operators](#index-Operators)

[7. Expressions and operators](#Expressions-and-operators)

[Operators, arithmetic](#index-Operators_002c-arithmetic)

[7.2 Expressions and values](#Expressions-and-values)

[Operators, arithmetic](#index-Operators_002c-arithmetic-1)

[7.7 More Special Assignments](#More-Special-Assignments)

[Operators, bitwise](#index-Operators_002c-bitwise)

[18.3.1 Bitwise operators](#Bitwise-operators)

[Operators, comparison](#index-Operators_002c-comparison)

[7. Expressions and operators](#Expressions-and-operators)

[Operators, comparison](#index-Operators_002c-comparison-1)

[7.8 Comparisons and logic](#Comparisons-and-logic)

[Operators, comparison](#index-Operators_002c-comparison-2)

[7.9 Logical operators](#Logical-operators)

[Operators, hidden](#index-Operators_002c-hidden)

[18.1 Hidden operators and values](#Hidden-operators-and-values)

[Operators, hidden, and
arrays](#index-Operators_002c-hidden_002c-and-arrays)

[18.1.3 Arrays and hidden operators](#Arrays-and-hidden-operators)

[Operators, logical](#index-Operators_002c-logical)

[7.9 Logical operators](#Logical-operators)

[Operators, mathematical](#index-Operators_002c-mathematical)

[7. Expressions and operators](#Expressions-and-operators)

[Operators, precedence of](#index-Operators_002c-precedence-of)

[C. Precedence of operators](#Precedence-of-operators)

[Operators, shift](#index-Operators_002c-shift)

[18.3.2 Shift operations](#Shift-operations)

[Operators, special
assignment](#index-Operators_002c-special-assignment)

[7.6 Special Assignment Operators `++` and
`--`](#Special-Assignment-Operators-_002b_002b-_002d_002d)

[Operators, special
assignment](#index-Operators_002c-special-assignment-1)

[7.7 More Special Assignments](#More-Special-Assignments)

[Optimizing loops](#index-Optimizing-loops)

[11.5.3 Speeding loops with `continue`](#Speeding-loops-with-continue)

[Options, command-line](#index-Options_002c-command_002dline)

[17.2 Processing command-line
options](#Processing-command_002dline-options)

[OR, bitwise exclusive, truth
table](#index-OR_002c-bitwise-exclusive_002c-truth-table)

[18.3.3.4 Bitwise exclusive OR
(XOR/EOR)](#Bitwise-exclusive-OR-_0028XOR_002fEOR_0029)

[OR, bitwise inclusive, truth
table](#index-OR_002c-bitwise-inclusive_002c-truth-table)

[18.3.3.3 Bitwise inclusive OR](#Bitwise-inclusive-OR)

[OR, inclusive](#index-OR_002c-inclusive)

[7.9.1 Inclusive OR](#Inclusive-OR)

[Order of operation, unary
operators](#index-Order-of-operation_002c-unary-operators)

[7.5 Unary Operator Precedence](#Unary-Operator-Precedence)

[Order of operations](#index-Order-of-operations)

[7.4 Parentheses and Priority](#Parentheses-and-Priority)

[Output](#index-Output)

[16. Input and output](#Input-and-output)

[Output conversion specifiers,
formatted](#index-Output-conversion-specifiers_002c-formatted)

[16.2.2.2 Formatted output conversion
specifiers](#Formatted-output-conversion-specifiers)

[Output conversion specifiers, formatted,
modifiers](#index-Output-conversion-specifiers_002c-formatted_002c-modifiers)

[16.2.2.2 Formatted output conversion
specifiers](#Formatted-output-conversion-specifiers)

[Output conversion specifiers, formatted,
modifiers](#index-Output-conversion-specifiers_002c-formatted_002c-modifiers-1)

[16.2.2.2 Formatted output conversion
specifiers](#Formatted-output-conversion-specifiers)

[Output conversion specifiers, formatted, table
of](#index-Output-conversion-specifiers_002c-formatted_002c-table-of)

[16.2.2.2 Formatted output conversion
specifiers](#Formatted-output-conversion-specifiers)

[Output, block](#index-Output_002c-block)

[16.1.3 Block input and output](#Block-input-and-output)

[Output, disk](#index-Output_002c-disk)

[24. Example programs](#Example-programs)

[Output, formatted string](#index-Output_002c-formatted-string)

[16.2.2 Formatted string output](#Formatted-string-output)

[Output, single-character](#index-Output_002c-single_002dcharacter)

[16.3 Single-character input and
output](#Single_002dcharacter-input-and-output)

[Output, string](#index-Output_002c-string)

[16.2 String output and input](#String-output-and-input)

[Output, uncoordinated](#index-Output_002c-uncoordinated)

[23.3.5 Uncoordinated output](#Uncoordinated-output)

[Output, unformatted string](#index-Output_002c-unformatted-string)

[16.2.1 Unformatted string output](#Unformatted-string-output)

------------------------------------------------------------------------

[P]{#Concept-index-1_cp_letter-P}

[Parameters](#index-Parameters)

[4. Functions](#Functions)

[Parameters](#index-Parameters-1)

[6.3 Communication via parameters](#Communication-via-parameters)

[Parameters](#index-Parameters-2)

[8. Parameters](#Parameters)

[Parameters in function
prototypes](#index-Parameters-in-function-prototypes)

[8.1 Parameters in function
prototypes](#Parameters-in-function-prototypes)

[Parameters, actual](#index-Parameters_002c-actual)

[8.3 Actual parameters and formal
parameters](#Actual-parameters-and-formal-parameters)

[Parameters, arrays as](#index-Parameters_002c-arrays-as)

[14.6 Arrays as Parameters](#Arrays-as-Parameters)

[Parameters, communication
via](#index-Parameters_002c-communication-via)

[6.3 Communication via parameters](#Communication-via-parameters)

[Parameters, declaring](#index-Parameters_002c-declaring)

[8. Parameters](#Parameters)

[Parameters, formal](#index-Parameters_002c-formal)

[8.3 Actual parameters and formal
parameters](#Actual-parameters-and-formal-parameters)

[Parameters, passing arrays
as](#index-Parameters_002c-passing-arrays-as)

[14.6 Arrays as Parameters](#Arrays-as-Parameters)

[Parameters, value](#index-Parameters_002c-value)

[8. Parameters](#Parameters)

[Parameters, value](#index-Parameters_002c-value-1)

[8.2 Value Parameters](#Value-parameters)

[Parameters, value, example
of](#index-Parameters_002c-value_002c-example-of)

[8. Parameters](#Parameters)

[Parameters, variable](#index-Parameters_002c-variable)

[8. Parameters](#Parameters)

[Parameters, variable](#index-Parameters_002c-variable-1)

[9.4 Variable parameters](#Variable-parameters)

[Parameters, variable](#index-Parameters_002c-variable-2)

[9.4.2 Another variable parameter
example](#Another-variable-parameter-example)

[Parentheses](#index-Parentheses)

[7.4 Parentheses and Priority](#Parentheses-and-Priority)

[Parse error](#index-Parse-error)

[23.1.1 parse error at..., parse error
before...](#parse-error-at_002e_002e_002e)

[Parts of makefile rules](#index-Parts-of-makefile-rules)

[17.5.1 What a Rule Looks Like](#Rule-Introduction)

[Passes, compiler](#index-Passes_002c-compiler)

[2.2 The compiler](#The-compiler)

[Passing actual parameters as
pointers](#index-Passing-actual-parameters-as-pointers)

[9.4.1 Passing pointers correctly](#Passing-pointers-correctly)

[Passing arrays as parameters](#index-Passing-arrays-as-parameters)

[14.6 Arrays as Parameters](#Arrays-as-Parameters)

[Passing by reference](#index-Passing-by-reference)

[9.4 Variable parameters](#Variable-parameters)

[Passing by reference, origin of
term](#index-Passing-by-reference_002c-origin-of-term)

[9. Pointers](#Pointers)

[Passing information to program](#index-Passing-information-to-program)

[17.1 `argc` and `argv`](#argc-and-argv)

[Passing information with
parameters](#index-Passing-information-with-parameters)

[8. Parameters](#Parameters)

[Passing parameters](#index-Passing-parameters)

[8. Parameters](#Parameters)

[Passing parameters by
reference](#index-Passing-parameters-by-reference)

[8. Parameters](#Parameters)

[Passing parameters by value](#index-Passing-parameters-by-value)

[8. Parameters](#Parameters)

[Passing parameters by value](#index-Passing-parameters-by-value-1)

[8.2 Value Parameters](#Value-parameters)

[Peripherals](#index-Peripherals)

[16. Input and output](#Input-and-output)

[Peripherals and C language](#index-Peripherals-and-C-language)

[1.1 The advantages of C](#Advantages-of-C)

[Peripherals as devices](#index-Peripherals-as-devices)

[16. Input and output](#Input-and-output)

[Pipe symbol ('\|')](#index-Pipe-symbol-_0028_007c_0029)

[16.4 Programming with pipes](#Programming-with-pipes)

[Pipes, programming with](#index-Pipes_002c-programming-with)

[16.4 Programming with pipes](#Programming-with-pipes)

[Pointer expressions, pronunciation
of](#index-Pointer-expressions_002c-pronunciation-of)

[9.2 Pointer types](#Pointer-types)

[Pointer types](#index-Pointer-types)

[9.2 Pointer types](#Pointer-types)

[Pointer types, casting](#index-Pointer-types_002c-casting)

[9.2 Pointer types](#Pointer-types)

[Pointers](#index-Pointers)

[9. Pointers](#Pointers)

[Pointers and arrays, equivalence
of](#index-Pointers-and-arrays_002c-equivalence-of)

[14.6 Arrays as Parameters](#Arrays-as-Parameters)

[Pointers and initialization](#index-Pointers-and-initialization)

[9.3 Pointers and initialization](#Pointers-and-initialization)

[Pointers to structures](#index-Pointers-to-structures)

[20.1.5 Pointers to structures](#Pointers-to-structures)

[Pointers, types of](#index-Pointers_002c-types-of)

[9.2 Pointer types](#Pointer-types)

[POSIX standard, command-line
conventions](#index-POSIX-standard_002c-command_002dline-conventions)

[17.2 Processing command-line
options](#Processing-command_002dline-options)

[Postfix `++` operator](#index-Postfix-_002b_002b-operator)

[18.1.2 Postfix and prefix `++` and
`--`](#Postfix-and-prefix-_002b_002b-and-_002d_002d)

[Postfix `--` operator](#index-Postfix-_002d_002d-operator)

[18.1.2 Postfix and prefix `++` and
`--`](#Postfix-and-prefix-_002b_002b-and-_002d_002d)

[Postfix and prefix `++`,
confused](#index-Postfix-and-prefix-_002b_002b_002c-confused)

[23.3.2 Confusing `foo++` and
`++foo`](#Confusing-foo_002b_002b-and-_002b_002bfoo)

[Postfix operators](#index-Postfix-operators)

[18.1.2 Postfix and prefix `++` and
`--`](#Postfix-and-prefix-_002b_002b-and-_002d_002d)

[Power of C language](#index-Power-of-C-language)

[Preface](#Preface)

[Power of C language](#index-Power-of-C-language-1)

[1.1 The advantages of C](#Advantages-of-C)

[Precedence of operators](#index-Precedence-of-operators)

[C. Precedence of operators](#Precedence-of-operators)

[Precedence, operator](#index-Precedence_002c-operator)

[7.4 Parentheses and Priority](#Parentheses-and-Priority)

[Prefix `++` operator](#index-Prefix-_002b_002b-operator)

[18.1.2 Postfix and prefix `++` and
`--`](#Postfix-and-prefix-_002b_002b-and-_002d_002d)

[Prefix `--` operator](#index-Prefix-_002d_002d-operator)

[18.1.2 Postfix and prefix `++` and
`--`](#Postfix-and-prefix-_002b_002b-and-_002d_002d)

[Prefix operators](#index-Prefix-operators)

[18.1.2 Postfix and prefix `++` and
`--`](#Postfix-and-prefix-_002b_002b-and-_002d_002d)

[Preprocessor](#index-Preprocessor)

[12. Preprocessor directives](#Preprocessor-directives)

[Preprocessor directives](#index-Preprocessor-directives)

[12. Preprocessor directives](#Preprocessor-directives)

[Preprocessor directives](#index-Preprocessor-directives-1)

[12.1 A few directives](#A-few-directives)

[Preprocessor directives](#index-Preprocessor-directives-2)

[12.2 Macros](#Macros)

[Preprocessor directives,
example](#index-Preprocessor-directives_002c-example)

[12.2 Macros](#Macros)

[Prerequisite, combining rules
by](#index-Prerequisite_002c-combining-rules-by)

[17.5.6 Combining rules by
prerequisite](#Combining-rules-by-prerequisite)

[`printf` format strings](#index-printf-format-strings)

[16.2.2.1 `printf`](#printf)

[`printf`, example of](#index-printf_002c-example-of)

[16.2.2.2 Formatted output conversion
specifiers](#Formatted-output-conversion-specifiers)

[processing a makefile](#index-processing-a-makefile)

[17.5.3 make in action](#make-in-action)

[programming,
general-purpose](#index-programming_002c-general_002dpurpose)

[1.1 The advantages of C](#Advantages-of-C)

[Programs, annotating](#index-Programs_002c-annotating)

[3.2 Comments](#Comments)

[Pronunciation of pointer
expressions](#index-Pronunciation-of-pointer-expressions)

[9.2 Pointer types](#Pointer-types)

[Prototypes, function, parameters
in](#index-Prototypes_002c-function_002c-parameters-in)

[8.1 Parameters in function
prototypes](#Parameters-in-function-prototypes)

[Prototyping function](#index-Prototyping-function)

[4.4 Function prototyping](#Function-prototyping)

[Pseudo-code](#index-Pseudo_002dcode)

[2.2 The compiler](#The-compiler)

[Pushback](#index-Pushback)

[16.3.5 `ungetc()`](#ungetc)

[Pushing back characters](#index-Pushing-back-characters)

[16.3.5 `ungetc()`](#ungetc)

------------------------------------------------------------------------

[Q]{#Concept-index-1_cp_letter-Q}

[Quoting newline character in
makefile](#index-Quoting-newline-character-in-makefile)

[17.5.2 A simple makefile](#A-simple-makefile)

------------------------------------------------------------------------

[R]{#Concept-index-1_cp_letter-R}

[RAM](#index-RAM)

[16.1.4 File position](#File-position)

[Random-access files](#index-Random_002daccess-files)

[16.1.4 File position](#File-position)

[Random-access memory](#index-Random_002daccess-memory)

[16.1.4 File position](#File-position)

[`read`, example of](#index-read_002c-example-of)

[16.5.5 Writing files at a low level](#Writing-files-at-a-low-level)

[Reading arrays from streams](#index-Reading-arrays-from-streams)

[16.1.3 Block input and output](#Block-input-and-output)

[Reading arrays from streams](#index-Reading-arrays-from-streams-1)

[16.1.3 Block input and output](#Block-input-and-output)

[Reading files at a low level](#index-Reading-files-at-a-low-level)

[16.5.4 Reading files at a low level](#Reading-files-at-a-low-level)

[recompilation](#index-recompilation)

[17.5 Writing a makefile](#Writing-a-makefile)

[Recursion](#index-Recursion)

[21. Recursion](#Recursion)

[Recursion and global variables](#index-Recursion-and-global-variables)

[23.3.6 Global variables and recursion](#Global-variables-and-recursion)

[Recursion, controlled](#index-Recursion_002c-controlled)

[21.2 Controlled recursion](#Controlled-recursion)

[Recursion, controlled, with data
structures](#index-Recursion_002c-controlled_002c-with-data-structures)

[21.3 Controlled recursion with data
structures](#Controlled-recursion-with-data-structures)

[Recursive data structures](#index-Recursive-data-structures)

[21.3 Controlled recursion with data
structures](#Controlled-recursion-with-data-structures)

[Reference, passing by](#index-Reference_002c-passing-by)

[9.4 Variable parameters](#Variable-parameters)

[Reference, passing by, origin of
term](#index-Reference_002c-passing-by_002c-origin-of-term)

[9. Pointers](#Pointers)

[Reference, passing parameters
by](#index-Reference_002c-passing-parameters-by)

[8. Parameters](#Parameters)

[relinking](#index-relinking)

[17.5.3 make in action](#make-in-action)

[Renaming files at a low level](#index-Renaming-files-at-a-low-level)

[16.5.8 Renaming files at a low level](#Renaming-files-at-a-low-level)

[Reserved words in C](#index-Reserved-words-in-C)

[B. Reserved words in C](#Reserved-words-in-C)

[Return codes](#index-Return-codes)

[4.5 The `exit` function](#The-exit-function)

[`return`, terminating loops
with](#index-return_002c-terminating-loops-with)

[11.5.2 Terminating loops with `return`](#Terminating-loops-with-return)

[Returning values from
functions](#index-Returning-values-from-functions)

[4.3 Functions with values](#Functions-with-values)

[Root node](#index-Root-node)

[20.4.2 Dynamic data structures, Pointers and Dynamic
Memory](#Dynamic-data-structures)

[Root nodes](#index-Root-nodes)

[20.4.4.2 Initializing your data
structure](#Initializing-your-data-structure)

[Run-time errors](#index-Run_002dtime-errors)

[2.4 Errors](#Errors)

[Running an executable file](#index-Running-an-executable-file)

[2.1 Basic ideas about C](#Basic-ideas)

------------------------------------------------------------------------

[S]{#Concept-index-1_cp_letter-S}

[`scanf`, string overflows
with](#index-scanf_002c-string-overflows-with)

[16.2.9.2 String overflows with scanf](#String-overflows-with-scanf)

[Scope of local variables](#index-Scope-of-local-variables)

[6.2 Local Variables](#Local-variables)

[Scope of variables](#index-Scope-of-variables)

[6. Scope](#Scope)

[Scope, example of](#index-Scope_002c-example-of)

[6.4 Scope example](#Scope-example)

[Scope, global](#index-Scope_002c-global)

[6. Scope](#Scope)

[Scope, local](#index-Scope_002c-local)

[6. Scope](#Scope)

[Setting up data structures](#index-Setting-up-data-structures)

[20.4.4 Setting up a data structure](#Setting-up-a-data-structure)

[Shakespeare](#index-Shakespeare)

[7.9.1 Inclusive OR](#Inclusive-OR)

[Shared libraries](#index-Shared-libraries)

[13.2 Kinds of library](#Kinds-of-library)

[Shared libraries, creating](#index-Shared-libraries_002c-creating)

[17.6 Building a library](#Building-a-library)

[shell command](#index-shell-command)

[17.5.2 A simple makefile](#A-simple-makefile)

[Shell, command](#index-Shell_002c-command)

[2. Using a compiler](#Using-a-compiler)

[Shell, command](#index-Shell_002c-command-1)

[2.1 Basic ideas about C](#Basic-ideas)

[Shell, GNU](#index-Shell_002c-GNU)

[2. Using a compiler](#Using-a-compiler)

[Shell, GNU](#index-Shell_002c-GNU-1)

[2.1 Basic ideas about C](#Basic-ideas)

[Shift operators](#index-Shift-operators)

[18.3.2 Shift operations](#Shift-operations)

[Simple makefile](#index-Simple-makefile)

[17.5.2 A simple makefile](#A-simple-makefile)

[Simplest C program](#index-Simplest-C-program)

[3. The form of a C program](#The-form-of-a-C-program)

[Simplifying makefiles with
variables](#index-Simplifying-makefiles-with-variables)

[17.5.4 Variables simplify makefiles](#Variables-simplify-makefiles)

[Single-character input](#index-Single_002dcharacter-input)

[16.3 Single-character input and
output](#Single_002dcharacter-input-and-output)

[Single-character output](#index-Single_002dcharacter-output)

[16.3 Single-character input and
output](#Single_002dcharacter-input-and-output)

[Software, free](#index-Software_002c-free)

[Preface](#Preface)

[Source code](#index-Source-code)

[2.2 The compiler](#The-compiler)

[Source code file](#index-Source-code-file)

[2.3 File names](#File-names)

[Special assignment operators](#index-Special-assignment-operators)

[7.6 Special Assignment Operators `++` and
`--`](#Special-Assignment-Operators-_002b_002b-_002d_002d)

[Special assignment operators](#index-Special-assignment-operators-1)

[7.7 More Special Assignments](#More-Special-Assignments)

[Special assignment operators,
example](#index-Special-assignment-operators_002c-example)

[7.7 More Special Assignments](#More-Special-Assignments)

[Special characters](#index-Special-characters)

[D. Special characters](#Special-characters)

[Speeding loops](#index-Speeding-loops)

[11.5 Terminating and speeding loops](#Terminating-and-speeding-loops)

[Speeding loops](#index-Speeding-loops-1)

[11.5.3 Speeding loops with `continue`](#Speeding-loops-with-continue)

[`sscanf` example](#index-sscanf-example)

[16.2.8.1 `sscanf`](#sscanf)

[`sscanf`, common errors with](#index-sscanf_002c-common-errors-with)

[16.2.8.1 `sscanf`](#sscanf)

[Stability of GNU system](#index-Stability-of-GNU-system)

[2.4 Errors](#Errors)

[Stack](#index-Stack)

[21.1 The stack](#The-stack)

[Stack](#index-Stack-1)

[21.1.1 The stack in detail](#The-stack-in-detail)

[Stack, variable](#index-Stack_002c-variable)

[6.4 Scope example](#Scope-example)

[Standard input](#index-Standard-input)

[16.1.5 Stream buffering](#Stream-buffering)

[Standard output](#index-Standard-output)

[16.1.5 Stream buffering](#Stream-buffering)

[Statements](#index-Statements)

[4. Functions](#Functions)

[Static libraries](#index-Static-libraries)

[13.2 Kinds of library](#Kinds-of-library)

[Static libraries, creating](#index-Static-libraries_002c-creating)

[17.6 Building a library](#Building-a-library)

[Static variables](#index-Static-variables)

[5.5.2 Static variables](#Static-variables)

[Storage classes](#index-Storage-classes)

[5.5 Storage classes](#Storage-classes)

[Storage classes](#index-Storage-classes-1)

[5.5.3 Other storage classes](#Other-storage-classes)

[Storage, false assumptions
about](#index-Storage_002c-false-assumptions-about)

[23.3.3 Unwarranted assumptions about
storage](#Unwarranted-assumptions-about-storage)

[Stream buffering](#index-Stream-buffering)

[16.1.5 Stream buffering](#Stream-buffering)

[Streams](#index-Streams)

[16. Input and output](#Input-and-output)

[Streams](#index-Streams-1)

[16. Input and output](#Input-and-output)

[Streams, reading arrays from](#index-Streams_002c-reading-arrays-from)

[16.1.3 Block input and output](#Block-input-and-output)

[Streams, reading arrays
from](#index-Streams_002c-reading-arrays-from-1)

[16.1.3 Block input and output](#Block-input-and-output)

[Streams, writing arrays to](#index-Streams_002c-writing-arrays-to)

[16.1.3 Block input and output](#Block-input-and-output)

[Streams, writing arrays to](#index-Streams_002c-writing-arrays-to-1)

[16.1.3 Block input and output](#Block-input-and-output)

[String arrays](#index-String-arrays)

[15.3 String arrays](#String-arrays)

[String constants](#index-String-constants)

[15.2 Initializing strings](#Initializing-strings)

[String input](#index-String-input)

[16.2 String output and input](#String-output-and-input)

[String input](#index-String-input-1)

[16.2.6 String input](#String-input)

[String input](#index-String-input-2)

[16.2.7 Deprecated string input
functions](#Deprecated-string-input-functions)

[String input functions,
deprecated](#index-String-input-functions_002c-deprecated)

[16.2.7 Deprecated string input
functions](#Deprecated-string-input-functions)

[String input functions, deprecated
formatted](#index-String-input-functions_002c-deprecated-formatted)

[16.2.9 Deprecated formatted string input
functions](#Deprecated-formatted-string-input-functions)

[String input, formatted](#index-String-input_002c-formatted)

[16.2.8 Formatted string input](#Formatted-string-input)

[String library functions](#index-String-library-functions)

[15.4 String library functions](#String-library-functions)

[String output](#index-String-output)

[16.2 String output and input](#String-output-and-input)

[String output functions, formatted,
deprecated](#index-String-output-functions_002c-formatted_002c-deprecated)

[16.2.5 Deprecated formatted string output
functions](#Deprecated-formatted-string-output-functions)

[String output, formatted](#index-String-output_002c-formatted)

[16.2.2 Formatted string output](#Formatted-string-output)

[String output, unformatted](#index-String-output_002c-unformatted)

[16.2.1 Unformatted string output](#Unformatted-string-output)

[String overflows with `scanf`](#index-String-overflows-with-scanf)

[16.2.9.2 String overflows with scanf](#String-overflows-with-scanf)

[String values](#index-String-values)

[15. Strings](#Strings)

[Strings](#index-Strings)

[15. Strings](#Strings)

[Strings, confused with
characters](#index-Strings_002c-confused-with-characters)

[15.1 Conventions and declarations](#Conventions-and-declarations)

[Strings, initializing](#index-Strings_002c-initializing)

[15.2 Initializing strings](#Initializing-strings)

[Structures](#index-Structures)

[20.1 `struct`](#struct)

[Structures, `->` operator](#index-Structures_002c-_002d_003e-operator)

[20.1.2 Using structures](#Using-structures)

[Structures, `.` dot
operator](#index-Structures_002c-_002e-dot-operator)

[20.1.2 Using structures](#Using-structures)

[Structures, arrays of](#index-Structures_002c-arrays-of)

[20.1.3 Arrays of structures](#Arrays-of-structures)

[Structures, as distinguished from data
structures](#index-Structures_002c-as-distinguished-from-data-structures)

[20. Data structures](#Data-structures)

[Structures, data](#index-Structures_002c-data)

[20. Data structures](#Data-structures)

[Structures, declaring](#index-Structures_002c-declaring)

[20.1.1 Structure declarations](#Structure-declarations)

[Structures, declaring with
`typedef`](#index-Structures_002c-declaring-with-typedef)

[20.1.1.1 Structure declarations using
typedef](#Structure-declarations-using-typedef)

[Structures, initializing](#index-Structures_002c-initializing)

[20.1.6 Initializing structures](#Initializing-structures)

[Structures, member operator
of](#index-Structures_002c-member-operator-of)

[20.1.2 Using structures](#Using-structures)

[Structures, member operator
of](#index-Structures_002c-member-operator-of-1)

[20.1.2 Using structures](#Using-structures)

[Structures, members of](#index-Structures_002c-members-of)

[20.1 `struct`](#struct)

[Structures, nested](#index-Structures_002c-nested)

[20.1.4 Nested structures](#Nested-structures)

[Structures, pointers to](#index-Structures_002c-pointers-to)

[20.1.5 Pointers to structures](#Pointers-to-structures)

[Structures, using](#index-Structures_002c-using)

[20.1.2 Using structures](#Using-structures)

[Style](#index-Style)

[3.1 A word about style](#A-word-about-style)

[Style](#index-Style-1)

[3.3 Example 1](#Example-comment)

[Style](#index-Style-2)

[18.1.4 A warning about style](#A-warning-about-style)

[Style](#index-Style-3)

[22. Style](#Style)

[Style guidelines](#index-Style-guidelines)

[22. Style](#Style)

[Style guidelines for comments](#index-Style-guidelines-for-comments)

[22.2 Comments and style](#Comments-and-style)

[Style guidelines for
declarations](#index-Style-guidelines-for-declarations)

[22.4 Declarations and initialization](#Declarations-and-initialization)

[Style guidelines for formatting
code](#index-Style-guidelines-for-formatting-code)

[22.1 Formatting code](#Formatting-code)

[Style guidelines for function
names](#index-Style-guidelines-for-function-names)

[22.3 Variable and function names](#Variable-and-function-names)

[Style guidelines for global
variables](#index-Style-guidelines-for-global-variables)

[22.5 Global variables and style](#Global-variables-and-style)

[Style guidelines for hidden
operators](#index-Style-guidelines-for-hidden-operators)

[22.6 Hidden operators and style](#Hidden-operators-and-style)

[Style guidelines for
initialization](#index-Style-guidelines-for-initialization)

[22.4 Declarations and initialization](#Declarations-and-initialization)

[Style guidelines for variable
names](#index-Style-guidelines-for-variable-names)

[22.3 Variable and function names](#Variable-and-function-names)

[Style, freedom of in C
language](#index-Style_002c-freedom-of-in-C-language)

[1.1 The advantages of C](#Advantages-of-C)

[Style, warning about](#index-Style_002c-warning-about)

[18.1.4 A warning about style](#A-warning-about-style)

[Subtraction operator](#index-Subtraction-operator)

[7. Expressions and operators](#Expressions-and-operators)

[Suucinctness of C language](#index-Suucinctness-of-C-language)

[1.1 The advantages of C](#Advantages-of-C)

[`switch` statement, breaking out
of](#index-switch-statement_002c-breaking-out-of)

[10.5 The `switch` statement](#The-switch-statement)

[`switch` statement, breaking out
of](#index-switch-statement_002c-breaking-out-of-1)

[10.6 Example Listing](#Example-15)

[Syntax errors](#index-Syntax-errors)

[2.4 Errors](#Errors)

------------------------------------------------------------------------

[T]{#Concept-index-1_cp_letter-T}

[Tab characters in makefile
rules](#index-Tab-characters-in-makefile-rules)

[17.5.1 What a Rule Looks Like](#Rule-Introduction)

[Tables, truth](#index-Tables_002c-truth)

[18.3.3 Truth tables and bit masks](#Truth-tables-and-bit-masks)

[Template string,](#index-Template-string_002c-)

[16.2.8.1 `sscanf`](#sscanf)

[Terminating loops](#index-Terminating-loops)

[11.5 Terminating and speeding loops](#Terminating-and-speeding-loops)

[Terminating loops with `break`](#index-Terminating-loops-with-break)

[11.5.1 Terminating loops with `break`](#Terminating-loops-with-break)

[Terminating loops with `return`](#index-Terminating-loops-with-return)

[11.5.2 Terminating loops with `return`](#Terminating-loops-with-return)

[Texinfo](#index-Texinfo)

[Preface](#Preface)

[To be or not to be](#index-To-be-or-not-to-be)

[7.9.1 Inclusive OR](#Inclusive-OR)

[Too few parameters error](#index-Too-few-parameters-error)

[23.2.2 too few parameters..., too many
parameters...](#too-few-parameters_002e_002e_002e)

[Trees](#index-Trees)

[20.4.3 Lists and trees](#Lists-and-trees)

[Trees, binary](#index-Trees_002c-binary)

[20.4.3.2 Binary trees](#Binary-trees)

[True Boolean value](#index-True-Boolean-value)

[7.8 Comparisons and logic](#Comparisons-and-logic)

[Truth tables](#index-Truth-tables)

[18.3.3 Truth tables and bit masks](#Truth-tables-and-bit-masks)

[Type errors](#index-Type-errors)

[2.4 Errors](#Errors)

[Type errors](#index-Type-errors-1)

[2.4.2 Type errors](#Type-errors)

[`typedef`, declaring structures
with](#index-typedef_002c-declaring-structures-with)

[20.1.1.1 Structure declarations using
typedef](#Structure-declarations-using-typedef)

[Types, casting](#index-Types_002c-casting)

[5.4 The cast operator](#The-cast-operator)

[Types, casting, example](#index-Types_002c-casting_002c-example)

[5.4.1 Cast operator demo](#Cast-operator-demo)

[Types, defining your own](#index-Types_002c-defining-your-own)

[2.4.2 Type errors](#Type-errors)

[Types, pointer](#index-Types_002c-pointer)

[9.2 Pointer types](#Pointer-types)

[Types, variable](#index-Types_002c-variable)

[2.4.2 Type errors](#Type-errors)

[Typographical errors](#index-Typographical-errors)

[2.4.1 Typographical errors](#Typographical-errors)

------------------------------------------------------------------------

[U]{#Concept-index-1_cp_letter-U}

[Unary operators](#index-Unary-operators)

[7.5 Unary Operator Precedence](#Unary-Operator-Precedence)

[Unary operators, order of
operation](#index-Unary-operators_002c-order-of-operation)

[7.5 Unary Operator Precedence](#Unary-Operator-Precedence)

[Uncoordinated output](#index-Uncoordinated-output)

[23.3.5 Uncoordinated output](#Uncoordinated-output)

[Undefined reference error](#index-Undefined-reference-error)

[23.1.2 undefined reference
to...](#undefined-reference-to_002e_002e_002e)

[Unforgiving nature of C
language](#index-Unforgiving-nature-of-C-language)

[Preface](#Preface)

[Unformatted string output](#index-Unformatted-string-output)

[16.2.1 Unformatted string output](#Unformatted-string-output)

[Unions](#index-Unions)

[20.3 `union`](#union)

[Unions and flag variables](#index-Unions-and-flag-variables)

[20.3.2 Using unions](#Using-unions)

[Unions, declaring](#index-Unions_002c-declaring)

[20.3.1 Declaration of unions](#Declaration-of-unions)

[Unions, using](#index-Unions_002c-using)

[20.3.2 Using unions](#Using-unions)

[Unreading characters](#index-Unreading-characters)

[16.3.5 `ungetc()`](#ungetc)

[Using structures](#index-Using-structures)

[20.1.2 Using structures](#Using-structures)

[Using unions](#index-Using-unions)

[20.3.2 Using unions](#Using-unions)

[Usual file name errors](#index-Usual-file-name-errors)

[16.5.1 Usual file name errors](#Usual-file-name-errors)

------------------------------------------------------------------------

[V]{#Concept-index-1_cp_letter-V}

[Value parameters](#index-Value-parameters)

[8. Parameters](#Parameters)

[Value parameters](#index-Value-parameters-1)

[8.2 Value Parameters](#Value-parameters)

[Value parameters, example of](#index-Value-parameters_002c-example-of)

[8. Parameters](#Parameters)

[Value, passing parameters by](#index-Value_002c-passing-parameters-by)

[8. Parameters](#Parameters)

[Values, Boolean](#index-Values_002c-Boolean)

[7. Expressions and operators](#Expressions-and-operators)

[Values, Boolean](#index-Values_002c-Boolean-1)

[7.8 Comparisons and logic](#Comparisons-and-logic)

[Variable](#index-Variable)

[2.1 Basic ideas about C](#Basic-ideas)

[Variable declaration](#index-Variable-declaration)

[2.4.2 Type errors](#Type-errors)

[Variable declarations](#index-Variable-declarations)

[4. Functions](#Functions)

[Variable names, characters available
for](#index-Variable-names_002c-characters-available-for)

[5. Variables and declarations](#Variables-and-declarations)

[Variable names, style guidelines
for](#index-Variable-names_002c-style-guidelines-for)

[22.3 Variable and function names](#Variable-and-function-names)

[Variable parameters](#index-Variable-parameters)

[8. Parameters](#Parameters)

[Variable parameters](#index-Variable-parameters-1)

[9.4 Variable parameters](#Variable-parameters)

[Variable parameters](#index-Variable-parameters-2)

[9.4.2 Another variable parameter
example](#Another-variable-parameter-example)

[Variable stack](#index-Variable-stack)

[6.4 Scope example](#Scope-example)

[Variable types](#index-Variable-types)

[2.4.2 Type errors](#Type-errors)

[Variables](#index-Variables)

[5. Variables and declarations](#Variables-and-declarations)

[Variables, declaring](#index-Variables_002c-declaring)

[5. Variables and declarations](#Variables-and-declarations)

[Variables, declaring](#index-Variables_002c-declaring-1)

[5.2 Declarations](#Declarations)

[Variables, environment](#index-Variables_002c-environment)

[17.3 Environment variables](#Environment-variables)

[Variables, external](#index-Variables_002c-external)

[5.5.1 External variables](#External-variables)

[Variables, floating point](#index-Variables_002c-floating-point)

[5.1.2 Floating point variables](#Floating-point-variables)

[Variables, global](#index-Variables_002c-global)

[6.1 Global Variables](#Global-variables)

[Variables, global, and
recursion](#index-Variables_002c-global_002c-and-recursion)

[23.3.6 Global variables and recursion](#Global-variables-and-recursion)

[Variables, initializing](#index-Variables_002c-initializing)

[5.3 Initialization](#Initialization)

[Variables, integer](#index-Variables_002c-integer)

[5.1 Integer variables](#Integer-variables)

[Variables, integer, sizes
of](#index-Variables_002c-integer_002c-sizes-of)

[5.1 Integer variables](#Integer-variables)

[Variables, local](#index-Variables_002c-local)

[6.2 Local Variables](#Local-variables)

[Variables, local, scope of](#index-Variables_002c-local_002c-scope-of)

[6.2 Local Variables](#Local-variables)

[Variables, local, visibility
of](#index-Variables_002c-local_002c-visibility-of)

[6.2 Local Variables](#Local-variables)

[Variables, scope of](#index-Variables_002c-scope-of)

[6. Scope](#Scope)

[Variables, simplifying makefiles
with](#index-Variables_002c-simplifying-makefiles-with)

[17.5.4 Variables simplify makefiles](#Variables-simplify-makefiles)

[Variables, static](#index-Variables_002c-static)

[5.5.2 Static variables](#Static-variables)

[Variables, visibility of](#index-Variables_002c-visibility-of)

[6. Scope](#Scope)

[Variadic functions](#index-Variadic-functions)

[8.4 Variadic functions](#Variadic-functions)

[Visibility of local variables](#index-Visibility-of-local-variables)

[6.2 Local Variables](#Local-variables)

[Visibility of variables](#index-Visibility-of-variables)

[6. Scope](#Scope)

------------------------------------------------------------------------

[W]{#Concept-index-1_cp_letter-W}

[Walls, as metaphors for curly
brackets](#index-Walls_002c-as-metaphors-for-curly-brackets)

[6. Scope](#Scope)

[`while` and `do`, difference
between](#index-while-and-do_002c-difference-between)

[11.2 `do`...`while`](#do_002e_002e_002ewhile)

[`write`, example of](#index-write_002c-example-of)

[16.5.5 Writing files at a low level](#Writing-files-at-a-low-level)

[Writing arrays to streams](#index-Writing-arrays-to-streams)

[16.1.3 Block input and output](#Block-input-and-output)

[Writing arrays to streams](#index-Writing-arrays-to-streams-1)

[16.1.3 Block input and output](#Block-input-and-output)

[Writing files at a low level](#index-Writing-files-at-a-low-level)

[16.5.5 Writing files at a low level](#Writing-files-at-a-low-level)

[Writing makefiles](#index-Writing-makefiles)

[17.5 Writing a makefile](#Writing-a-makefile)

------------------------------------------------------------------------

[X]{#Concept-index-1_cp_letter-X}

[XOR, truth table](#index-XOR_002c-truth-table)

[18.3.3.4 Bitwise exclusive OR
(XOR/EOR)](#Bitwise-exclusive-OR-_0028XOR_002fEOR_0029)

------------------------------------------------------------------------

[Z]{#Concept-index-1_cp_letter-Z}

[Zero-based arrays in C](#index-Zero_002dbased-arrays-in-C)

[14. Arrays](#Arrays)

------------------------------------------------------------------------

  ------------ ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  Jump to:     [**.**](#Concept-index-1_cp_symbol-1){.summary-letter}   [**\\**](#Concept-index-1_cp_symbol-2){.summary-letter}  \
               [**A**](#Concept-index-1_cp_letter-A){.summary-letter}   [**B**](#Concept-index-1_cp_letter-B){.summary-letter}   [**C**](#Concept-index-1_cp_letter-C){.summary-letter}   [**D**](#Concept-index-1_cp_letter-D){.summary-letter}   [**E**](#Concept-index-1_cp_letter-E){.summary-letter}   [**F**](#Concept-index-1_cp_letter-F){.summary-letter}   [**G**](#Concept-index-1_cp_letter-G){.summary-letter}   [**H**](#Concept-index-1_cp_letter-H){.summary-letter}   [**I**](#Concept-index-1_cp_letter-I){.summary-letter}   [**J**](#Concept-index-1_cp_letter-J){.summary-letter}   [**K**](#Concept-index-1_cp_letter-K){.summary-letter}   [**L**](#Concept-index-1_cp_letter-L){.summary-letter}   [**M**](#Concept-index-1_cp_letter-M){.summary-letter}   [**N**](#Concept-index-1_cp_letter-N){.summary-letter}   [**O**](#Concept-index-1_cp_letter-O){.summary-letter}   [**P**](#Concept-index-1_cp_letter-P){.summary-letter}   [**Q**](#Concept-index-1_cp_letter-Q){.summary-letter}   [**R**](#Concept-index-1_cp_letter-R){.summary-letter}   [**S**](#Concept-index-1_cp_letter-S){.summary-letter}   [**T**](#Concept-index-1_cp_letter-T){.summary-letter}   [**U**](#Concept-index-1_cp_letter-U){.summary-letter}   [**V**](#Concept-index-1_cp_letter-V){.summary-letter}   [**W**](#Concept-index-1_cp_letter-W){.summary-letter}   [**X**](#Concept-index-1_cp_letter-X){.summary-letter}   [**Z**](#Concept-index-1_cp_letter-Z){.summary-letter}  

  ------------ ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

------------------------------------------------------------------------

[]{#Bits-and-pieces}

  -------------------------------------------------------------- -------------------------------------------------------------------------- --- ---------------------------------------------------------------------------- ----------------------------- ------------ --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Concept-index "Previous section in reading order")\]   \[[\>](#Allocating-memory-for-strings "Next section in reading order")\]       \[[\<\<](#Concept-index "Beginning of this chapter or previous chapter")\]   \[[Up](#Top "Up section")\]   \[ \>\> \]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  -------------------------------------------------------------- -------------------------------------------------------------------------- --- ---------------------------------------------------------------------------- ----------------------------- ------------ --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Bits-and-pieces-1}

Bits and pieces {#bits-and-pieces .unnumbered}
===============

This section is for random chunks of text that are too good to drop from
the book, but were out-of-place where they were.

  ------------------------------------------------------------------------------- ---- --
  [G.1 Allocating memory for strings](#Allocating-memory-for-strings)                  
  [G.2 Characters](#Characters)                                                        
  [G.3 Assigning variables to one another](#Assigning-variables-to-one-another)        
  [G.4 Function pointers](#Function-pointers)                                          
  ------------------------------------------------------------------------------- ---- --

------------------------------------------------------------------------

[]{#Allocating-memory-for-strings}

  ---------------------------------------------------------------- ------------------------------------------------------- --- ------------------------------------------------------------------------------ ----------------------------------------- ------------ --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Bits-and-pieces "Previous section in reading order")\]   \[[\>](#Characters "Next section in reading order")\]       \[[\<\<](#Bits-and-pieces "Beginning of this chapter or previous chapter")\]   \[[Up](#Bits-and-pieces "Up section")\]   \[ \>\> \]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ---------------------------------------------------------------- ------------------------------------------------------- --- ------------------------------------------------------------------------------ ----------------------------------------- ------------ --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Allocating-memory-for-strings-1}

G.1 Allocating memory for strings {#g.1-allocating-memory-for-strings .section}
---------------------------------

Neither of the methods above is any good if a program is going to be
fetching a lot of strings from a user. It just isn't practical to define
lots of static strings and expect the user to type into the right size
boxes! The next step in string handling is therefore to allocate memory
for strings personally: in other words to be able to say how much
storage is needed for a string while a program is running. C has special
memory allocation functions which can do this, not only for strings but
for any kind of object. Suppose then that a program is going to get ten
strings from the user. Here is one way in which it could be done:

1.  Define one large, static string (or array) for getting one string at
    a time. Call this a string buffer, or waiting place.
2.  Define an array of ten pointers to characters, so that the strings
    can be recalled easily.
3.  Find out how long the string in the string buffer is.
4.  Allocate memory for the string.
5.  Copy the string from the buffer to the new storage and place a
    pointer to it in the array of pointers for reference.
6.  Release the memory when it is finished with.

------------------------------------------------------------------------

[]{#Characters}

  ------------------------------------------------------------------------------ ------------------------------------------------------------------------------- --- ------------------------------------------------------------------------------ ----------------------------------------- ------------ --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Allocating-memory-for-strings "Previous section in reading order")\]   \[[\>](#Assigning-variables-to-one-another "Next section in reading order")\]       \[[\<\<](#Bits-and-pieces "Beginning of this chapter or previous chapter")\]   \[[Up](#Bits-and-pieces "Up section")\]   \[ \>\> \]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ------------------------------------------------------------------------------ ------------------------------------------------------------------------------- --- ------------------------------------------------------------------------------ ----------------------------------------- ------------ --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Characters-1}

G.2 Characters {#g.2-characters .section}
--------------

In C, single characters are written enclosed by single quotes. This is
in contrast to strings of characters, which use double quotes
('\"...\"').

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | int ch;                           |
|                                   | ch = 'a';                         |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

would give `ch` the value of the character 'a'. The same effect can also
be achieved by writing:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | char ch = 'a';                    |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

It is also possible to have the type:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | unsigned char                     |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

This admits ASCII values from 0 to 255, rather than -128 to 127.

  ------------------------------------------------------------------------------- ---- --
  [G.3 Assigning variables to one another](#Assigning-variables-to-one-another)        
  [G.4 Function pointers](#Function-pointers)                                          
  ------------------------------------------------------------------------------- ---- --

------------------------------------------------------------------------

[]{#Assigning-variables-to-one-another}

  ----------------------------------------------------------- -------------------------------------------------------------- --- ------------------------------------------------------------------------------ ----------------------------------------- ------------ --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Characters "Previous section in reading order")\]   \[[\>](#Function-pointers "Next section in reading order")\]       \[[\<\<](#Bits-and-pieces "Beginning of this chapter or previous chapter")\]   \[[Up](#Bits-and-pieces "Up section")\]   \[ \>\> \]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ----------------------------------------------------------- -------------------------------------------------------------- --- ------------------------------------------------------------------------------ ----------------------------------------- ------------ --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Assigning-variables-to-one-another-1}

G.3 Assigning variables to one another {#g.3-assigning-variables-to-one-another .section}
--------------------------------------

Not only can you assign numbers to variables, you can assign other
variables to variables:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | var1 = 23;                        |
|                                   | var2 = var1;                      |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

The variable or value on either side of the '=' symbol must usually be
of the same type. However, integers and characters will interconvert
because characters are stored by their ASCII codes (which are integers!)
Thus the following will work:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | int i;                            |
|                                   | char ch = 'A';                    |
|                                   |                                   |
|                                   | i = ch;                           |
|                                   |                                   |
|                                   | printf ("The ASCII code of %c is  |
|                                   | %d",ch,i);                        |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

The result of this would be:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | The ASCII code of A is 65         |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

------------------------------------------------------------------------

[]{#Function-pointers}

  ----------------------------------------------------------------------------------- ---------- --- ------------------------------------------------------------------------------ ----------------------------------------- ------------ --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[\<](#Assigning-variables-to-one-another "Previous section in reading order")\]   \[ \> \]       \[[\<\<](#Bits-and-pieces "Beginning of this chapter or previous chapter")\]   \[[Up](#Bits-and-pieces "Up section")\]   \[ \>\> \]                   \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ----------------------------------------------------------------------------------- ---------- --- ------------------------------------------------------------------------------ ----------------------------------------- ------------ --- --- --- --- ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

[]{#Function-pointers-1}

G.4 Function pointers {#g.4-function-pointers .section}
---------------------

You can create pointers to functions as well as to variables. Function
pointers can be tricky, however, and caution is advised in using them.

Function pointers allow you to pass functions as a parameters to another
function. This enables you to give the latter function a choice of
functions to call. That is, you can plug in a new function in place of
an old one simply by passing a different parameter. This technique is
sometimes called *indirection* or *vectoring*.

To pass a pointer for one function to a second function, simply use the
name of the first function, as long as there is no variable with the
same name. Do not include the first function's parentheses or parameters
when you pass its name.

For example, the following code passes a pointer for the function named
`fred_function` to the function `barbara_function`:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | void fred();                      |
|                                   | barbara (fred);                   |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

Notice that `fred` is declared with a regular function prototype before
`barbara` calls it. You must also declare `barbara`, of course:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | void barbara (void (*function_ptr |
|                                   | )() );                            |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

Notice the parentheses around `function_ptr` and the parentheses after
it. As far as `barbara` is concerned, any function passed to it is named
`(*function_ptr)()`, and this is how `fred` is called in the example
below:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | #include <stdio.h>                |
|                                   |                                   |
|                                   | void fred();                      |
|                                   | void barbara ( void (*function_pt |
|                                   | r)() );                           |
|                                   | int main();                       |
|                                   |                                   |
|                                   | int main()                        |
|                                   | {                                 |
|                                   |   barbara (fred);                 |
|                                   |   return 0;                       |
|                                   | }                                 |
|                                   |                                   |
|                                   | void fred()                       |
|                                   | {                                 |
|                                   |   printf("fred here!\n");         |
|                                   | }                                 |
|                                   |                                   |
|                                   | void barbara ( void (*function_pt |
|                                   | r)() )                            |
|                                   | {                                 |
|                                   |   /* Call fred */                 |
|                                   |   (*function_ptr)();              |
|                                   | }                                 |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

The output from this example is simply 'fred here!'.

Again, notice how `barbara` called `fred`. Given a pointer to a
function, the syntax for calling the function is as follows:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | variable = (*function_pointer)(pa |
|                                   | rameter_list);                    |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

For example, in the program below, the function `do_math` calls the
functions `add` and `subtract` with the following line:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | result = (*math_fn_ptr) (num1, nu |
|                                   | m2);                              |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

Here is the example program:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | #include <stdio.h>                |
|                                   |                                   |
|                                   | int add (int, int);               |
|                                   | int subtract (int, int);          |
|                                   | int do_math (int (*math_fn_ptr) ( |
|                                   | int, int), int, int);             |
|                                   | int main();                       |
|                                   |                                   |
|                                   | int main()                        |
|                                   | {                                 |
|                                   |   int result;                     |
|                                   |                                   |
|                                   |   result = do_math (add, 10, 5);  |
|                                   |   printf ("Addition = %d.\n", res |
|                                   | ult);                             |
|                                   |                                   |
|                                   |   result = do_math (subtract, 40, |
|                                   |  5);                              |
|                                   |   printf ("Subtraction = %d.\n\n" |
|                                   | , result);                        |
|                                   |                                   |
|                                   |   return 0;                       |
|                                   | }                                 |
|                                   |                                   |
|                                   | int add (int num1, int num2)      |
|                                   | {                                 |
|                                   |   return (num1 + num2);           |
|                                   | }                                 |
|                                   |                                   |
|                                   |                                   |
|                                   | int subtract (int num1, int num2) |
|                                   | {                                 |
|                                   |   return (num1 - num2);           |
|                                   | }                                 |
|                                   |                                   |
|                                   |                                   |
|                                   | int do_math (int (*math_fn_ptr) ( |
|                                   | int, int), int num1, int num2)    |
|                                   | {                                 |
|                                   |   int result;                     |
|                                   |                                   |
|                                   |   printf ("\ndo_math here.\n");   |
|                                   |                                   |
|                                   |   /* Call one of the math functio |
|                                   | ns passed to us:                  |
|                                   |      either add or subtract. */   |
|                                   |                                   |
|                                   |   result = (*math_fn_ptr) (num1,  |
|                                   | num2);                            |
|                                   |   return result;                  |
|                                   | }                                 |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

The output from this program reads:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | do_math here.                     |
|                                   | Addition = 15.                    |
|                                   |                                   |
|                                   | do_math here.                     |
|                                   | Subtraction = 35.                 |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

You can also initialize a function pointer by setting it to the name of
a function, then treating the function pointer as an ordinary function,
as in the next example:

+-----------------------------------+-----------------------------------+
|                                   | ``` {.smallexample}               |
|                                   | #include <stdio.h>                |
|                                   |                                   |
|                                   | int main();                       |
|                                   | void print_it();                  |
|                                   | void (*fn_ptr)();                 |
|                                   |                                   |
|                                   | int main()                        |
|                                   | {                                 |
|                                   |   void (*fn_ptr)() = print_it;    |
|                                   |                                   |
|                                   |   (*fn_ptr)();                    |
|                                   |                                   |
|                                   |   return 0;                       |
|                                   | }                                 |
|                                   |                                   |
|                                   | void print_it()                   |
|                                   | {                                 |
|                                   |   printf("We are here!  We are he |
|                                   | re!\n\n");                        |
|                                   | }                                 |
|                                   | ```                               |
+-----------------------------------+-----------------------------------+

Remember to initialize any function pointers you use this way! If you do
not, your program will probably crash, because the uninitialized
function pointer will contain garbage.

------------------------------------------------------------------------

[]{#SEC_Foot}

  ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

Footnotes
=========

### [(1)](#DOCF1){#FOOT1}

That is, unless you are competing in [The International Obfuscated C
Code Contest](http://www.ioccc.org/).

### [(2)](#DOCF2){#FOOT2}

This, by the way, is how the phrase "pass by reference" entered the
jargon. Like other pointers, a variable parameter "makes a reference" to
the address of a variable.

### [(3)](#DOCF3){#FOOT3}

The version of '`ctype.h`' in the '`/usr/include`' directory proper is
the one that comes with '`glibc`'; the one in '`/usr/include/linux`' is
a special version associated with the Linux kernel. You can specify the
one you want with a full pathname inside double quotes (for example,
`#include "/usr/include/linux/ctype.h"`), or you can use the '-I' option
of `gcc` to force GCC to search a set of directories in a specific
order. See section [Building a library](#Building-a-library), for more
information.)

### [(4)](#DOCF4){#FOOT4}

Since the file position is a long integer, the length of a file using
one of these functions cannot be any greater than the maximum value of a
32-bit long integer under GNU, plus one (since the file position is
zero-based) --- that is, such a file cannot be any more than
2,147,483,648 bytes, or about two gigabytes long. If you need to use
longer files, you can use low-level file routines, which allow for
longer files and file positions through such 64-bit functions as
`lseek64`.

### [(5)](#DOCF5){#FOOT5}

Strictly speaking, there are multiple levels of buffering on a GNU
system. Even after flushing characters to a file, data from the file may
remain in memory, unwritten to disk. On GNU systems, there is an
independently-running system program, or *daemon*, that periodically
commits relevant data still in memory to disk. Under GNU/Linux, this
daemon is called '`bdflush`'.

### [(6)](#DOCF6){#FOOT6}

To create library files containing multiple object files, simply include
the object files on the same command line. For example, to create a
static library with multiple object files, type a command such as
`ar rs liblprprint.a lpr_print.o lpr_print2.o lpr_print3.o`. Similarly,
to create a shared library, type
`gcc -shared -o liblprprint.so lpr_print.o lpr_print2.o lpr_print3.o`.

------------------------------------------------------------------------

[]{#SEC_Contents}

  ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

Table of Contents
=================

::: {.contents}
-   [Preface](#Preface){#toc-Preface-1}
-   [1. Introduction](#Introduction){#toc-Introduction-1}
    -   [1.1 The advantages of
        C](#Advantages-of-C){#toc-The-advantages-of-C}
    -   [1.2 Questions for Chapter
        1](#Questions-for-Chapter-1){#toc-Questions-for-Chapter-1-1}
-   [2. Using a compiler](#Using-a-compiler){#toc-Using-a-compiler-1}
    -   [2.1 Basic ideas about
        C](#Basic-ideas){#toc-Basic-ideas-about-C}
    -   [2.2 The compiler](#The-compiler){#toc-The-compiler-1}
    -   [2.3 File names](#File-names){#toc-File-names-1}
    -   [2.4 Errors](#Errors){#toc-Errors-1}
        -   [2.4.1 Typographical
            errors](#Typographical-errors){#toc-Typographical-errors-1}
        -   [2.4.2 Type errors](#Type-errors){#toc-Type-errors-1}
    -   [2.5 Questions for Chapter
        2](#Questions-for-Chapter-2){#toc-Questions-for-Chapter-2-1}
-   [3. The form of a C
    program](#The-form-of-a-C-program){#toc-The-form-of-a-C-program-1}
    -   [3.1 A word about
        style](#A-word-about-style){#toc-A-word-about-style-1}
    -   [3.2 Comments](#Comments){#toc-Comments-1}
    -   [3.3 Example 1](#Example-comment){#toc-Example-1}
    -   [3.4 Questions for Chapter
        3](#Questions-for-Chapter-3){#toc-Questions-for-Chapter-3-1}
-   [4. Functions](#Functions){#toc-Functions-1}
    -   [4.1 Function names](#Function-names){#toc-Function-names-1}
    -   [4.2 Function
        examples](#Function-examples){#toc-Function-examples-1}
    -   [4.3 Functions with
        values](#Functions-with-values){#toc-Functions-with-values-1}
    -   [4.4 Function
        prototyping](#Function-prototyping){#toc-Function-prototyping-1}
    -   [4.5 The `exit`
        function](#The-exit-function){#toc-The-exit-function-1}
    -   [4.6 Questions for Chapter
        4](#Questions-for-Chapter-4){#toc-Questions-for-Chapter-4-1}
-   [5. Variables and
    declarations](#Variables-and-declarations){#toc-Variables-and-declarations-1}
    -   [5.1 Integer
        variables](#Integer-variables){#toc-Integer-variables-1}
        -   [5.1.1 The `char`
            type](#The-char-type){#toc-The-char-type-1}
        -   [5.1.2 Floating point
            variables](#Floating-point-variables){#toc-Floating-point-variables-1}
    -   [5.2 Declarations](#Declarations){#toc-Declarations-1}
    -   [5.3 Initialization](#Initialization){#toc-Initialization-1}
    -   [5.4 The cast
        operator](#The-cast-operator){#toc-The-cast-operator-1}
        -   [5.4.1 Cast operator
            demo](#Cast-operator-demo){#toc-Cast-operator-demo-1}
    -   [5.5 Storage classes](#Storage-classes){#toc-Storage-classes-1}
        -   [5.5.1 External
            variables](#External-variables){#toc-External-variables-1}
        -   [5.5.2 Static
            variables](#Static-variables){#toc-Static-variables-1}
        -   [5.5.3 Other storage
            classes](#Other-storage-classes){#toc-Other-storage-classes-1}
    -   [5.6 Questions for Chapter
        5](#Questions-for-Chapter-5){#toc-Questions-for-Chapter-5-1}
-   [6. Scope](#Scope){#toc-Scope-1}
    -   [6.1 Global Variables](#Global-variables){#toc-Global-Variables}
    -   [6.2 Local Variables](#Local-variables){#toc-Local-Variables}
    -   [6.3 Communication via
        parameters](#Communication-via-parameters){#toc-Communication-via-parameters-1}
    -   [6.4 Scope example](#Scope-example){#toc-Scope-example-1}
    -   [6.5 Questions for Chapter
        6](#Questions-for-Chapter-6){#toc-Questions-for-Chapter-6-1}
-   [7. Expressions and
    operators](#Expressions-and-operators){#toc-Expressions-and-operators-1}
    -   [7.1 The assignment
        operator](#The-assignment-operator){#toc-The-assignment-operator-1}
        -   [7.1.1 Important note about
            assignment](#Important-note-about-assignment){#toc-Important-note-about-assignment-1}
    -   [7.2 Expressions and
        values](#Expressions-and-values){#toc-Expressions-and-values-1}
    -   [7.3 Expressions](#Expressions){#toc-Expressions-1}
    -   [7.4 Parentheses and
        Priority](#Parentheses-and-Priority){#toc-Parentheses-and-Priority-1}
    -   [7.5 Unary Operator
        Precedence](#Unary-Operator-Precedence){#toc-Unary-Operator-Precedence-1}
    -   [7.6 Special Assignment Operators `++` and
        `--`](#Special-Assignment-Operators-_002b_002b-_002d_002d){#toc-Special-Assignment-Operators-_002b_002b-and-_002d_002d}
    -   [7.7 More Special
        Assignments](#More-Special-Assignments){#toc-More-Special-Assignments-1}
    -   [7.8 Comparisons and
        logic](#Comparisons-and-logic){#toc-Comparisons-and-logic-1}
    -   [7.9 Logical
        operators](#Logical-operators){#toc-Logical-operators-1}
        -   [7.9.1 Inclusive OR](#Inclusive-OR){#toc-Inclusive-OR-1}
    -   [7.10 Questions for Chapter
        7](#Questions-for-Chapter-7){#toc-Questions-for-Chapter-7-1}
-   [8. Parameters](#Parameters){#toc-Parameters-1}
    -   [8.1 Parameters in function
        prototypes](#Parameters-in-function-prototypes){#toc-Parameters-in-function-prototypes-1}
    -   [8.2 Value Parameters](#Value-parameters){#toc-Value-Parameters}
    -   [8.3 Actual parameters and formal
        parameters](#Actual-parameters-and-formal-parameters){#toc-Actual-parameters-and-formal-parameters-1}
    -   [8.4 Variadic
        functions](#Variadic-functions){#toc-Variadic-functions-1}
    -   [8.5 Questions for Chapter
        8](#Questions-for-Chapter-8){#toc-Questions-for-Chapter-8-1}
-   [9. Pointers](#Pointers){#toc-Pointers-1}
    -   [9.1 Pointer
        operators](#Pointer-operators){#toc-Pointer-operators-1}
    -   [9.2 Pointer types](#Pointer-types){#toc-Pointer-types-1}
    -   [9.3 Pointers and
        initialization](#Pointers-and-initialization){#toc-Pointers-and-initialization-1}
    -   [9.4 Variable
        parameters](#Variable-parameters){#toc-Variable-parameters-1}
        -   [9.4.1 Passing pointers
            correctly](#Passing-pointers-correctly){#toc-Passing-pointers-correctly-1}
        -   [9.4.2 Another variable parameter
            example](#Another-variable-parameter-example){#toc-Another-variable-parameter-example-1}
    -   [9.5 Questions for Chapter
        9](#Questions-for-Chapter-9){#toc-Questions-for-Chapter-9-1}
-   [10. Decisions](#Decisions){#toc-Decisions-1}
    -   [10.1 `if`](#if){#toc-if-1}
    -   [10.2
        `if… else…`](#if_002e_002e_002e-else_002e_002e_002e){#toc-if_2026-else_2026}
    -   [10.3 Nested `if`
        statements](#Nested-if-statements){#toc-Nested-if-statements-1}
    -   [10.4 The `?`...`:`...
        operator](#The-question-mark-operator){#toc-The-_003f_2026_003a_2026-operator}
    -   [10.5 The `switch`
        statement](#The-switch-statement){#toc-The-switch-statement-1}
    -   [10.6 Example Listing](#Example-15){#toc-Example-Listing}
    -   [10.7 Questions for Chapter
        10](#Questions-for-Chapter-10){#toc-Questions-for-Chapter-10-1}
-   [11. Loops](#Loops){#toc-Loops-1}
    -   [11.1 `while`](#while){#toc-while-1}
    -   [11.2
        `do`...`while`](#do_002e_002e_002ewhile){#toc-do_2026while}
    -   [11.3 `for`](#for){#toc-for-1}
    -   [11.4 The flexibility of
        `for`](#The-flexibility-of-for){#toc-The-flexibility-of-for-1}
    -   [11.5 Terminating and speeding
        loops](#Terminating-and-speeding-loops){#toc-Terminating-and-speeding-loops-1}
        -   [11.5.1 Terminating loops with
            `break`](#Terminating-loops-with-break){#toc-Terminating-loops-with-break-1}
        -   [11.5.2 Terminating loops with
            `return`](#Terminating-loops-with-return){#toc-Terminating-loops-with-return-1}
        -   [11.5.3 Speeding loops with
            `continue`](#Speeding-loops-with-continue){#toc-Speeding-loops-with-continue-1}
    -   [11.6 Nested loops](#Nested-loops){#toc-Nested-loops-1}
    -   [11.7 Questions for Chapter
        11](#Questions-for-Chapter-11){#toc-Questions-for-Chapter-11-1}
-   [12. Preprocessor
    directives](#Preprocessor-directives){#toc-Preprocessor-directives-1}
    -   [12.1 A few
        directives](#A-few-directives){#toc-A-few-directives-1}
    -   [12.2 Macros](#Macros){#toc-Macros-1}
        -   [12.2.1 Macro
            functions](#Macro-functions){#toc-Macro-functions-1}
    -   [12.3 Extended macro
        example](#Extended-macro-example){#toc-Extended-macro-example-1}
    -   [12.4 Questions](#Questions-12){#toc-Questions}
-   [13. Libraries](#Libraries){#toc-Libraries-1}
    -   [13.1 Header files](#Header-files){#toc-Header-files-1}
    -   [13.2 Kinds of
        library](#Kinds-of-library){#toc-Kinds-of-library-1}
    -   [13.3 Common library
        functions](#Common-library-functions){#toc-Common-library-functions-1}
        -   [13.3.1 Character
            handling](#Character-handling){#toc-Character-handling-1}
    -   [13.4 Mathematical
        functions](#Mathematical-functions){#toc-Mathematical-functions-1}
    -   [13.5 Questions for Chapter
        13](#Questions-for-Chapter-13){#toc-Questions-for-Chapter-13-1}
-   [14. Arrays](#Arrays){#toc-Arrays-1}
    -   [14.1 Array bounds](#Array-bounds){#toc-Array-bounds-1}
    -   [14.2 Arrays and `for`
        loops](#Arrays-and-for-loops){#toc-Arrays-and-for-loops-1}
    -   [14.3 Multidimensional
        arrays](#Multidimensional-arrays){#toc-Multidimensional-arrays-1}
    -   [14.4 Arrays and nested
        loops](#Arrays-and-nested-loops){#toc-Arrays-and-nested-loops-1}
    -   [14.5 Initializing
        arrays](#Initializing-arrays){#toc-Initializing-arrays-1}
    -   [14.6 Arrays as
        Parameters](#Arrays-as-Parameters){#toc-Arrays-as-Parameters-1}
    -   [14.7 Questions for Chapter
        14](#Questions-for-Chapter-14){#toc-Questions-for-Chapter-14-1}
-   [15. Strings](#Strings){#toc-Strings-1}
    -   [15.1 Conventions and
        declarations](#Conventions-and-declarations){#toc-Conventions-and-declarations-1}
    -   [15.2 Initializing
        strings](#Initializing-strings){#toc-Initializing-strings-1}
    -   [15.3 String arrays](#String-arrays){#toc-String-arrays-1}
    -   [15.4 String library
        functions](#String-library-functions){#toc-String-library-functions-1}
    -   [15.5 Questions for Chapter
        15](#Questions-for-Chapter-15){#toc-Questions-for-Chapter-15-1}
-   [16. Input and output](#Input-and-output){#toc-Input-and-output-1}
    -   [16.1 High-level file
        routines](#High_002dlevel-file-routines){#toc-High_002dlevel-file-routines-1}
        -   [16.1.1 Opening a
            file](#Opening-a-file){#toc-Opening-a-file-1}
        -   [16.1.2 Closing a
            file](#Closing-a-file){#toc-Closing-a-file-1}
        -   [16.1.3 Block input and
            output](#Block-input-and-output){#toc-Block-input-and-output-1}
        -   [16.1.4 File position](#File-position){#toc-File-position-1}
        -   [16.1.5 Stream
            buffering](#Stream-buffering){#toc-Stream-buffering-1}
        -   [16.1.6 End-of-file and error
            functions](#End_002dof_002dfile-and-error-functions){#toc-End_002dof_002dfile-and-error-functions-1}
    -   [16.2 String output and
        input](#String-output-and-input){#toc-String-output-and-input-1}
        -   [16.2.1 Unformatted string
            output](#Unformatted-string-output){#toc-Unformatted-string-output-1}
            -   [16.2.1.1 `puts`](#puts){#toc-puts-1}
            -   [16.2.1.2 `fputs`](#fputs){#toc-fputs-1}
        -   [16.2.2 Formatted string
            output](#Formatted-string-output){#toc-Formatted-string-output-1}
            -   [16.2.2.1 `printf`](#printf){#toc-printf-1}
            -   [16.2.2.2 Formatted output conversion
                specifiers](#Formatted-output-conversion-specifiers){#toc-Formatted-output-conversion-specifiers-1}
        -   [16.2.3 `fprintf`](#fprintf){#toc-fprintf-1}
        -   [16.2.4 `asprintf`](#asprintf){#toc-asprintf-1}
        -   [16.2.5 Deprecated formatted string output
            functions](#Deprecated-formatted-string-output-functions){#toc-Deprecated-formatted-string-output-functions-1}
            -   [16.2.5.1 `sprintf`](#sprintf){#toc-sprintf-1}
        -   [16.2.6 String input](#String-input){#toc-String-input-1}
            -   [16.2.6.1 `getline`](#getline){#toc-getline-1}
            -   [16.2.6.2 `getdelim`](#getdelim){#toc-getdelim-1}
        -   [16.2.7 Deprecated string input
            functions](#Deprecated-string-input-functions){#toc-Deprecated-string-input-functions-1}
            -   [16.2.7.1 `gets`](#gets){#toc-gets-1}
            -   [16.2.7.2 `fgets`](#fgets){#toc-fgets-1}
        -   [16.2.8 Formatted string
            input](#Formatted-string-input){#toc-Formatted-string-input-1}
            -   [16.2.8.1 `sscanf`](#sscanf){#toc-sscanf-1}
            -   [16.2.8.2 Formatted input conversion
                specifiers](#Formatted-input-conversion-specifiers){#toc-Formatted-input-conversion-specifiers-1}
        -   [16.2.9 Deprecated formatted string input
            functions](#Deprecated-formatted-string-input-functions){#toc-Deprecated-formatted-string-input-functions-1}
            -   [16.2.9.1 `scanf`](#scanf){#toc-scanf-1}
            -   [16.2.9.2 String overflows with
                scanf](#String-overflows-with-scanf){#toc-String-overflows-with-scanf-1}
        -   [16.2.10 `fscanf`](#fscanf){#toc-fscanf-1}
    -   [16.3 Single-character input and
        output](#Single_002dcharacter-input-and-output){#toc-Single_002dcharacter-input-and-output-1}
        -   [16.3.1 `getchar`](#getchar){#toc-getchar-1}
        -   [16.3.2 `putchar`](#putchar){#toc-putchar-1}
        -   [16.3.3 `getc` and
            `fgetc`](#getc-and-fgetc){#toc-getc-and-fgetc-1}
        -   [16.3.4 `putc` and
            `fputc`](#putc-and-fputc){#toc-putc-and-fputc-1}
        -   [16.3.5 `ungetc()`](#ungetc){#toc-ungetc_0028_0029}
    -   [16.4 Programming with
        pipes](#Programming-with-pipes){#toc-Programming-with-pipes-1}
    -   [16.5 Low-level file
        routines](#Low_002dlevel-file-routines){#toc-Low_002dlevel-file-routines-1}
        -   [16.5.1 Usual file name
            errors](#Usual-file-name-errors){#toc-Usual-file-name-errors-1}
        -   [16.5.2 Opening files at a low
            level](#Opening-files-at-a-low-level){#toc-Opening-files-at-a-low-level-1}
            -   [16.5.2.1 File
                creation](#File-creation){#toc-File-creation-1}
        -   [16.5.3 Closing files at a low
            level](#Closing-files-at-a-low-level){#toc-Closing-files-at-a-low-level-1}
        -   [16.5.4 Reading files at a low
            level](#Reading-files-at-a-low-level){#toc-Reading-files-at-a-low-level-1}
        -   [16.5.5 Writing files at a low
            level](#Writing-files-at-a-low-level){#toc-Writing-files-at-a-low-level-1}
        -   [16.5.6 Finding file positions at a low
            level](#Finding-file-positions-at-a-low-level){#toc-Finding-file-positions-at-a-low-level-1}
        -   [16.5.7 Deleting files at a low
            level](#Deleting-files-at-a-low-level){#toc-Deleting-files-at-a-low-level-1}
        -   [16.5.8 Renaming files at a low
            level](#Renaming-files-at-a-low-level){#toc-Renaming-files-at-a-low-level-1}
    -   [16.6 Questions](#Questions-16){#toc-Questions-1}
-   [17. Putting a program
    together](#Putting-a-program-together){#toc-Putting-a-program-together-1}
    -   [17.1 `argc` and `argv`](#argc-and-argv){#toc-argc-and-argv-1}
    -   [17.2 Processing command-line
        options](#Processing-command_002dline-options){#toc-Processing-command_002dline-options-1}
        -   [17.2.1 `argp`
            description](#argp-description){#toc-argp-description-1}
        -   [17.2.2 `argp` example](#argp-example){#toc-argp-example-1}
    -   [17.3 Environment
        variables](#Environment-variables){#toc-Environment-variables-1}
    -   [17.4 Compiling multiple
        files](#Compiling-multiple-files){#toc-Compiling-multiple-files-1}
    -   [17.5 Writing a
        makefile](#Writing-a-makefile){#toc-Writing-a-makefile-1}
        -   [17.5.1 What a Rule Looks
            Like](#Rule-Introduction){#toc-What-a-Rule-Looks-Like}
        -   [17.5.2 A simple
            makefile](#A-simple-makefile){#toc-A-simple-makefile-1}
        -   [17.5.3 make in
            action](#make-in-action){#toc-make-in-action-1}
        -   [17.5.4 Variables simplify
            makefiles](#Variables-simplify-makefiles){#toc-Variables-simplify-makefiles-1}
        -   [17.5.5 Letting make deduce
            commands](#Letting-make-deduce-commands){#toc-Letting-make-deduce-commands-1}
        -   [17.5.6 Combining rules by
            prerequisite](#Combining-rules-by-prerequisite){#toc-Combining-rules-by-prerequisite-1}
        -   [17.5.7 Rules for cleaning the
            directory](#Rules-for-cleaning-the-directory){#toc-Rules-for-cleaning-the-directory-1}
    -   [17.6 Building a
        library](#Building-a-library){#toc-Building-a-library-1}
    -   [17.7 Questions](#Questions-17){#toc-Questions-2}
-   [18. Advanced
    operators](#Advanced-operators){#toc-Advanced-operators-1}
    -   [18.1 Hidden operators and
        values](#Hidden-operators-and-values){#toc-Hidden-operators-and-values-1}
        -   [18.1.1 Hidden
            assignments](#Hidden-assignments){#toc-Hidden-assignments-1}
        -   [18.1.2 Postfix and prefix `++` and
            `--`](#Postfix-and-prefix-_002b_002b-and-_002d_002d){#toc-Postfix-and-prefix-_002b_002b-and-_002d_002d-1}
        -   [18.1.3 Arrays and hidden
            operators](#Arrays-and-hidden-operators){#toc-Arrays-and-hidden-operators-1}
        -   [18.1.4 A warning about
            style](#A-warning-about-style){#toc-A-warning-about-style-1}
    -   [18.2 The comma
        operator](#The-comma-operator){#toc-The-comma-operator-1}
    -   [18.3 Machine-level
        operators](#Machine_002dlevel-operators){#toc-Machine_002dlevel-operators-1}
        -   [18.3.1 Bitwise
            operators](#Bitwise-operators){#toc-Bitwise-operators-1}
        -   [18.3.2 Shift
            operations](#Shift-operations){#toc-Shift-operations-1}
        -   [18.3.3 Truth tables and bit
            masks](#Truth-tables-and-bit-masks){#toc-Truth-tables-and-bit-masks-1}
            -   [18.3.3.1 Bitwise NOT](#Bitwise-NOT){#toc-Bitwise-NOT-1}
            -   [18.3.3.2 Bitwise AND](#Bitwise-AND){#toc-Bitwise-AND-1}
            -   [18.3.3.3 Bitwise inclusive
                OR](#Bitwise-inclusive-OR){#toc-Bitwise-inclusive-OR-1}
            -   [18.3.3.4 Bitwise exclusive OR
                (XOR/EOR)](#Bitwise-exclusive-OR-_0028XOR_002fEOR_0029){#toc-Bitwise-exclusive-OR-_0028XOR_002fEOR_0029-1}
            -   [18.3.3.5 Masks](#Masks){#toc-Masks-1}
    -   [18.4 Questions 18](#Questions-18){#toc-Questions-18-1}
-   [19. More data types](#More-data-types){#toc-More-data-types-1}
    -   [19.1 `enum`](#enum){#toc-enum-1}
    -   [19.2 `void`](#void){#toc-void-1}
    -   [19.3 `volatile`](#volatile){#toc-volatile-1}
    -   [19.4 Constants](#Constants){#toc-Constants-1}
        -   [19.4.1 `const`](#const){#toc-const-1}
        -   [19.4.2 Constant
            expressions](#Constant-expressions){#toc-Constant-expressions-1}
    -   [19.5 `struct` and
        `union`](#struct-and-union){#toc-struct-and-union-1}
    -   [19.6 `typedef`](#typedef){#toc-typedef-1}
    -   [19.7 Questions 19](#Questions-19){#toc-Questions-19-1}
-   [20. Data structures](#Data-structures){#toc-Data-structures-1}
    -   [20.1 `struct`](#struct){#toc-struct-1}
        -   [20.1.1 Structure
            declarations](#Structure-declarations){#toc-Structure-declarations-1}
            -   [20.1.1.1 Structure declarations using
                typedef](#Structure-declarations-using-typedef){#toc-Structure-declarations-using-typedef-1}
        -   [20.1.2 Using
            structures](#Using-structures){#toc-Using-structures-1}
        -   [20.1.3 Arrays of
            structures](#Arrays-of-structures){#toc-Arrays-of-structures-1}
        -   [20.1.4 Nested
            structures](#Nested-structures){#toc-Nested-structures-1}
        -   [20.1.5 Pointers to
            structures](#Pointers-to-structures){#toc-Pointers-to-structures-1}
        -   [20.1.6 Initializing
            structures](#Initializing-structures){#toc-Initializing-structures-1}
    -   [20.2 Memory
        allocation](#Memory-allocation){#toc-Memory-allocation-1}
    -   [20.3 `union`](#union){#toc-union-1}
        -   [20.3.1 Declaration of
            unions](#Declaration-of-unions){#toc-Declaration-of-unions-1}
        -   [20.3.2 Using unions](#Using-unions){#toc-Using-unions-1}
    -   [20.4 Complex data
        structures](#Complex-data-structures){#toc-Complex-data-structures-1}
        -   [20.4.1 Data structure
            diagrams](#Data-structure-diagrams){#toc-Data-structure-diagrams-1}
        -   [20.4.2 Dynamic data structures, Pointers and Dynamic
            Memory](#Dynamic-data-structures){#toc-Dynamic-data-structures_002c-Pointers-and-Dynamic-Memory}
        -   [20.4.3 Lists and
            trees](#Lists-and-trees){#toc-Lists-and-trees-1}
            -   [20.4.3.1 Linked
                lists.](#Linked-lists){#toc-Linked-lists_002e}
            -   [20.4.3.2 Binary
                trees](#Binary-trees){#toc-Binary-trees-1}
        -   [20.4.4 Setting up a data
            structure](#Setting-up-a-data-structure){#toc-Setting-up-a-data-structure-1}
            -   [20.4.4.1 Designing your data
                structure](#Designing-your-data-structure){#toc-Designing-your-data-structure-1}
            -   [20.4.4.2 Initializing your data
                structure](#Initializing-your-data-structure){#toc-Initializing-your-data-structure-1}
    -   [20.5 Further data structure
        examples](#Further-data-structure-examples){#toc-Further-data-structure-examples-1}
    -   [20.6 Questions 20](#Questions-20){#toc-Questions-20-1}
-   [21. Recursion](#Recursion){#toc-Recursion-1}
    -   [21.1 The stack](#The-stack){#toc-The-stack-1}
        -   [21.1.1 The stack in
            detail](#The-stack-in-detail){#toc-The-stack-in-detail-1}
    -   [21.2 Controlled
        recursion](#Controlled-recursion){#toc-Controlled-recursion-1}
    -   [21.3 Controlled recursion with data
        structures](#Controlled-recursion-with-data-structures){#toc-Controlled-recursion-with-data-structures-1}
    -   [21.4 Recursion
        summary](#Recursion-summary){#toc-Recursion-summary-1}
    -   [21.5 Questions 21](#Questions-21){#toc-Questions-21-1}
-   [22. Style](#Style){#toc-Style-1}
    -   [22.1 Formatting code](#Formatting-code){#toc-Formatting-code-1}
    -   [22.2 Comments and
        style](#Comments-and-style){#toc-Comments-and-style-1}
    -   [22.3 Variable and function
        names](#Variable-and-function-names){#toc-Variable-and-function-names-1}
    -   [22.4 Declarations and
        initialization](#Declarations-and-initialization){#toc-Declarations-and-initialization-1}
    -   [22.5 Global variables and
        style](#Global-variables-and-style){#toc-Global-variables-and-style-1}
    -   [22.6 Hidden operators and
        style](#Hidden-operators-and-style){#toc-Hidden-operators-and-style-1}
    -   [22.7 Final words on
        style](#Final-words-on-style){#toc-Final-words-on-style-1}
    -   [22.8 Questions 22](#Questions-22){#toc-Questions-22-1}
-   [23. Debugging](#Debugging){#toc-Debugging-1}
    -   [23.1 Compile-time
        errors](#Compile_002dtime-errors){#toc-Compile_002dtime-errors-1}
        -   [23.1.1 parse error at..., parse error
            before...](#parse-error-at_002e_002e_002e){#toc-parse-error-at_2026_002c-parse-error-before_2026}
        -   [23.1.2 undefined reference
            to...](#undefined-reference-to_002e_002e_002e){#toc-undefined-reference-to_2026}
        -   [23.1.3 unterminated string or character
            constant](#unterminated-string-or-character-constant){#toc-unterminated-string-or-character-constant-1}
    -   [23.2 ...undeclared (first use in this
        function)](#g_t_002e_002e_002eundeclared-_0028first-use-in-this-function_0029){#toc-_2026undeclared-_0028first-use-in-this-function_0029}
        -   [23.2.1 different type
            arg](#different-type-arg){#toc-different-type-arg-1}
        -   [23.2.2 too few parameters..., too many
            parameters...](#too-few-parameters_002e_002e_002e){#toc-too-few-parameters_2026_002c-too-many-parameters_2026}
    -   [23.3 Run-time
        errors](#Run_002dtime-errors){#toc-Run_002dtime-errors-1}
        -   [23.3.1 Confusion of `=` and
            `==`](#Confusion-of-_003d-and-_003d_003d){#toc-Confusion-of-_003d-and-_003d_003d-1}
        -   [23.3.2 Confusing `foo++` and
            `++foo`](#Confusing-foo_002b_002b-and-_002b_002bfoo){#toc-Confusing-foo_002b_002b-and-_002b_002bfoo-1}
        -   [23.3.3 Unwarranted assumptions about
            storage](#Unwarranted-assumptions-about-storage){#toc-Unwarranted-assumptions-about-storage-1}
        -   [23.3.4 Array out of
            bounds](#Array-out-of-bounds){#toc-Array-out-of-bounds-1}
        -   [23.3.5 Uncoordinated
            output](#Uncoordinated-output){#toc-Uncoordinated-output-1}
        -   [23.3.6 Global variables and
            recursion](#Global-variables-and-recursion){#toc-Global-variables-and-recursion-1}
    -   [23.4 Mathematical
        errors](#Mathematical-errors){#toc-Mathematical-errors-1}
    -   [23.5 Introduction to
        GDB](#Introduction-to-GDB){#toc-Introduction-to-GDB-1}
    -   [23.6 Questions 23](#Questions-23){#toc-Questions-23-1}
-   [24. Example programs](#Example-programs){#toc-Example-programs-1}
-   [A. A note from the original
    author](#A-note-from-the-original-author){#toc-A-note-from-the-original-author-1}
-   [B. Reserved words in
    C](#Reserved-words-in-C){#toc-Reserved-words-in-C-1}
-   [C. Precedence of
    operators](#Precedence-of-operators){#toc-Precedence-of-operators-1}
-   [D. Special
    characters](#Special-characters){#toc-Special-characters-1}
-   [E. Character conversion
    table](#Character-conversion-table){#toc-Character-conversion-table-1}
-   [F. A word about
    `goto`](#A-word-about-goto){#toc-A-word-about-goto-1}
-   [G. Answers to
    questions](#Answers-to-questions){#toc-Answers-to-questions-1}
-   [Bibliography](#Bibliography){#toc-Bibliography-1}
-   [Glossary](#Glossary){#toc-Glossary-1}
-   [Code index](#Code-index){#toc-Code-index-1}
-   [Concept index](#Concept-index){#toc-Concept-index-1}
-   [Bits and pieces](#Bits-and-pieces){#toc-Bits-and-pieces-1}
    -   [G.1 Allocating memory for
        strings](#Allocating-memory-for-strings){#toc-Allocating-memory-for-strings-1}
    -   [G.2 Characters](#Characters){#toc-Characters-1}
    -   [G.3 Assigning variables to one
        another](#Assigning-variables-to-one-another){#toc-Assigning-variables-to-one-another-1}
    -   [G.4 Function
        pointers](#Function-pointers){#toc-Function-pointers-1}
:::

------------------------------------------------------------------------

[]{#SEC_About}

  ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------
  \[[Top](#Top "Cover (top) of document")\]   \[[Contents](#SEC_Contents "Table of contents")\]   \[[Index](#Code-index "Index")\]   \[[?](#SEC_About "About (help)")\]
  ------------------------------------------- --------------------------------------------------- ---------------------------------- ------------------------------------

About This Document
===================

This document was generated by *HS Rai* on *September 22, 2019* using
[*texi2html 1.82*](http://www.nongnu.org/texi2html/).

The buttons in the navigation panels have the following meaning:

      Button         Name      Go to                                           From 1.2.3 go to
  -------------- ------------- ----------------------------------------------- ------------------
     \[ \< \]        Back      Previous section in reading order               1.2.2
     \[ \> \]       Forward    Next section in reading order                   1.2.4
    \[ \<\< \]     FastBack    Beginning of this chapter or previous chapter   1
     \[ Up \]         Up       Up section                                      1.2
    \[ \>\> \]    FastForward  Next chapter                                    2
     \[Top\]          Top      Cover (top) of document                          
   \[Contents\]    Contents    Table of contents                                
    \[Index\]        Index     Index                                            
     \[ ? \]         About     About (help)                                     

where the **Example** assumes that the current position is at
**Subsubsection One-Two-Three** of a document of the following
structure:

-   1\. Section One
    -   1.1 Subsection One-One
        -   \...
    -   1.2 Subsection One-Two
        -   1.2.1 Subsubsection One-Two-One
        -   1.2.2 Subsubsection One-Two-Two
        -   1.2.3 Subsubsection One-Two-Three     **\<== Current
            Position**
        -   1.2.4 Subsubsection One-Two-Four
    -   1.3 Subsection One-Three
        -   \...
    -   1.4 Subsection One-Four

------------------------------------------------------------------------

This document was generated by *HS Rai* on *September 22, 2019* using
[*texi2html 1.82*](http://www.nongnu.org/texi2html/).\
